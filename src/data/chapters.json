[
  {
    "id": 1,
    "language": "Python",
    "title": "Variables",
    "content": "\n    <p>In Python, we have several data types that are used to store different kinds of information:</p>\n    <ul class=inText>\n        <li>Integer: Represents whole numbers without a decimal component.</li>\n        <li>String: A sequence of characters enclosed within quotes.</li>\n        <li>Float: Represents numbers that contain a decimal point.</li>\n        <li>Boolean: Represents one of two values, True or False.</li>\n        <li>List: An ordered collection of items enclosed within square brackets.</li>\n        <li>Dictionary: A collection of key-value pairs enclosed within curly braces.</li>\n        <li>Tuple: An ordered collection of items enclosed within parentheses.</li>\n    </ul>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>my_number = 1000      # Integer\nmy_text = \"Hello!\"    # String\nmy_float = 7.5        # Float\nmy_bool_1 = True      # Boolean\nmy_bool_2 = False     # Boolean\nmy_list = []          # List\nmy_dictionary = {}    # Dictionary\nmy_tuple = (1, 2, 3)  # Tuple</code></pre>\n    \n    <p>These data types are essential for storing and manipulating different kinds of information in Python.</p>\n    <p>The name you see before the '=' is what's called a \"variable\". You can name it whatever you want! Above you can see how I named my variables eg; my_number, my_text, my_float, my_bool_1.</p>\n    <p>It's good practice to name your variable relevant to its purpose. For example if I was creating a variable that would represent the cash price of an item, I might name it something like:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>item_cost = 1                       # The cost of an item, which will be 1 dollar\nsupply_remaining = 2_500_000_000    # The number of items in inventory that are remaining, Note that we use '_' instead of commas as a separator\nname_CTO = \"John Woods\"\nvalue_of_a_quarter = 0.25</code></pre>\n    \n    <p>You might notice that I use the underscore symbol \"_\" instead of spaces in my variable. Something to keep in mind is you cannot start a variable with an integer, use any special characters aside from \"_\", and you cannot use spaces.\n    Here are some examples of incorrect variables that will not work in your code, and will cause an error, <strong>DO NOT USE</strong>:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>3variable = 5     # Starts with a number\nmy-variable = 6   # Contains a hyphen\nmy variable = 7   # Contains a space</code></pre>\n    \n    <h2>General Arithmetic for Integers, Floats, and Strings</h2>\n    \n    <p>General arithmetic operations are a great place to start! Let's try creating a number variable, and printing it to the console.</p>\n    <p>If this is your first time programming, or even if you have programmed before, you'll quickly find out or are already familiar that printing is one of the most commonly used functions for debugging. It's how you \"see\" what the value is of your variable at a specific point in your code.</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>my_number = 1\nmy_number_plus_one = my_number + 1\nprint(my_number_plus_one)</code></pre>\n    \n    <p>The steps that occur here:</p>\n    <ol class=inText>\n    <li>Created my \"my_number\" variable and assigned it to the integer 1</li>\n    <li>Created another variable called \"my_number_plus_one\" and assigned it to what \"my_number\" is when 1 is added to it</li>\n    <li>Used the \"print()\" function to see the value in my terminal</li>\n    </ol>\n    \n    <p>There are several arithmetic operators (Like \"+\" or \"-\") available in Python, and they are as follows:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>a = 10\nb = 3\naddition = a + b          # Addition: 13\nsubtraction = a - b       # Subtraction: 7\nmultiplication = a * b    # Multiplication: 30\ndivision = a / b          # Division: 3.3333333333333335\nfloor_division = a // b   # Floor Division: 3\nmodulus = a % b           # Modulus: 1\nexponentiation = a ** b   # Exponentiation: 1000</code></pre>\n    \n    <p>Similar to integers and floats, you can also use arithmetic operators on strings, these are mostly limited to:</p>\n    <ul class=inText>\n    <li>Addition and multiplication: +, *</li>\n    </ul>\n    <p>The act of combining strings together or multiplying a single string is often referred to as <strong>concatenation</strong>.</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>result = \"Hello, \" + \"World!\"\nprint(result) # result is \"Hello, World!\"\nstring = \"Hello\"\nresult = string * 3\nprint(result) # result is \"HelloHelloHello\"</code></pre>\n    \n    <p>We won't dive into Lists, Dictionaries, or Tuples just yet, but I would like to mention, and this is something you'll see in practice later— that lists and dictionaries are mutable, whereas tuples are immutable.\n    When you hear mutable, think \"can be changed\", where mutable means it can be changed and immutable means it cannot be changed.</p>\n    \n    <p>Example:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>my_tuple = (1, 2)\nprint(my_tuple[0])\nmy_tuple[0] = 2\nprint(my_tuple)\n# ERROR\n#    my_tuple[0] = 2\n#    ~~~~~~~~^^^\n# TypeError: 'tuple' object does not support item assignment</code></pre>\n    \n    <p>A more advanced concept to start early with, but another thing we will review later:</p>\n    <h2>Examples of mutable and immutable parameters on an asset on Algorand</h2>\n    <strong>Immutable Parameters:</strong></br>\n    <p>These parameters can only be specified when an asset is created.</p>\n    <ul class=inText>\n    <li>Creator: The address of the account that created the asset.</li>\n    <li>AssetName: The name of the asset.</li>\n    <li>UnitName: The unit name of the asset.</li>\n    <li>Total: The total number of units of the asset.</li>\n    <li>Decimals: The number of digits to use after the decimal point when displaying the asset.</li>\n    <li>DefaultFrozen: Whether the asset is frozen by default.</li>\n    <li>URL: A URL where more information about the asset can be retrieved.</li>\n    <li>MetaDataHash: A commitment to some unspecified asset metadata.</li>\n    </ul>\n    <strong>Mutable Parameters:</strong></br>\n    <p>These parameters can be changed after the asset is created.</p>\n    <ul class=inText>\n    <li>Manager: The address of the account that can change the asset's mutable parameters.</li>\n    <li>Reserve: The address of the account that holds the asset reserve. (Cannot be changed if initially not declared)</li>\n    <li>Freeze: The address of the account that can freeze or unfreeze user asset holdings. (Cannot be changed if initially not declared)</li>\n    <li>Clawback: The address of the account that can revoke user asset holdings and send them to other addresses. (Cannot be changed if initially not declared)</li>\n    </ul>\n    <em>*Note: Exception for various ARC types like ARC19 and ARC69 that use the reserve address and/or note field to point to metadata*</em>\n  \n      <hr><form class=\"quiz-form\">\n      <h1>Quiz</h1>\n          <h3>Question 1</h3>\n          <p>What data type is used to store whole numbers in Python?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) String</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) Float</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"correct\">c) Integer</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) Boolean</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which of the following is an example of a correct variable name in Python?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"incorrect\">a) 3variable</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) my-variable</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) my variable</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"correct\">d) my_variable</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the result of the following code snippet?</p>\n          <pre class=\"overflow-auto shadow-md\"><code>string = \"Hello\" \nresult = string * 3\nprint(result)</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"correct\">a) HelloHelloHello</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) Hello, Hello, Hello</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) Hello*3</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) Error</label><br>\n  \n          <h3>Question 4</h3>\n          <p>Which Python data type is immutable?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"incorrect\">a) Tuple</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) String</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"correct\">c) List</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) Integer</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "a = 10\nb = 3.5\nprint(a+b)"
  },
  {
    "id": 3,
    "language": "Python",
    "title": "Lists",
    "content": "\n    <p>Before we go over dictionaries, which are the most common datatype when sending and receiving information between applications (back-end to front-end, front-end to back-end, or back-end to websites, etc.), and this is especially true when interacting with the Algorand blockchain, I think it's important to have an understanding of how lists work.</p>\n    \n    <p>Below is an example of a list:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>my_list = [7, \"Hello\", False, 63.5]</code></pre>\n    \n    <p>A list can hold all types of data, and you can have all kinds of data in one list. You use lists when you need exactly that, a list. Lists are also mutable, as opposed to tuples—which means we can rearrange, extend, and replace items in a list, meaning they're super flexible!</p>\n    \n    <p>A list is a collection of data enclosed between square brackets [ ], and separated by commas. An example of common kinds of data you would have in a list on Algorand could be one that has asset ID's.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>asset_ids = [1265975021, 1138500612, 400593267]</code></pre>\n    \n    <p>Or perhaps a list of addresses:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>addresses = [\n'WWYUMYPM2Y5NIIZTF4O5N73A4ZTZQWXS6TNP23U37LQ6WWF543SRTGKWUU',\n'7IWZ342UGNQ2JVS2E6EGFD4MPUNL4ZIWDYNFZIANR6U7WZXORCRQCCN3YY',\n'HZ57J3K46JIJXILONBBZOHX6BKPXEM2VVXNRFSUED6DKFD5ZD24PMJ3MVA']</code></pre>\n    \n    <p>Although lists don't have to be organized in anyway and are not descriptive, they can be manipulated. For example, if you wanted to remove duplicate entries in a list, you could use the set() function.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>my_list = [1, 1, 2, 3, 4, 4]\nmy_list_without_duplicates = set(my_list)\nprint(my_list_without_duplicates)\n# Output:# [1, 2, 3, 4]</code></pre>\n    \n    <p>Let's look back at the first example of a list:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>my_list = [7, \"Hello\", False, 63.5]</code></pre>\n    \n    <p>In the list above we have an integer at the first spot, 7; a string in the second spot, \"Hello\"; a boolean (True or False value) in the third spot; a float (AKA decimal value), in the fourth spot.\n    I refer to the places these items are in the list as \"spots\", but the correct term is actually \"indexes\". We referenced them as the first, second, third, and fourth spot— however, in programming lists are zero-indexed. This means that we always start from zero, and use an integer to refer to their position in the list. This feels strange, but it is something you should have ingrained into your mind, as this is universal across all programming when indexing for positions in a list.</p>\n    \n    <p>The correct reference to the positions would be Index 0 for 7, Index 1 for \"Hello\", Index 2 for False, and Index 3 for 63.5. But, how would we see this utilized in a programming scenario?</p>\n    \n    <p>To interact with the list, we must first assign it to a variable:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>my_list = [7, \"Hello\", False, 63.5]</code></pre>\n    \n    <p>Now, we can use index notation to pick out items of our choice by using their position, let's start with just printing the list to the terminal:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>print(my_list)\n# Output: [7, \"Hello\", False, 63.5]</code></pre>\n    \n    <p>... and now lets print the item at index 1 (the second item since the first item is always 0) using index notation:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>first_index_my_list = my_list[1]\nprint(first_index_my_list)\n# Output: \"Hello\"</code></pre>\n    \n    <p>Try printing the third index into the using index notation into the code editor down below, I've already defined the list for you below, click run when you're ready to run the code! The output should be 63.5</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>my_list = [7, \"Hello\", False, 63.5]\"</code></pre>\n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n          <h3>Question 1</h3>\n          <p>What is the correct way to define a list in Python?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) my_list = {1, 2, 3}</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) my_list = (1, 2, 3)</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"correct\">c) my_list = [1, 2, 3]</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) my_list = 1, 2, 3</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which of the following statements about lists is true?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"incorrect\">a) Lists are immutable.</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"correct\">b) Lists can contain different types of data.</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) Lists are enclosed in parentheses ( ).</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) Lists are zero-indexed.</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the output of the following code?</p>\n          <pre class=\"overflow-auto shadow-md\"><code>my_list = [7, \"Hello\", False, 63.5]\nprint(my_list[2])</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) 7</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) \"Hello\"</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"correct\">c) False</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) 63.5</label><br>\n  \n          <h3>Question 4</h3>\n          <p>What is the correct way to remove duplicate entries in a list?</p>\n          <pre class=\"overflow-auto shadow-md\"><code>my_list = [1, 1, 2, 3, 4, 4]\nmy_list_without_duplicates = set(my_list)\nprint(my_list_without_duplicates)</code></pre>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) Using the set() function</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) Using the list() function</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) Using the dict() function</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) Using the tuple() function</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "my_list = [7, \"Hello\", False, 63.5]\nprint(my_list)"
  },
  {
    "id": 4,
    "language": "Python",
    "title": "Dictionaries",
    "content": "\n    <p>Now we'll dive into a bit more advanced data structures, dictionaries! A dictionary is like a list, except it uses curly brackets { } instead of square brackets [ ]— but most importantly, dictionaries also differ in that they store values with keys, and can accept several data types. A dictionary can be highly versatile, and can not only be used for data storage, but for more complex algorithms like hashmaps, which we'll go over later. Most interestingly, we can have dictionaries with dictionaries within them, and even lists as well! It's important to mention that keys and values have a colon ' : ' separator between them.</p>\n    \n    <p>Here's a simple example of a dictionary:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>this_is_my_dictionary = {\"name\": \"John\", \"age\": 22}</code></pre>\n    \n    <p>In lists, we used a process called indexing, and the index notation format to access values, eg; my_list[3]. With dictionaries, we use a similar process called key access, and the key notation format to access values.</p>\n    \n    <p>The main difference is that we use keys, instead of solely integers that refer to position, to select values from a dictionary— and not to confuse you, but a key in a dictionary can also be an integer =).</p>\n    \n    <p>For example, in this_is_my_dictionary above, you'll see the value \"John\" belongs to the key, \"name\". As well as the value 22, belongs to the key, \"age\". This is what key notation would look like for accessing a value for a specific key in a dictionary:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>name_value = this_is_my_dictionary['name']\nprint(name_value)\n# Output: \"John\"</code></pre>\n    \n    <p>Try printing the \"age\" value in the code editor below:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>age_value = this_is_my_dictionary['age']\nprint(age_value)\n# Output: 22</code></pre>\n    \n    <p>Now we'll look over a more intricate dictionary, that's a bit larger and complex.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>this_is_my_dictionary = {\"name\": \"John\", \"age\": 22, \"likes\": [\"Exercise\", \"Cooking\", \"Coding\"]}</code></pre>\n    \n    <p>We see something in this dictionary that we haven't seen before, a list as the value to a key. Let's try accessing the 1st index of John's likes using a mix of key notation and index notation!</p>\n    <pre class=\"overflow-auto shadow-md\"><code>likes = this_is_my_dictionary['likes']\nprint(likes)\n# Output:# [\"Exercise\", \"Cooking\", \"Coding\"]</code></pre>\n    \n    \n    <pre class=\"overflow-auto shadow-md\"><code>likes_first_index = likes[1]\nprint(likes_first_index)\n# Output:# \"Cooking\"</code></pre>\n  \n      <hr><form class=\"quiz-form\">\n      <h1>Quiz</h1>\n          <h3>Question 1</h3>\n          <p>What is the correct way to define a dictionary in Python?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) my_dict = [1: \"one\", 2: \"two\"]</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) my_dict = (1: \"one\", 2: \"two\")</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"correct\">c) my_dict = {1: \"one\", 2: \"two\"}</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) my_dict = 1: \"one\", 2: \"two\"</label><br>\n  \n          <h3>Question 2</h3>\n          <p>How do you access the value associated with a key in a dictionary?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) Using key notation</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) Using index notation</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) Using both key and index notation</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) Using value notation</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the output of the following code?</p>\n          <pre class=\"overflow-auto shadow-md\"><code>this_is_my_dictionary = {\"name\": \"John\", \"age\": 22}\nprint(this_is_my_dictionary['age'])</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) \"John\"</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"correct\">b) 22</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) \"age\"</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) \"name\"</label><br>\n  \n          <h3>Question 4</h3>\n          <p>What will be the output of the following code?</p>\n          <pre class=\"overflow-auto shadow-md\"><code>this_is_my_dictionary = {\"name\": \"John\", \"age\": 22, \"likes\": [\"Exercise\", \"Cooking\", \"Coding\"]}\nprint(this_is_my_dictionary['likes'][1])</code></pre>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"incorrect\">a) \"Exercise\"</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"correct\">b) \"Cooking\"</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) \"Coding\"</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) [\"Exercise\", \"Cooking\", \"Coding\"]</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "this_is_my_dictionary = {\"name\": \"John\", \"age\": 22}\nprint(this_is_my_dictionary)"
  },
  {
    "id": 2,
    "language": "Python",
    "title": "Functions",
    "content": "\n    <p>In Python, a function is a block of code that performs a specific task. Functions help to modularize code, making it more readable and reusable.</p>\n    <p>To define a function, we use the <code>def</code> keyword followed by the function name and parentheses. Inside the parentheses, we can specify parameters that the function can accept. The code block within every function starts with a colon (:) and is indented.</p>\n    <p>Let's start with a simple function that prints a greeting message:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>def greet():\n    print(\"Hello, world!\")\n</code></pre>\n    \n    <p>When we call the <code>greet()</code> function, it prints \"Hello, world!\" to the console.</p>\n    <p>Functions can also accept parameters, which allow us to pass values into the function for processing. Here's an example:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>def greet(name):\n    print(f\"Hello, {name}!\")\ngreet(\"Alice\")  # Output: \"Hello, Alice!\"\ngreet(\"Bob\")    # Output: \"Hello, Bob!\"</code></pre>\n    \n    <p>In this example, the <code>greet</code> function accepts one parameter <code>name</code>. When we call the function and pass in a value like \"Alice\" or \"Bob\", the function prints a personalized greeting message.</p>\n    <p>Functions can return values using the <code>return</code> statement. This allows us to capture the result of a function and use it in our code. Here's an example:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>def add(a, b):\n    return a + b\nresult = add(3, 5)\nprint(result)  # Output: 8</code></pre>\n    \n    <p>The <code>add</code> function takes two parameters <code>a</code> and <code>b</code>, adds them together, and returns the result. We can then store the returned value in a variable and print it.</p>\n    <p>Functions can have default parameter values, which are used if no argument is provided when the function is called. Here's an example:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>def greet(name=\"world\"):\n    print(f\"Hello, {name}!\")\ngreet()         # Output: Hello, world!\ngreet(\"Alice\")  # Output: Hello, Alice!</code></pre>\n    \n    <p>In this example, the <code>greet</code> function has a default parameter value of \"world\". If no argument is passed when the function is called, it uses the default value.</p>\n    <p>We can also define functions that accept a variable number of arguments using the <code>*args</code> and <code>**kwargs</code> syntax. Here's an example:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>def add(*args):\n    return sum(args)\nprint(add(1, 2, 3))        # Output: 6\nprint(add(4, 5, 6, 7))    # Output: 22</code></pre>\n    \n    <p>The <code>add</code> function uses <code>*args</code> to accept a variable number of arguments. Inside the function, <code>args</code> is a tuple containing all the arguments passed. We use the <code>sum</code> function to add all the values together and return the result.</p>\n    <p>The <code>**kwargs</code> syntax allows us to accept a variable number of keyword arguments. Here's an example:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>def print_info(**kwargs):\n    for key, value in kwargs.items():\n        print(f\"{key}: {value}\")\nprint_info(name=\"Alice\", age=30, city=\"New York\")</code></pre>\n    \n    <p>In this example, the <code>print_info</code> function uses <code>**kwargs</code> to accept a varying number of keyword arguments. Inside the function, <code>kwargs</code> is a dictionary containing all the keyword arguments passed. We loop through the dictionary and print each key-value pair.</p>\n    <p>Functions are a fundamental part of Python programming, enabling us to create modular, reusable, and maintainable code. As we progress, we'll explore more advanced concepts and techniques related to functions.</p>\n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What keyword is used to define a function in Python?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) func</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) function</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"correct\">c) def</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) define</label><br>\n  \n          <h3>Question 2</h3>\n          <p>What will be the output of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>def greet(name):\n    print(f\"Hello, {name}!\")  \ngreet(\"Alice\")</code></pre>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"incorrect\">a) Hello, world!</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"correct\">b) Hello, Alice!</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) Hello!</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) Alice, Hello!</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What does the following function return?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>def add(a, b):\n    return a + b  \nresult = add(3, 5)\nprint(result)</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) 35</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) 15</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"correct\">c) 8</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) 5</label><br>\n  \n          <h3>Question 4</h3>\n          <p>What will be the output of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>def greet(name=\"world\"):\n    print(f\"Hello, {name}!\")  \ngreet()</code></pre>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) Hello, world!</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) Hello, Alice!</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) Hello!</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) world, Hello!</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "def greet():\n    print(\"Hello, world!\")\ngreet()"
  },
  {
    "id": 5,
    "language": "Python",
    "title": "Imports",
    "content": "\n    <p>This code begins with module imports, which is a fancy way of saying— \"someone wrote some code that does something, and I want to use that something in my code\". It isn't possible to use libraries, which are just collections of code created by someone, without formally importing them at the beginning of your code. Imports must appear before usage of anything within them because like the English language, python interpreters read from top to bottom.</p>\n    \n    <p>The module imports are the algod.py file from the v2 client folder, in the algosdk library: library/folder/file.py/class</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient</code></pre>\n    \n    <p>The period \" . \" between \"algosdk\" and \"v2client\" indicates where we are going from the algosdk library, which is the v2client folder. From the v2client folder, we then enter the algod python file, and extract the AlgodClient class to use in our code. This is how you import the file, function, or \"class\" (we will go over classes later) that you want to use within your code. If we did not import AlgodClient specifically, we could still access it in our code from the Algod file. We would just need to type out the algod_client variable like so:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client import algod\nalgod_client = algod.AlgodClient(node_token, node_port)</code></pre>\n    \n    <p>We could also stop at v2client, and follow a similar workflow</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk import v2client\nalgod_client = v2client.algod.AlgodClient(node_token, node_port)</code></pre>\n    \n    <p>We can see now why sometimes its more efficient to import a specific file, method, or function instead of the entire library— it is certainly easier to read, and write, and is generally much more concise. For the random module, the library comes with python naturally when installed, so you will notice that with a fresh installation of python, you will not have access to the algosdk library, but you will have access to the random library. To gain access to the algosdk library, you would simply need to install it using the pip installer.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>pip install py-algorand-sdk</code></pre>\n    \n    <p>If you don't have pip, it must be installed manually, which is gone over in the Installation guide on this webpage.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>import random</code></pre>\n    \n    <p>To decide on whether or not you want to import a specific file, function, or method, you would need to use your intuition! For example, I use the general import random at the top of my file, yet I only use randint from that module. So it may be better to use</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from random import randint</code></pre>\n    \n    <p>For the sake of understanding, lets just say perhaps the person writing the code unsure of whether or not the code will need other functions from the random library. Perhaps I plan to also use randrange from the random library with randint, so for now I'll import the entire random library.</p>\n    \n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What is the correct way to import the AlgodClient class from the algosdk library?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) import AlgodClient from algosdk.v2client.algod</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) import algosdk.v2client.algod.AlgodClient</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"correct\">c) from algosdk.v2client.algod import AlgodClient</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) from algosdk.v2client import AlgodClient</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which statement about module imports is true?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"incorrect\">a) Imports can be placed anywhere in the code</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"correct\">b) Imports must appear before usage of anything within them</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) Python reads imports from bottom to top</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) You can only import entire libraries, not specific functions</label><br>\n  \n          <h3>Question 3</h3>\n          <p>How would you import only the randint function from the random module?</p>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"correct\">a) from random import randint</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) import random.randint</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) import randint from random</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) import random</label><br>\n  \n          <h3>Question 4</h3>\n          <p>Which command would you use to install the algosdk library using pip?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"incorrect\">a) pip install algosdk</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"correct\">b) pip install py-algorand-sdk</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) pip install algorand</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) pip install py-algosdk</label><br>\n  \n          \n      </form>\n    \n    ",
    "initialCode": "# Import the entire random module\nimport random\n\n# Generate a random integer between 1 and 10\nrandom_number = random.randint(1, 10)\nprint(f\"Random number (full random import): {random_number}\")\n  "
  },
  {
    "id": 16,
    "language": "Python",
    "title": "Getting Started with Algorand",
    "content": "\n    <p>To set-up your own node, visit this github repository I have created for a previous tutorial series:</p>\n    <p><a href=\"https://github.com/atsoc1993/Algorand_Discord_Bots_Tutorial_Series/tree/main/Episode%201%20-%20Algorand%20Node%2C%20Python%2C%20Visual%20Studio%20Code%2C%20Ubuntu%2C%20and%20Module%20Installations\" target=\"_blank\">GitHub Repository</a></p>\n    <p>Scroll down to the section called \"Algorand Node Installation\"— and make sure to run these commands in an Ubuntu LTS Shell (Download link in bottom resources section)</p>\n    <p>If you chose to run a node, that's wonderful! If not, I will be including sections for those programming without a node.</p>\n    <p>Now that we have access to an Algorand testnet node, as well as a basic understanding of how to work with different kinds of variables, functions and imports. It's time to get started!</p>\n    <p>This will reaffirm your ability to use functions, methods, and imports— as well as key notation: eg; accessing the name of a customer in a variable named my_dictionary</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>my_dictionary = {'customer-name': 'Jerry'}\ncustomer_name = my_dictionary['customer-name']\nprint(customer_name)</code>\n</pre>\n    \n    <p>If you are using your own algorand testnet node on Windows, you will need to access your algod_token and algod_port from your node's data directory:</p>\n    \n    <p><strong>Obtaining your Algorand Node Token and Port</strong></p>\n    <pre class=\"overflow-auto shadow-md\"><code>#Enter the data directory from the root folder\ncd node/data\n\n#Use the following commands to obtain your node token and port\ncat algod.token\n\n#Log the token into the terminal, it should look something like:\nb94c8e5d7a3f1bbd249e83a1cc5b4ae67d8c2a7e9b5f0c6d8e1a7b4f263859cd\ncat algod.net\n\n#Logs the port into the terminal, it should look something like:\n127.0.0.1:8080</code></pre>\n    \n    <p>When programming, you will format this information for variables like so:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>algod_token = 'b94c8e5d7a3f1bbd249e83a1cc5b4ae67d8c2a7e9b5f0c6d8e1a7b4f263859cd'\nalgod_port = 'http://127.0.0.1:8080'</code></pre>\n    \n    <p>If you are not using your own algorand testnet node, you can use these:</p>\n    <p>(Free service does not require token, and the algod_token variable will be an empty string '', whereas the algod_server will be the algonode testnet cloud link)</p>\n    <pre class=\"overflow-auto shadow-md\"><code>algod_token = ''\nalgod_server = 'https://testnet-api.algonode.cloud'</code></pre>\n    \n    <p>Let's started by simply getting the status of the Algorand testnet network!</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nalgod_token = ''  # Leave '' for public nodely service, or enter your node token \nalgod_server = 'https://testnet-api.algonode.cloud' # Use this cloud link, or enter your own host & port\n# Initialize AlgodClient\nalgod_client = AlgodClient(algod_token, algod_server)\nstatus = algod_client.status()\nprint(status)</code></pre>\n    \n    <p>First we import the AlgodClient from algod.py in the v2client folder of the algosdk library.</p>\n    <p>Then, we define our token and server for the node we'll be using.</p>\n    <p>We initialize an AlgodClient instance, which requires a token and server argument, and assign it to our \"algod_client\" variable.</p>\n    <p>We access a function available from the AlgodClient, called status, through our algod_client variable.</p>\n    <p>The result of the status function is assigned to a variable called 'status'.</p>\n    <p>Finally, we print our 'status' variable.</p>\n    <p>Try running the code now!</p>\n    \n    <p>You'll see that you receive a dictionary with several keys and associated values, here is a list of all the keys:</p>\n    <ul class=inText>\n        <li>catchpoint</li>\n        <li>catchpoint-acquired-blocks</li>\n        <li>catchpoint-processed-accounts</li>\n        <li>catchpoint-processed-kvs</li>\n        <li>catchpoint-total-accounts</li>\n        <li>catchpoint-total-blocks</li>\n        <li>catchpoint-total-kvs</li>\n        <li>catchpoint-verified-accounts</li>\n        <li>catchpoint-verified-kvs</li>\n        <li>catchup-time</li>\n        <li>last-catchpoint</li>\n        <li>last-round</li>\n        <li>last-version</li>\n        <li>next-version</li>\n        <li>next-version-round</li>\n        <li>next-version-supported</li>\n        <li>stopped-at-unsupported-round</li>\n        <li>time-since-last-round</li>\n    </ul>\n    \n    <p>The most popular keys are last-round, so you know which block you are on, and perhaps time-since-last-round, if you should need to know that information. Other keys are primarily\n    used by node running services, like upcoming reti-pool incentives, but otherwise are not especially useful for our purposes.</p>\n    \n    <p>Referencing the information from Chapter 4, for dictionaries, try this:\n    <ul class=inText>\n        <li>Create a variable, and name it last_round</li>\n        <li>Assign the value of the key 'last-round' in the status dictionary to this variable you created</li>\n        <li>Print your variable!</li>\n    </ul>\n    </p>\n    \n    \n    <pre class=\"overflow-auto shadow-md\"><code>status = {'catchpoint': '', 'catchpoint-acquired-blocks': 0, 'catchpoint-processed-accounts': 0, 'catchpoint-processed-kvs': 0,\n'catchpoint-total-accounts': 0, 'catchpoint-total-blocks': 0, 'catchpoint-total-kvs': 0, 'catchpoint-verified-accounts': 0, \n'catchpoint-verified-kvs': 0, 'catchup-time': 0, 'last-catchpoint': '', 'last-round': 41422522,\n'last-version': 'https://github.com/algorandfoundation/specs/tree/925a46433742afb0b51bb939354bd907fa88bf95', \n'next-version': 'https://github.com/algorandfoundation/specs/tree/925a46433742afb0b51bb939354bd907fa88bf95',\n'next-version-round': 41422523, 'next-version-supported': True, 'stopped-at-unsupported-round': False, \n'time-since-last-round': 1687057197}</code></pre>\n\n    <p>Enter this code below to get the 'last-round' value printed to the console:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>last_round = status['last-round']\nprint(last_round)</code></pre>\n  \n  \n      <hr><form class=\"quiz-form\">\n     <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What is the correct way to access the value associated with the key 'customer-name' in a dictionary?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) my_dictionary.customer-name</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"correct\">b) my_dictionary['customer-name']</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) my_dictionary('customer-name')</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) my_dictionary[customer-name]</label><br>\n  \n          <h3>Question 2</h3>\n          <p>What is the command to view the Algorand node token in the terminal?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"incorrect\">a) cat algod.net</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"correct\">b) cat algod.token</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) cat node.token</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) cat algod.port</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the value of 'last_round' if the key 'last-round' in the status dictionary is 1000?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>status = {'last-round': 1000}\nlast_round = status['last-round']\nprint(last_round)\n</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) '1000'</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"correct\">b) 1000</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) 999</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) None</label><br>\n  \n          <h3>Question 4</h3>\n          <p>What is the correct way to initialize an AlgodClient instance using a public Algorand testnet node?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"incorrect\">a) algod_client = AlgodClient('', 'http://localhost:4001')</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"correct\">b) algod_client = AlgodClient('', 'https://testnet-api.algonode.cloud')</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) algod_client = AlgodClient('my_token', 'https://mainnet-api.algonode.cloud')</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) algod_client = AlgodClient('my_token', 'http://127.0.0.1:8080')</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "# Using public Algorand testnet with empty token\nfrom algosdk.v2client.algod import AlgodClient\n  \nalgod_token = ''\nalgod_server = 'https://testnet-api.algonode.cloud'\n  \n# Initialize AlgodClient\nalgod_client = AlgodClient(algod_token, algod_server)\n  \n# Fetch and print status from the public testnet\ntry:\n    status = algod_client.status()\n    print(f\"Connected to public Algorand testnet! Last round: {status['last-round']}\")\nexcept Exception as e:\n    print(f\"Failed to connect to public testnet: {e}\")\n  "
  },
  {
    "id": 17,
    "language": "Python",
    "title": "Payment Transactions",
    "content": "\n    <p>In this chapter we are creating and managing Algorand accounts in Python, including generating addresses, converting mnemonics, and executing secure payment transactions.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import PaymentTxn, wait_for_confirmation\nfrom algosdk import account\nfrom algosdk import mnemonic\nfrom algosdk.util import algos_to_microalgos    \n</code></pre>\n    \n    <p><strong>Two Ways to Import an Account</strong></p>\n    \n    <p><strong>Method 1</strong>\n    Create a New Account</p>\n    <pre class=\"overflow-auto shadow-md\"><code>private_key, address = account.generate_account()\nprint(\"Private Key: \", private_key)\nprint(\"Address: \", address)\n#Output\n#Private Key: 6KitD65Q7V6ZDB29EEx1YtoBeqy0PDt+78Ga4DchXItGwneOxj+2nn0hNp/4pW4w9r2cgXI4pVFSrtmZYLflSg== \n#Address: I3BHPDWGH63J47JBG2P7RJLOGD3L3HEBOI4KKUKSV3MZSYFX4VFDIDYSMU</code></pre>\n    \n    <p>If needed to import to a wallet, you can obtain the mnemonic from the private key</p>\n    <pre class=\"overflow-auto shadow-md\"><code>mnemonic_phrase = mnemonic.from_private_key(private_key)\nprint(mnemonic_phrase)\n#Output: brown repeat amazing april survey fish gospel brown bless core deny plate admit burden pistol device shuffle sadness genius answer hurt analyst foot above annual <== Mnemonic\n</code></pre>\n    \n    <p><strong>Method 2</strong> Use mnemonic to obtain/redeem private key</p>\n    <pre class=\"overflow-auto shadow-md\"><code>mnemonic_phrase = 'brown repeat amazing april survey fish gospel brown bless core deny plate admit burden pistol device shuffle sadness genius answer hurt analyst foot above annual'\nprivate_key = mnemonic.to_private_key(mnemonic_phrase)\nprint(private_key)\n#Output: 6KitD65Q7V6ZDB29EEx1YtoBeqy0PDt+78Ga4DchXItGwneOxj+2nn0hNp/4pW4w9r2cgXI4pVFSrtmZYLflSg== <== Private Key</code></pre>\n    \n    <p>When developing in Python, there are two methods to obtain a private key and address to use for signing transactions you create. The private key is in base64 format and required for transaction signing.</p>\n    \n    <p><strong>Method 1: Create a brand new account and obtain the private key and address directly</strong></p>\n    <p>In the algosdk's account module, there is a function called generate_account(), which you can import at the beginning of your code, and is defined here:</p>\n\n    <pre><code>(function) def generate_account() -> tuple[str, Any]</code></pre>\n\n\n    <p>Returns:\n    (str, str): private key, account address</p>\n    \n    <p>This returns the private key and account address as strings. Since this returns a tuple of two items, you would assign two variables to the output of the function, and then subsequently print them.</p>\n    <p>In testnet, you can now fund the account by inputting the address at <a href=\"https://bank.testnet.algorand.network/\" target=\"_blank\">https://bank.testnet.algorand.network/</a>.\n    All accounts require a minimum balance of 0.1 Algo to send transactions, and then 0.001 Algorand per transaction fee.</p>\n    \n    <p>Should you need the mnemonic to import into a wallet application later, you can do so with the from_private_key() function in the mnemonic library as well; input your private key into the function and assign the output variable to something like \"mnemonic_phrase\". Function is defined below:</p>\n    <pre><code>(function) def from_private_key(private_key: Any) -> str\n#Returns the mnemonic for the private key.</code></pre>\n    <p>Args:\n    private_key (str): private key in base64</p>\n    <p>Returns:\n    str: mnemonic</p>\n    \n    <p><strong>Method 2: Convert an Existing Mnemonic to a Private Key</strong></p>\n    <p>Should you already have a mnemonic and require the private key in base64 format, you can create a variable called \"mnemonic_phrase\" and use the result of the to_private_key() function in the mnemonic library, which is defined below:</p>\n    <pre><code>(function) def to_private_key(mnemonic: Any) -> str\n#Returns the private key for the mnemonic.</code></pre>\n    <p>Args:\n    mnemonic (str): mnemonic of the private key</p>\n    <p>Returns:\n    str: private key in base64</p>\n    <p>The mnemonic must be a string, meaning it is enclosed in apostrophes or double quotes ('' or \"\"), and there must be a space between words.</p>\n    \n    <p>Now lets use the account we generated and funded using <a href=\"https://bank.testnet.algorand.network/\" target=\"_blank\">https://bank.testnet.algorand.network/</a>, create our AlgodClient class to initiate a connection to the Algorand blockchain, generate a new account to interact with, and subsequently sign, and send some different kinds of payment transactions.</p>\n    \n    <p>We will be trying a typical payment transaction with a note field, followed by a rekey transaction (rekey to a new account and back to ourselves from the new account), and an account closing transaction. All three are under the scope of a payment transaction.</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import generate_account\nfrom algosdk.util import algos_to_microalgos\nfrom algosdk.transaction import PaymentTxn, wait_for_confirmation\n\nalgod_token = ''\nalgod_server = 'https://testnet-api.algonode.cloud'\nalgod_client = AlgodClient(algod_token, algod_server)\n\naddress = 'I3BHPDWGH63J47JBG2P7RJLOGD3L3HEBOI4KKUKSV3MZSYFX4VFDIDYSMU'\nprivate_key = '6KitD65Q7V6ZDB29EEx1YtoBeqy0PDt+78Ga4DchXItGwneOxj+2nn0hNp/4pW4w9r2cgXI4pVFSrtmZYLflSg=='\n\namount = algos_to_microalgos(1.001)\nparams = algod_client.suggested_params()\n\nnew_account_private_key, new_account_address = generate_account()\n\nbasic_payment_transaction = PaymentTxn(\n    sender = address,\n    receiver = new_account_address,\n    sp = params,\n    amt = amount,\n    note = \"Here's your one Algo!\"\n)\n\nsigned_basic_payment_transaction = basic_payment_transaction.sign(private_key)\ntransaction_id = algod_client.send_transaction(signed_basic_payment_transaction)\nwait_for_confirmation(algod_client, transaction_id)\nprint(transaction_id)</code></pre>\n    \n    <p>Steps:</p>\n    <ol class=inText>\n      <li>Import our necessary modules</li>\n      <li>Define our AlgodClient to initiate a connection to the chain</li>\n      <li>Define our account's address and private key that we will be sending transactions from</li>\n      <li>Define an amount of Algorand to send</li>\n      <li>Obtain the params needed for all transactions</li>\n      <li>Generate a new account for testing, so we have an address to send testnet Algorand to</li>\n      <li>Define our payment transaction and its parameters</li>\n      <li>Sign the transaction with our private key</li>\n      <li>Assign the result of sending our signed transaction with the send_transaction() function from the AlgodClient class</li>\n      <li>Use the wait_for_confirmation() function to ensure the transaction is successful</li>\n      <li>Print the transaction ID for reference on an explorer like <a href=\"https://allo.info/\" target=\"_blank\">allo.info</a>, <a href=\"https://testnet.explorer.perawallet.app/\" target=\"_blank\">Pera Wallet Explorer</a>, <a href=\"https://www.blockpack.app/#/explorer/home\" target=\"_blank\">BlockPack Explorer</a>, or <a href=\"https://app.dappflow.org/explorer/home\" target=\"_blank\">DappFlow Explorer</a>.</li>\n    </ol>\n    \n    <p>We introduce a few new functions here:</p>\n    <ul class=inText>\n      <li>the algos_to_microalgos() function from the algosdk.util module</li>\n      <li>the PaymentTxn class and wait_for_confirmation() function from the algosdk.transaction module</li>\n      <li>The send_transaction() function, which is a method from the AlgodClient class</li>\n    </ul>\n    \n    <p>In the algorand SDK's, when we want to reference an amount of algo, that amount needs to be in a format called \"Microalgo\"; Microalgo is essentially an amount of algo times 1,000,000. Meaning that 1 Algo would be 1,000,000 Microalgo, and the transaction fee of 0.001 Algo is 1,000 Microalgo.</p>\n    \n    <p>Instead of manually calculating the microalgo amount each time, what we can do is use the algos_to_microalgos() function, and pass in the amount of algo as an argument, defined below:</p>\n    <pre><code>(function) def algos_to_microalgos(algos: Any) -> Any\n#Converts algos to microalgos.</code></pre>\n    <p>Args:\n    algos (int or decimal): how many algos</p>\n    <p>Returns:\n    int: how many microalgos</p>\n    \n    <p>The PaymentTransaction class comes with a lot of functionality, aside from simple payment transactions of an amount of Algo to more advanced features, including:</p>\n    <ul class=inText>\n      <li>the ability to rekey your account to another (giving them full access, and losing your access)</li>\n      <li>closing your account (send all of your remaining Algo to them)</li>\n    </ul>\n    \n    <p><strong>PaymentTransaction format:</strong></p>\n    <pre><code>class PaymentTxn (\n    sender: str,\n    sp: SuggestedParams,\n    receiver: Any,\n    amt: Any,\n    close_remainder_to: Any | None = None,\n    note: Any | None = None,\n    lease: Any | None = None,\n    rekey_to: Any | None = None\n)\n#Represents a payment transaction.</code></pre>\n    <p>Args:\n    sender (str): address of the sender\n    sp (SuggestedParams): suggested params from algod\n    receiver (str): address of the receiver\n    amt (int): amount in microAlgos to be sent\n    close_remainder_to (str, optional): if nonempty, account will be closed and remaining algos will be sent to this address\n    note (bytes, optional): arbitrary optional bytes\n    lease (byte[32], optional): specifies a lease, and no other transaction with the same sender and lease can be confirmed in this transaction's valid rounds\n    rekey_to (str, optional): additionally rekey the sender to this address</p>\n    \n    <p>After we define our Payment Transaction class parameters, we can then use the sign() method that is included within it. This sign function accepts our private key, and outputs a signed transaction object, which is needed to input to the send_transaction() function:</p>\n    <pre><code>(method) def sign(private_key: Any) -> SignedTransaction\n#Sign the transaction with a private key.</code></pre>\n    <p>Args:\n    private_key (str): the private key of the signing account</p>\n    <p>Returns:\n    SignedTransaction: signed transaction with the signature</p>\n    \n    <p>The wait_for_confirmation() function requires the AlgodClient class variable we created, as well as the transaction ID to wait for:</p>\n    <pre><code>(function) def wait_for_confirmation (\n    algod_client: AlgodClient,\n    txid: str\n)</code></pre>\n    \n    <p>Lastly, the send_transaction() function, which accepts signed transaction objects:</p>\n    <pre><code>(method) def send_transaction (\n        txn: GenericSignedTransaction\n) -> Outputs transaction ID</code></pre>\n    \n    <p>Below are examples of rekey transactions and close amount to transactions, which are sent in succession (BUT NOT A GROUP TRANSACTION, WHICH WE WILL LEARN ABOUT LATER)</p>\n    \n<pre class=\"overflow-auto shadow-md\"><code># Rekey Transaction\nrekey_to_new_account_payment = PaymentTxn(\n    sender = address,\n    receiver = new_account_address,\n    sp = params,\n    amt = 0,\n    rekey_to = new_account_address,\n    note = \"Take care of my account for me! I'll be back in a week\"\n)\nsigned_rekey_to_new_account_payment = rekey_to_new_account_payment.sign(private_key)\ntransaction_id = algod_client.send_transaction(signed_rekey_to_new_account_payment)\nwait_for_confirmation(algod_client, transaction_id)\nprint(transaction_id)\n# New account rekeys back to the original account, note that the sender is the original account but the new account uses their own private key, not the original accounts private key\nrekey_back_to_old_account_from_new_account = PaymentTxn(\n    sender = address,\n    receiver = address,\n    sp = params,\n    rekey_to = address,\n    amt = 0,\n    note = \"Sorry! I'm too busy trading this week. Maybe ask PorkChop.algo?\"\n)\nsigned_rekey_back_to_old_account_from_new_account = rekey_back_to_old_account_from_new_account.sign(new_account_private_key)\ntransaction_id = algod_client.send_transaction(signed_rekey_back_to_old_account_from_new_account)\nwait_for_confirmation(algod_client, transaction_id)\nprint(transaction_id)\n# Close remainder to transaction\nclose_account_to_new_account = PaymentTxn(\n    sender = address,\n    receiver = new_account_address,\n    sp = params,\n    amt = 0,\n    close_remainder_to = new_account_address,\n    note = 'Take care of my precious Algo!'\n)\nsigned_close_account_to_new_account = close_account_to_new_account.sign(private_key)\ntransaction_id = algod_client.send_transaction(signed_close_account_to_new_account)\nwait_for_confirmation(algod_client, transaction_id)\nprint(transaction_id)</code></pre>\n    \n    <p>Although the Payment Transaction has many possible inputs, the bare minimum is using the sender, sp, receiver, and amt field. Anything else is at your discretion!</p>\n    \n    <p><strong>DISCLAIMER:</strong> that when rekeying and closing out accounts, this process is irreversible! If you don't know the person, or feel unsure about doing so, you should never use these transactions outside of testing purposes without ultimate confidence. No platforms currently utilize rekey transactions for users, but do use them internally when generating smart contracts for contract to contract calls, which will come later in our learning process.</p>\n    \n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n<p>What function is used to create a new Algorand account in the algosdk library?</p>\n<input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n<label for=\"q1a\" class=\"incorrect\">a) algosdk.create_account()</label><br>\n<input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n<label for=\"q1b\" class=\"correct\">b) algosdk.generate_account()</label><br>\n<input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n<label for=\"q1c\" class=\"incorrect\">c) algosdk.new_account()</label><br>\n<input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n<label for=\"q1d\" class=\"incorrect\">d) algosdk.account_create()</label><br>\n\n<h3>Question 2</h3>\n<p>How can you obtain the mnemonic phrase from a private key in the algosdk library?</p>\n<input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n<label for=\"q2a\" class=\"incorrect\">a) algosdk.private_key_to_mnemonic()</label><br>\n<input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n<label for=\"q2b\" class=\"correct\">b) algosdk.secret_key_to_mnemonic()</label><br>\n<input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n<label for=\"q2c\" class=\"incorrect\">c) algosdk.mnemonic_from_private_key()</label><br>\n<input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n<label for=\"q2d\" class=\"incorrect\">d) algosdk.mnemonic_convert()</label><br>\n\n<h3>Question 3</h3>\n<p>What is the correct way to initialize an AlgodClient instance to connect to the Algorand testnet?</p>\n <pre class=\"overflow-auto shadow-md\"><code>algod_token = ''\nalgod_server = 'https://testnet-api.algonode.cloud'\nalgod_client = algod.AlgodClient(algod_token, algod_server)\n</code></pre>\n<input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n<label for=\"q3a\" class=\"correct\">a) algod.AlgodClient()</label><br>\n<input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n<label for=\"q3b\" class=\"incorrect\">b) algod.AlgodNode()</label><br>\n<input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n<label for=\"q3c\" class=\"incorrect\">c) algod.Algodv2()</label><br>\n<input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n<label for=\"q3d\" class=\"incorrect\">d) algod.Client()</label><br>\n\n<h3>Question 4</h3>\n<p>What function is used to convert an amount of Algo to MicroAlgo?</p>\n<input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n<label for=\"q4a\" class=\"incorrect\">a) algosdk.convert_algo_to_micro()</label><br>\n<input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n<label for=\"q4b\" class=\"correct\">b) algosdk.algos_to_microalgos()</label><br>\n<input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n<label for=\"q4c\" class=\"incorrect\">c) algosdk.algo_to_micro()</label><br>\n<input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n<label for=\"q4d\" class=\"incorrect\">d) algosdk.to_microalgos()</label><br>\n\n<h3>Question 5</h3>\n<p>Which function is used to send a signed transaction in the Algorand SDK?</p>\n<input type=\"radio\" id=\"q5a\" name=\"q5\" value=\"a\">\n<label for=\"q5a\" class=\"incorrect\">a) algod_client.send_transaction()</label><br>\n<input type=\"radio\" id=\"q5b\" name=\"q5\" value=\"b\">\n<label for=\"q5b\" class=\"correct\">b) algod_client.send_raw_transaction()</label><br>\n<input type=\"radio\" id=\"q5c\" name=\"q5\" value=\"c\">\n<label for=\"q5c\" class=\"incorrect\">c) algod_client.submit_transaction()</label><br>\n<input type=\"radio\" id=\"q5d\" name=\"q5\" value=\"d\">\n<label for=\"q5d\" class=\"incorrect\">d) algod_client.send_signed_transaction()</label><br>\n\n  \n          \n      </form>\n    \n    ",
    "initialCode": "from algosdk import account, mnemonic\n  \n# Generate a new account\nprivate_key, address = account.generate_account()\n  \n# Display the private key and address\nprint(\"Private Key:\", private_key)\nprint(\"Address:\", address)\n  \n# Generate mnemonic phrase from private key\nmnemonic_phrase = mnemonic.from_private_key(private_key)\nprint(\"Mnemonic Phrase:\", mnemonic_phrase)\n  \n    "
  },
  {
    "id": 20,
    "language": "Python",
    "title": "Installation and Setup",
    "content": "<h2>Getting Started with Discord Bot Development on the Algorand Blockchain</h2>\n    <p>This tutorial will walk you through the installation and setup needed to start building a Discord bot for the Algorand blockchain. The steps outlined below cover essential tools, libraries, and additional resources to ensure a smooth start.</p>\n    \n    <h2>Resources</h2>\n    <ul class=\"inText\">\n      <li>YouTube Tutorial: <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n    <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/z9lZ_ypTZzA \"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div></li>\n      <li>Download Python at <a href=\"https://www.python.org/downloads/\" target=\"_blank\">https://www.python.org/downloads/</a> \n      <ul><li>(Ensure 'Add Python to PATH' is selected during installation)</li></li></ul>\n      <li>Install Visual Studio Code at <a href=\"https://code.visualstudio.com/\" target=\"_blank\">https://code.visualstudio.com/</a></li>\n      <li>Python IntelliSense Extension for VS Code: Install within VS Code for enhanced Python support</li>\n    </ul>\n\n    <h2>Installing Essential Libraries</h2>\n    <p>Install the following libraries in your terminal:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>pip install aiohttp</code>\n<code>pip install algokit</code>\n<code>pip install py-algorand-sdk</code>\n<code>pip install algorand-python</code>\n<code>pip install python-dotenv</code></pre>\n    <p><strong>Note:</strong> If you encounter errors during Algokit installation regarding missing C++ tools, please follow the instructions in the video and install the <a href=\"https://visualstudio.microsoft.com/visual-cpp-build-tools/\" target=\"_blank\">Microsoft Visual C++ Build Tools</a>.</p>\n\n    <h2>Test Contract Example</h2>\n    <p>Create a new Python file called <code>testcontract.py</code> and add the following code to define a simple contract:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract\nfrom algopy.arc4 import abimethod\n\nclass TestContract(ARC4Contract):\n    def __init__(self) -> None:\n        pass\n\n    @abimethod\n    def test(self) -> None:\n        pass</code></pre>\n    <p>Compile the contract with the following terminal command:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>algokit compile py testcontract.py</code></pre>\n    <p>If the approval and clear TEAL files are generated successfully, your setup is complete, and you can proceed with the tutorial series.</p>\n\n    <h2>Running Your Own Node</h2>\n    <p>If you wish to run your own Algorand node rather than using Algonode, refer to the tutorial playlist. Note: Based on community feedback, we've shifted from a Discord bot-focused series to a PUYA-focused series. Only two videos were released for the Discord bot series before this shift. Start with <a href=\"https://www.youtube.com/watch?v=JjmH-KA7UcQ&list=PL5aELASDGbIAw8QqqdGoc9y2zqwsr_J4L&index=1\" target=\"_blank\">the first video in the new series</a>, which includes node installation for Windows.</p>\n    \n    <h2>Visual Studio Code - Code Editing</h2>\n    <p>Download Visual Studio Code to edit your code efficiently, and install the Python IntelliSense extension to help with code completion and suggestions.</p>\n    <p>This tutorial guides you through developing Discord bots for the Algorand blockchain. It’s designed to complement the YouTube tutorial series.</p>\n    <h2>YouTube Tutorial</h2>\n    <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n    <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/JjmH-KA7UcQ\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n\n    \n    <h2>Installing Dependencies</h2>\n    <h3>Using Regular Terminal (not Ubuntu)</h3>\n    <ul class=\"inText\">\n        <li><strong>PIP Installation:</strong></li>\n    </ul>\n    <pre class=\"overflow-auto shadow-md\">\n<code>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</code>\n<code>python get-pip.py</code></pre>\n    <ul class=\"inText\">\n        <li><strong>AIOHTTP (required before installing Discord.py):</strong></li>\n    </ul>\n    <pre class=\"overflow-auto shadow-md\">\n<code>pip install aiohttp>=3.9.0b0</code></pre>\n    <ul class=\"inText\">\n        <li><strong>Discord.py:</strong></li>\n    </ul>\n    <pre class=\"overflow-auto shadow-md\">\n<code>pip install discord.py</code></pre>\n    <ul class=\"inText\">\n        <li><strong>Python AlgoSDK:</strong></li>\n    </ul>\n    <pre class=\"overflow-auto shadow-md\">\n<code>pip3 install py-algorand-sdk</code></pre>\n    \n    <h3>Using Ubuntu Terminal</h3>\n    <h4>Algorand Node Installation</h4>\n    <pre class=\"overflow-auto shadow-md\">\n<code>sudo apt-get update\nsudo apt-get install -y gnupg2 curl software-properties-common\ncurl -o - https://releases.algorand.com/key.pub | sudo tee /etc/apt/trusted.gpg.d/algorand.asc\nsudo add-apt-repository \"deb [arch=amd64] https://releases.algorand.com/deb/ stable main\"\nsudo apt-get update\nsudo apt-get install -y algorand-devtools</code></pre>\n    \n    <h4>Preparing & Running Algorand Node</h4>\n    <pre class=\"overflow-auto shadow-md\"><code>mkdir ~/node \ncd ~/node \ncurl https://raw.githubusercontent.com/algorand/go-algorand/rel/stable/cmd/updater/update.sh -O \nchmod 744 update.sh \n./update.sh -i -c stable -p ~/node -d ~/node/data -n \ngoal node start -d data \ngoal node catchup <a href=\"https://algorand-catchpoints.s3.us-east-2.amazonaws.com/channel/mainnet/latest.catchpoint\" target=\"_blank\">Get Catchpoint from Mainnet</a> -d data</code></pre>\n    \n    <h4>Algorand Node Commands</h4>\n    <ul class=\"inText\">\n        <li><strong>Start Node:</strong> <code>goal node start -d data</code></li>\n        <li><strong>Restart Node:</strong> <code>goal node restart -d data</code></li>\n        <li><strong>Stop Node:</strong> <code>goal node stop -d data</code></li>\n        <li><strong>Catchup Node:</strong> <code>goal node catchup [Catchpoint Link] -d data</code></li>\n    </ul>\n    \n    <h4>Obtain Algorand Node Token & Port</h4>\n    <pre class=\"overflow-auto shadow-md\"><code>cd node/data\ncat algod.token (Displays token)\ncat algod.net</code> (Displays port)</pre>\n    \n    <h4>Basic Terminal Commands</h4>\n    <ul class=\"inText\">\n        <li><strong>Clear Terminal:</strong> <code>clear</code></li>\n        <li><strong>Create Folder:</strong> <code>mkdir FolderName</code></li>\n        <li><strong>List Directories:</strong> <code>ls</code></li>\n        <li><strong>Change Directory:</strong> <code>cd FolderName</code></li>\n        <li><strong>Move Up One Directory:</strong> <code>cd ..</code></li>\n        <li><strong>Delete Directory:</strong> <code>rm -r FolderName</code></li>\n        <li><strong>View File Contents:</strong> <code>cat FileName</code></li>\n    </ul>\n    \n    <h2>Useful Links</h2>\n    <ul class=\"inText\">\n        <li><a href=\"https://www.python.org/downloads/\" target=\"_blank\">Install Python (Select 'Add Python to PATH')</a></li>\n        <li><a href=\"https://code.visualstudio.com/Download\" target=\"_blank\">Install Visual Studio Code</a></li>\n        <li><a href=\"https://www.microsoft.com/store/productId/9MTTCL66CPXJ?ocid=pdpshare\" target=\"_blank\">Microsoft Store Ubuntu LTS</a></li>\n        <li><a href=\"https://developer.algorand.org/docs/run-a-node/setup/install/\" target=\"_blank\">Algorand Node Documentation</a></li>\n        <li><a href=\"https://algorand-catchpoints.s3.us-east-2.amazonaws.com/channel/mainnet/latest.catchpoint\" target=\"_blank\">Algorand Node Mainnet Catchpoint</a></li>\n        <li><a href=\"https://discord.com/developers\" target=\"_blank\">Discord Developer Portal</a></li>\n    </ul>\n    \n    <hr><form class=\"quiz-form\">\n        <h1>Quiz</h1>\n        <h3>Question 1</h3>\n        <p>Which package should be installed before installing discord.py?</p>\n        <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n        <label for=\"q1a\" class=\"incorrect\">a) py-algorand-sdk</label><br>\n        <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n        <label for=\"q1b\" class=\"correct\">b) aiohttp>=3.9.0b0</label><br>\n        <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n        <label for=\"q1c\" class=\"incorrect\">c) Visual Studio Code</label><br>\n        <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n        <label for=\"q1d\" class=\"incorrect\">d) Node</label><br>\n        \n        <h3>Question 2</h3>\n        <p>What command starts the Algorand node?</p>\n        <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n        <label for=\"q2a\" class=\"incorrect\">a) mkdir node</label><br>\n        <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n        <label for=\"q2b\" class=\"correct\">b) goal node start -d data</label><br>\n        <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n        <label for=\"q2c\" class=\"incorrect\">c) chmod 744 update.sh</label><br>\n        <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n        <label for=\"q2d\" class=\"incorrect\">d) apt-get update</label><br>\n    </form>\n    ",
    "initialCode": ""
  },
  {
    "id": 21,
    "language": "Python",
    "title": "Compiling Launching and Interacting with Your First Contract",
    "content": "\n    <p>In this chapter, you'll learn how to compile, launch, and interact with a basic smart contract on the Algorand blockchain. You'll set up essential tools, generate and fund accounts, deploy your contract, and make your first interaction using Python.</p>\n    <h2>YouTube Tutorial</h2>\n<div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n    <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/SJrR47eho7Y\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n    <h2>Compiling</h2>\n    <p>Make sure you have Python installed, and then install <strong>algokit</strong> and <strong>algorand-python</strong> via Python's pip installer:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>pip install algokit\npip install algorand-python</code></pre>\n    \n    <p>Use <code>algokit compile py helloWorldContract.py</code> in the terminal line (assuming your contract is named <code>helloWorldContract.py</code>) to generate your approval and clear TEAL files, as well as the ARC32 JSON for the contract. We will use these to launch and interact with the contract later.</p>\n\n    <h3>helloWorldContract.py</h3>\n    <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, String\nfrom algopy.arc4 import abimethod\n\nclass HelloWorldContract(ARC4Contract):\n    \n    @abimethod\n    def hello(self, name: String) -> String:\n        return \"Hello, \" + name</code></pre>\n\n    <p>Once you have your approval and clear TEAL files, as well as your ARC32 JSON, it's time to launch your contract!</p>\n\n    <h2>Generating and Funding an Account</h2>\n    <p>Generate and fund an account using the code below. Use the testnet dispenser at <a href=\"https://bank.testnet.algorand.network/\">https://bank.testnet.algorand.network/</a>.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(private_key, address)</code></pre>\n\n    <p>Then, place your private key and the public testnet API and URL provided by nodely.io (as indicated in the tutorial) into your <code>.env</code> file.</p>\n\n    <p><strong>Note:</strong> Feel free to reuse this template when launching future contracts, but remember to adjust <code>approval_teal_file_name</code> and <code>clear_teal_file_name</code> variables, as well as the <code>global</code> and <code>local</code> state <code>num_uints</code> and <code>num_bytes</code> values for future contracts.</p>\n<h2>Setting Environment Variables (.env)</h2>\n      <p>Set up environment variables in a <code>.env</code> file. This includes the Algod token and server details, your private key, and the application ID of your contract:</p>\n      <pre class=\"overflow-auto shadow-md\"><code># Algod Token is blank when using Nodely API\nalgod_token=\nalgod_server=https://testnet-api.4160.nodely.dev\n\n# Private key for generated account\nprivate_key=ENTER PRIVATE KEY FOR ACCOUNT HERE\n\n# Application ID from contract generated by LaunchSmartContract.py\napp_id=ENTER GENERATED APP ID HERE</code></pre>\n    <h2>Launching the Contract</h2>\n    <pre class=\"overflow-auto shadow-md\"><code>import os\nfrom algosdk.account import address_from_private_key\nfrom algosdk.v2client.algod import AlgodClient\nfrom base64 import b64decode\nfrom algosdk.transaction import ApplicationCreateTxn, StateSchema, OnComplete, wait_for_confirmation, PaymentTxn\nfrom algosdk.logic import get_application_address\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\nalgod_client = AlgodClient(algod_token, algod_server)\npath = Path(__file__).parent / './HelloWorldContract.arc32.json'\napp_id = int(os.getenv('app_id'))\nmy_signer = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napplication_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=path,\n    app_id=app_id,\n    signer=my_signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\napplication_client.compose_call(atc, call_abi_method='hello', name='AlgoLearn Community')\n\nresult = atc.execute(algod_client, 2)\nprint(result.abi_results[0].tx_id)\nprint(result.abi_results[0].return_value)</code></pre>\n    \n    <p>Once your contract is launched, place your new <code>app_id</code> into your <code>.env</code> file, and try interacting with it using the application client methods above!</p>\n  ",
    "initialCode": ""
  },
  {
    "id": 22,
    "language": "Python",
    "title": "Generating Funding and Interacting with Your First Contract",
    "content": "\n      <h2>Video Walkthrough</h2>\n      <p>Watch the tutorial video to understand the steps in deploying your first Algorand smart contract:</p>\n  <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n    <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/SJrR47eho7Y\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n      <h2>Generating an Account</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n  \n  private_key, address = generate_account()\n  print(private_key, address)</code></pre>\n  \n      <h2>Funding the Account</h2>\n      <p>To fund the account, visit the Algorand testnet dispenser: <a href=\"https://bank.testnet.algorand.network/\">https://bank.testnet.algorand.network/</a></p>\n  \n      <h2>Setting Environment Variables (.env)</h2>\n      <p>Set up environment variables in a <code>.env</code> file. This includes the Algod token and server details, your private key, and the application ID of your contract:</p>\n      <pre class=\"overflow-auto shadow-md\"><code># Algod Token is blank when using Nodely API\nalgod_token=\nalgod_server=https://testnet-api.4160.nodely.dev\n\n# Private key for generated account\nprivate_key=ENTER PRIVATE KEY FOR ACCOUNT HERE\n\n# Application ID from contract generated by LaunchSmartContract.py\napp_id=ENTER GENERATED APP ID HERE</code></pre>\n  \n      <h2>Writing the Hello World Contract</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, String\nfrom algopy.arc4 import abimethod\n\nclass HelloWorldContract(ARC4Contract):\n    \n@abimethod\ndef hello(self, name: String) -> String:\n    return \"Hello, \" + name</code></pre>\n  \n      <h2>Launching the Contract</h2>\n      <p><strong>Note:</strong> Make sure the contract name matches the approval and clear TEAL file names.</p>\n      <p>If your class is defined as:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>class HelloWorldContract(ARC4Contract):</code></pre>\n      <p>Your approval and clear TEAL file names in <code>LaunchSmartContract.py</code> should be:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>approval_teal_file_name = 'HelloWorldContract.approval.teal'\nclear_teal_file_name = 'HelloWorldContract.clear.teal'</code></pre>\n  \n      <pre class=\"overflow-auto shadow-md\"><code>import os\nfrom algosdk.account import address_from_private_key\nfrom algosdk.v2client.algod import AlgodClient\nfrom base64 import b64decode\nfrom algosdk.transaction import ApplicationCreateTxn, StateSchema, OnComplete, wait_for_confirmation, PaymentTxn\nfrom algosdk.logic import get_application_address\nfrom algosdk.util import microalgos_to_algos, algos_to_microalgos\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\nalgod_client = AlgodClient(algod_token, algod_server)\n\napproval_teal_file_name = 'HelloWorldContract.approval.teal'\nclear_teal_file_name = 'HelloWorldContract.clear.teal'\n\nwith open(f'./{approval_teal_file_name}', 'r') as f:\n    approval_teal_source = f.read()\n\nwith open(f'./{clear_teal_file_name}', 'r') as f:\n    clear_teal_source = f.read()\n\napproval_result = algod_client.compile(approval_teal_source)\napproval_program = b64decode(approval_result['result'])\n\nclear_result = algod_client.compile(clear_teal_source)\nclear_program = b64decode(clear_result['result'])\n\nglobal_schema = StateSchema(num_uints=0, num_byte_slices=0)\nlocal_schema = StateSchema(num_uints=0, num_byte_slices=0)\n\nparams = algod_client.suggested_params()\n\ntxn = ApplicationCreateTxn(\n    sender=address,\n    sp=params,\n    on_complete=OnComplete.NoOpOC,\n    approval_program=approval_program,\n    clear_program=clear_program,\n    global_schema=global_schema,\n    local_schema=local_schema,\n)\n\nsigned_txn = txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_txn)\nprint(f'Contract Deployed Tx ID: {tx_id}')\n\nwait_for_confirmation(algod_client, tx_id)\ntx_info = algod_client.pending_transaction_info(tx_id)\n\napp_id = tx_info['application-index']\nprint(f'App ID: {app_id}')\n\napp_address = get_application_address(app_id)\nprint(f'App Address: {app_address}')\n\namount_to_send = algos_to_microalgos(0.1)\n\npayment_txn = PaymentTxn(\n    sender=address,\n    sp=params,\n    receiver=app_address,\n    amt=amount_to_send\n)\n\nsigned_payment_tx = payment_txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_payment_tx)\nprint(f'Application funded with 0.1 Algo for MBR: {tx_id}')</code></pre>\n\n    <h2>Interacting with the Hello World Contract</h2>\n    <pre class=\"overflow-auto shadow-md\"><code>import os\nfrom algosdk.account import address_from_private_key\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.atomic_transaction_composer import AtomicTransactionComposer, AccountTransactionSigner\nfrom algokit_utils import ApplicationClient\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\nalgod_client = AlgodClient(algod_token, algod_server)\npath = Path(__file__).parent / './HelloWorldContract.arc32.json'\napp_id = int(os.getenv('app_id'))\nmy_signer = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napplication_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=path,\n    app_id=app_id,\n    signer=my_signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\napplication_client.compose_call(atc, call_abi_method='hello', name='AlgoLearn Community')\n\nresult = atc.execute(algod_client, 2)\nprint(result.abi_results[0].tx_id)\nprint(result.abi_results[0].return_value)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 23,
    "language": "Python",
    "title": "Creating Launching and Interacting with an Archer Smart Contract",
    "content": "\n      <h2>Video Walkthrough</h2>\n      <p>Watch these videos to understand the process of setting up the Archer smart contract:</p>\n      <p>Part 1:</p>\n      <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n    <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/7MPmd7yZe78\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n      <p>Part 2:</p>\n      <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n  <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/BAINcnpxBrg\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n\n\n      <h2>Generating Accounts</h2>\n      <p>This contract will require two accounts. Use the code below to generate them:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n  \nprivate_key, address = generate_account()\nprint(private_key, address)</code></pre>\n  \n      <h2>Funding the Accounts</h2>\n      <p>To fund the accounts, visit the Algorand testnet dispenser: <a href=\"https://bank.testnet.algorand.network/\">https://bank.testnet.algorand.network/</a></p>\n  \n      <h2>Setting Environment Variables (.env)</h2>\n      <p>Define the following environment variables:</p>\n      <pre class=\"overflow-auto shadow-md\"><code># Private keys for both generated accounts\n  private_key=ENTER FIRST PRIVATE KEY\n  private_key_2=ENTER SECOND PRIVATE KEY\n  \n  # Algod token and server (Nodely API)\nalgod_token=\nalgod_server=https://testnet-api.4160.nodely.dev\n\n# Application ID generated by LaunchSmartContract.py\napp_id=722568747</code></pre>\n\n    <h2>Archer Class Example</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>class Archer:\n    def __init__(self, x):\n        self.arrows = x\n        self.bow_equipped = False\n        \n    def equip_bow(self):\n        assert self.bow_equipped == False\n        self.bow_equipped = True\n        \n    def unequip_bow(self):\n        self.bow_equipped = False\n        \n    def shoot_arrow(self):\n        assert self.bow_equipped == True\n        self.arrows -= 1\n      \n  \n  my_archer = Archer(10)\n  print(my_archer.arrows)\n  print(my_archer.bow_equipped)\n  \n  my_archer.equip_bow()\n  print(my_archer.bow_equipped)\n  \n  my_archer.unequip_bow()\n  print(my_archer.bow_equipped)\n  \n  for i in range(5):\n      my_archer.shoot_arrow()\n      print(my_archer.arrows)</code></pre>\n  \n      <h2>Archer Smart Contract</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, GlobalState, LocalState, UInt64, Txn\nfrom algopy.arc4 import abimethod, String\n\nclass Archer(ARC4Contract):\n    def __init__(self) -> None:\n        self.arrows = LocalState(UInt64)\n        self.bow_equipped = LocalState(bool)\n        self.archersCreated = GlobalState(UInt64(0))\n        \n    @abimethod(allow_actions=['OptIn'])\n    def createArcher(self, x: UInt64) -> tuple[String, String, UInt64, String, UInt64]:\n        self.arrows[Txn.sender] = x\n        self.bow_equipped[Txn.sender] = False\n        self.archersCreated.value += UInt64(1)\n        \n        return String('An Archer was Created!'), String(\"Archer has this many arrows: \"), x, String(\"Contract has created this many archers so far: \"), self.archersCreated.value\n        \n    @abimethod()\n    def EquipBow(self) -> tuple[String, bool]:\n        assert self.bow_equipped[Txn.sender] == False\n        self.bow_equipped[Txn.sender] = True\n        return String('Archer Equipped their Bow: '), self.bow_equipped[Txn.sender]\n        \n    @abimethod()\n    def UnequipBow(self) -> tuple[String, bool]:\n        assert self.bow_equipped[Txn.sender] == True\n        self.bow_equipped[Txn.sender] = False\n        return String('Archer Unequipped their Bow: '), self.bow_equipped[Txn.sender]\n\n    @abimethod()\n    def ShootArrow(self) -> tuple[String, String, UInt64]:\n        assert self.bow_equipped[Txn.sender] == True\n        assert self.arrows[Txn.sender] > UInt64(0)\n        self.arrows[Txn.sender] -= UInt64(1)\n        return String('Archer shot an arrow!'), String('Arrows Remaining: '), self.arrows[Txn.sender]</code></pre>\n  \n      <h2>Launching the Contract</h2>\n      <p><strong>Note:</strong> Ensure the contract name matches the approval and clear TEAL file names.</p>\n      <p>If your class is defined as:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>class Archer(ARC4Contract):</code></pre>\n      <p>Your approval and clear TEAL file names in <code>LaunchSmartContract.py</code> should be:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>approval_teal_file_name = 'Archer.approval.teal'\nclear_teal_file_name = 'Archer.clear.teal'</code></pre>\n  \n      <pre class=\"overflow-auto shadow-md\"><code>import os\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom base64 import b64decode\nfrom algosdk.transaction import StateSchema, ApplicationCreateTxn, OnComplete, wait_for_confirmation\nfrom algosdk import logic\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\nprivate_key = os.getenv('private_key')\n\nalgod_client = AlgodClient(node_token, node_server)\n\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\napproval_teal_file_name = 'Archer.approval.teal'\nclear_teal_file_name= 'Archer.clear.teal'\n\nwith open(f'./{approval_teal_file_name}', 'r') as f:\n    approval_teal_source = f.read()\n\nwith open(f'./{clear_teal_file_name}', 'r') as f:\n    clear_teal_source = f.read()\n\napproval_result = algod_client.compile(approval_teal_source)\napproval_program = b64decode(approval_result['result'])\n\nclear_result = algod_client.compile(clear_teal_source)\nclear_program = b64decode(clear_result['result'])\n\nglobal_schema = StateSchema(num_uints=1, num_byte_slices=0)\nlocal_schema = StateSchema(num_uints=2, num_byte_slices=0)\n\ntx = ApplicationCreateTxn(\n    sender=address,\n    sp=params,\n    on_complete=OnComplete.NoOpOC,\n    approval_program=approval_program,\n    clear_program=clear_program,\n    global_schema=global_schema,\n    local_schema=local_schema\n)\n\nsigned_txn = tx.sign(private_key)\n\ntry:\n    tx_id = algod_client.send_transaction(signed_txn)\nexcept Exception as e:\n    print(\"Failed due to:\", e)\n    \nprint(f'Tx ID: {tx_id}')\nwait_for_confirmation(algod_client, tx_id)\ntx_info = algod_client.pending_transaction_info(tx_id)\napplication_id = tx_info['application-index']\nprint(f'Application ID: {application_id}')\n\napp_address = logic.get_application_address(application_id)\nprint(f'Application Address: {app_address}')</code></pre>\n  \n      <h2>Interacting with the Archer Smart Contract</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algokit_utils import ApplicationClient\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, AtomicTransactionComposer\nfrom algosdk.account import address_from_private_key\nfrom algosdk.transaction import OnComplete\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\n\nprivate_key = os.getenv('private_key_2')\n\nalgod_client = AlgodClient(node_token, node_server)\npath = Path(__file__).parent / './Archer.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\naddress = address_from_private_key(private_key)\nparams = algod_client.suggested_params()\n\napplication_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=path,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\napplication_client.compose_call(atc, call_abi_method='createArcher', transaction_parameters={'on_complete': OnComplete.OptInOC}, x=5)\napplication_client.compose_call(atc, call_abi_method='EquipBow')\napplication_client.compose_call(atc, call_abi_method='UneqipBow')\napplication_client.compose_call(atc, call_abi_method='EquipBow', transaction_parameters={'note': 'Extra Equip Bow Transaction'})\napplication_client.compose_call(atc, call_abi_method='ShootArrow')\n\nresult = atc.execute(algod_client, 2)\ntx_ids = [result.abi_results[i].tx_id for i in range(0, len(result.abi_results))]\nabi_results = [result.abi_results[i].return_value for i in range(0, len(result.abi_results))]\n\nfor i in range(len(result.abi_results)):\n    print(tx_ids[i])\n    print(abi_results[i])\n    print('\\n')</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 24,
    "language": "Python",
    "title": "Simple Staking Smart Contract POC",
    "content": "\n      <h2>Video Walkthrough</h2>\n      <p>Watch the tutorial video for an introduction to this staking smart contract:</p>\n  <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n  <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/dJHugoV36xg\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n\n      <h2>Generating an Account</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n  \nprivate_key, address = generate_account()\nprint(private_key, address)</code></pre>\n  \n      <h2>Funding the Account</h2>\n      <p>To fund the account, visit the Algorand testnet dispenser: <a href=\"https://bank.testnet.algorand.network/\">https://bank.testnet.algorand.network/</a></p>\n  \n      <h2>Algod Node API Information</h2>\n      <p>Use the following Nodely API as your Algod Node API:</p>\n      <p><a href=\"https://testnet-api.4160.nodely.dev\">https://testnet-api.4160.nodely.dev</a></p>\n      <p>Documentation: <a href=\"https://nodely.io/docs/free/start\">https://nodely.io/docs/free/start</a></p>\n  \n      <h2>Staking Contract Code</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, gtxn, Global, BoxRef, Txn, UInt64, itxn\nfrom algopy.arc4 import abimethod\nfrom algopy.arc4 import UInt64 as arc4UInt64\n\nclass StakingContract(ARC4Contract):\n    def __init__(self) -> None:\n        pass\n    \n    @abimethod\n    def stake(self,\n            pay_amount: gtxn.PaymentTransaction,\n            fee_payment: gtxn.PaymentTransaction) -> tuple[UInt64, UInt64]:\n        \n        assert pay_amount.receiver == Global.current_application_address\n        assert fee_payment.amount == 21_700\n        \n        staking_box = BoxRef(key=Txn.sender.bytes)\n        value, exists = staking_box.maybe()\n        \n        if exists:\n            amount_staked = arc4UInt64.from_bytes(value[0:8])\n            initial_stake_time = arc4UInt64.from_bytes(value[8:16])\n            time_difference = Global.latest_timestamp - initial_stake_time.native\n            \n            reward = time_difference * 1000\n            itxn.Payment(receiver=Txn.sender,amount=reward,fee=Global.min_txn_fee).submit()\n            \n            new_total_stake = amount_staked.native + pay_amount.amount\n            staking_box.put(arc4UInt64(new_total_stake).bytes + arc4UInt64(Global.latest_timestamp).bytes)\n        \n        else:        \n            reward = UInt64(0)\n            staking_box.create(size=16)\n            staking_box.put(arc4UInt64(pay_amount.amount).bytes + arc4UInt64(Global.latest_timestamp).bytes)\n        \n        return pay_amount.amount, reward\n    \n    @abimethod\n    def claimRewardAndWithdraw(self) -> UInt64:\n        \n        staking_box = BoxRef(key=Txn.sender.bytes)\n        value, exists = staking_box.maybe()\n        \n        assert exists\n        \n        amount_staked = arc4UInt64.from_bytes(value[0:8])\n        initial_stake_time = arc4UInt64.from_bytes(value[8:16])\n        \n        time_difference = Global.latest_timestamp - initial_stake_time.native\n        reward = time_difference * 1000\n        amount_to_send = reward + amount_staked.native\n        \n        itxn.Payment(receiver=Txn.sender,amount=amount_to_send,fee=Global.min_txn_fee).submit()\n        staking_box.delete()\n        \n        return amount_to_send</code></pre>\n  \n      <h2>Compiling the Contract</h2>\n      <p>Use the following command to compile the contract:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>algokit compile py MyStakingContract.py</code></pre>\n  \n      <h2>Launching the Contract</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.transaction import ApplicationCreateTxn, StateSchema, OnComplete, wait_for_confirmation, PaymentTxn\nfrom algosdk.account import address_from_private_key\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk import logic\nfrom dotenv import load_dotenv\nimport base64\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\nalgod_client = AlgodClient(node_token, node_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\napproval_teal_file_name = 'StakingContract.approval.teal'\nclear_teal_file_name = 'StakingContract.clear.teal'\n\nwith open(f'./{approval_teal_file_name}', 'r') as f:\n    approval_teal_source = f.read()\n\nwith open(f'{clear_teal_file_name}', 'r') as f:\n    clear_teal_source = f.read()\n\napproval_result = algod_client.compile(approval_teal_source)\napproval_program = base64.b64decode(approval_result['result'])\n\nclear_result = algod_client.compile(clear_teal_source)\nclear_program = base64.b64decode(clear_result['result'])\n\nglobal_schema = StateSchema(num_uints=0, num_byte_slices=0)\nlocal_schema = StateSchema(num_uints=0, num_byte_slices=0)\n\ntxn = ApplicationCreateTxn(\n    sender = address,\n    sp = params,\n    on_complete=OnComplete.NoOpOC,\n    approval_program=approval_program,\n    clear_program=clear_program,\n    global_schema=global_schema,\n    local_schema=local_schema,\n)\nsigned_txn = txn.sign(private_key)\n\ntry:\n    txid = algod_client.send_transaction(signed_txn)\nexcept Exception as e:\n    print(e)\n    \nprint(f'Tx ID: {txid}')\nwait_for_confirmation(algod_client, txid)\ntx_info = algod_client.pending_transaction_info(txid)\nprint(f'App ID: {tx_info[\"application-index\"]}')\n\napp_address = logic.get_application_address(tx_info[\"application-index\"])\nprint(f'Application Address: {app_address}')</code></pre>\n\n    <h2>Funding the Contract</h2>\n    <pre class=\"overflow-auto shadow-md\"><code>activate_contract = PaymentTxn (\n    sender = address,\n    sp = params,\n    receiver = app_address,\n    amt = 100_000\n)\n  \nsigned_activation = activate_contract.sign(private_key)\nactivation_tx = algod_client.send_transaction(signed_activation)\nprint(f'MBR For Contract to be Active Account Funded: {activation_tx}')</code></pre>\n  \n      <h2>Box Fees and MBR Calculation</h2>\n      <p>Box Minimum Balance Requirement (MBR) Calculation:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>box_creation_fee = 2500\nbox_byte_fee = 400\n\naddress_bytes = 32\nuint64_2 = 16\n\nbox_mbr = box_creation_fee + ((address_bytes + uint64_2) * 400)\nprint(box_mbr)</code></pre>\n  \n      <p>Read more about MBR for boxes: <a href=\"https://developer.algorand.org/articles/smart-contract-storage-boxes/\">Algorand Box Storage Documentation</a></p>\n  \n      <h2>Staking to the Contract</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, AtomicTransactionComposer, TransactionWithSigner\nfrom algosdk.transaction import PaymentTxn\nfrom algosdk.account import address_from_private_key\nfrom pathlib import Path\nimport os\nfrom algosdk.util import algos_to_microalgos\nfrom algosdk.abi import ABIType\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\npath = Path(__file__).parent / './StakingContract.arc32.json'\napp_id = int(os.getenv('app_id'))\nprivate_key = os.getenv('private_key')\nsigner = AccountTransactionSigner(private_key)\naddress = address_from_private_key(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=path,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\naddress_coder = ABIType.from_string('(address)')\nbox_key = address_coder.encode((address,))\n\nstake_algo_transaction = PaymentTxn(sender=address, sp=params,receiver=app_client.app_address,amt=algos_to_microalgos(0.1))\nstake_with_signer_tx = TransactionWithSigner(stake_algo_transaction, signer)\n\nfee_payment_txn = PaymentTxn(sender=address, sp=params,receiver=app_client.app_address,amt=21700)\nfee_payment_with_signer_tx = TransactionWithSigner(fee_payment_txn, signer)\n\napp_client.compose_call(atc, call_abi_method='stake',pay_amount=stake_with_signer_tx, fee_payment=fee_payment_with_signer_tx, transaction_parameters={'boxes': [[app_id, box_key]]})\n\nresult = atc.execute(algod_client, 2)\nprint(result.tx_ids[0])\nprint(result.abi_results[0].return_value)</code></pre>\n\n    <h2>Claiming Reward and Withdrawing from Contract</h2>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, AtomicTransactionComposer\nfrom algosdk.account import address_from_private_key\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\npath = Path(__file__).parent / './StakingContract.arc32.json'\napp_id = int(os.getenv('app_id'))\nprivate_key = os.getenv('private_key')\nsigner = AccountTransactionSigner(private_key)\naddress = address_from_private_key(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=path,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\naddress_coder = ABIType.from_string('(address)')\nbox_key = address_coder.encode((address,))\n\napp_client.compose_call(atc, call_abi_method='claimRewardAndWithdraw', transaction_parameters={'boxes': [[app_id, box_key]]})\n\nresult = atc.execute(algod_client, 2)\nprint(result.tx_ids[0])\nprint(result.abi_results[0].return_value)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 25,
    "language": "Python",
    "title": "Marketplace Contract Part 1 - Asset for Algo",
    "content": "\n      <h2>Video Walkthrough</h2>\n      <p>Watch the tutorial video for this chapter:</p> \n\n<div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n  <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/cNv3Nxx7mIA\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n\n      \n      <h3>Step 1: Generate Two Accounts</h3>\n      <ul class=\"inText\">\n        <li>One for Lister, one for Buyer</li>\n      </ul>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(private_key, address)\n</code></pre>\n      \n      <h3>Step 2: Load each Account with Funds</h3>\n      <p>Use the following link to load funds into each account:</p>\n      <a href=\"https://bank.testnet.algorand.network/\" target=\"_blank\">https://bank.testnet.algorand.network/</a>\n      \n      <h3>Step 3: Create .env</h3>\n      <pre class=\"overflow-auto shadow-md\"><code>algod_token = \nalgod_server = https://testnet-api.4160.nodely.dev\nprivate_key = lqPuVOtF4p6QpsaL7iTA6mbHoy7a5+nuAPjzw7HvckiXQWUlnZQVYSCZSvUK8w+MGjh09sNsx7WybOeb0MLD/Q==\nbuyer_private_key = jHx+aE6G/5RKAMJK7J7R+j3SyjKhzLsrbYIrzmmhWphJsT7CpTxqdhsjWQx4wDpx2I5B+1FiBSp16O5fXd/Sqg==\nasset_1 = 724395141\nasset_2 = 724449087\napp_id = 724455779\n</code></pre>\n      \n      <h3>Step 4: Compile Asset for Algo Listing Contract</h3>\n      <p>Create and compile the asset listing contract:</p>\n       <pre class=\"overflow-auto shadow-md\"><code>counter = 1</code></pre>\n      <p>Use the following implementation to compile your contract:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, String, gtxn, Asset, Txn, GlobalState, itxn, Global, BoxRef, UInt64, TransactionType\nfrom algopy import ARC4Contract, String, gtxn, Asset, Txn, GlobalState, itxn, Global, BoxRef, UInt64, TransactionType\nfrom algopy.arc4 import abimethod, Address, Struct, Bool\nfrom algopy.arc4 import UInt64 as arc4UInt64\n\nclass listingName(Struct):\n    lister: Address\n    counter: arc4UInt64    \n    \nclass listingValue(Struct):\n    asset_listed: arc4UInt64\n    algo_requested: arc4UInt64    \n    \nclass listings(ARC4Contract):\n    def __init__(self) -> None:\n        self.listingCounter = GlobalState(arc4UInt64(0))    \n    \n    @abimethod\n    def triggerOptIn(\n        self,\n        asset_to_opt_into: Asset,\n        fee_payment: gtxn.PaymentTransaction\n    ) -> tuple[String, UInt64]:\n\n        assert fee_payment.amount >= 101_000\n        assert fee_payment.receiver == Global.current_application_address\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_to_opt_into,\n            asset_receiver=Global.current_application_address,\n            fee=Global.min_txn_fee\n        ).submit()    \n    \n        return String(\"Successfully opted in to asset: \"), asset_to_opt_into.id    \n    \n    @abimethod\n    def postListingRequest(\n        self,\n        asset_to_list: gtxn.AssetTransferTransaction,\n        algo_amount_requested: arc4UInt64,\n        box_fee_mbr_payment: gtxn.PaymentTransaction,\n    ) -> tuple[String, UInt64, String, arc4UInt64]:\n        \n        assert box_fee_mbr_payment.amount == 24_900\n        assert asset_to_list.asset_receiver == Global.current_application_address\n        assert asset_to_list.asset_amount == 1\n        \n        self.listingCounter.value = arc4UInt64(self.listingCounter.value.native + 1)\n        \n        listing_box_name_info = listingName(Address(Txn.sender), self.listingCounter.value)\n        \n        listing_box = BoxRef(key=listing_box_name_info.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert not exists\n        \n        listing_box.create(size=16)\n        \n        listing_box_value_info = listingValue(arc4UInt64(asset_to_list.xfer_asset.id), algo_amount_requested)\n        \n        listing_box.put(listing_box_value_info.bytes)\n        \n        return String(\"User Listed Asset Successfully: \"), asset_to_list.xfer_asset.id, String(\"User is requesting x amount of Algo: \"), algo_amount_requested    \n    \n    @abimethod\n    def fulfillListingRequest(\n        self,\n        asset_listed: Asset,\n        listing_name: listingName,\n        payment: gtxn.PaymentTransaction,\n        transfer_fees: gtxn.PaymentTransaction\n    ) -> tuple[String, UInt64, String, UInt64]:\n        \n        assert transfer_fees.amount == 2000\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        \n        assert exists\n        \n        listing_value = listingValue.from_bytes(value)\n        \n        assert listing_value.asset_listed == asset_listed.id\n        assert listing_value.algo_requested == payment.amount\n        \n        itxn.Payment(\n            receiver=listing_name.lister.native,\n            amount=payment.amount,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_listed,\n            asset_receiver=Txn.sender,\n            asset_amount=1,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()\n        \n        return String(\"Listing Fulfilled for Asset: \"), asset_listed.id, String(\"Lister received x amount of Algo: \"), payment.amount       \n        \n    @abimethod\n    def cancelListingRequest(\n        self,\n        listing_asset: Asset,\n        listing_name: listingName,\n        transfer_fee: gtxn.PaymentTransaction\n    ) -> String:\n        \n        assert transfer_fee.amount == 1000\n        assert listing_name.lister.native == Txn.sender\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        \n        assert exists\n        \n        listing_value = listingValue.from_bytes(value)\n        \n        assert listing_value.asset_listed == listing_asset.id\n        \n        itxn.AssetTransfer(\n            xfer_asset=listing_asset.id,\n            asset_amount=1,\n            asset_receiver=Txn.sender,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()\n        \n        return String(\"Listing Request Cancelled\")</code></pre>\n\n      <p>Ensure you have the necessary imports and class definitions for your contract.</p>\n      \n      <h3>Step 5: Create Two Arbitrary Assets for Experimenting</h3>\n      <p>Follow the steps to create and configure two assets for testing purposes.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import AssetConfigTxn, wait_for_confirmation\nfrom algosdk.account import address_from_private_key\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\nasset_creation_txn = AssetConfigTxn(\n    sender=address,\n    sp=params,\n    total=100,\n    default_frozen=False,\n    asset_name='Test Asset Two',\n    unit_name='TA2',\n    manager=address,\n    reserve=address,\n    strict_empty_address_check=False,\n)\n\nsigned_tx = asset_creation_txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_tx)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\n\nasset_id = algod_client.pending_transaction_info(tx_id)['asset-index']\nasset_info = algod_client.asset_info(asset_id)\nprint(asset_info)</code></pre>\n      \n      <h3>Step 6: Store Generated Asset IDs in .env</h3><pre><code>asset_1 = 123456\nasset_2 = 654321</code></pre>\n      \n      <h3>Step 7: Experiment with Opting the Contract into an Asset</h3>\n      <p>If you're creating multiple listings, you need to opt the contract into each asset the first time.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(atc, call_abi_method='triggerOptIn', asset_to_opt_into=asset_1, fee_payment=wrapped_payment)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 8: Make an Asset for Algo Listing Box</h3>\n      <p>Create an asset listing box to manage your asset listings.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom pathlib import Path\nfrom algosdk.util import algos_to_microalgos\nfrom algosdk.abi import ABIType\nfrom base64 import b64decode\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(\n    atc, \n    call_abi_method='triggerOptIn', \n    asset_to_opt_into=asset_1, \n    fee_payment=wrapped_payment)\n\n\nasset_to_list_transaction = AssetTransferTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1, index=asset_1)\nwrapped_asset_list_transaction = TransactionWithSigner(asset_to_list_transaction, signer)\n\nbox_fee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=24_900)\nwrapped_box_fee_payment = TransactionWithSigner(box_fee_payment_tx, signer)\n\ncurrent_global_listing_counter = algod_client.application_info(app_id)['params']['global-state'][0]['value']['bytes']\nuint64_coder = ABIType.from_string('(uint64)')\nb64_decoded_global_listing_counter = b64decode(current_global_listing_counter)\nencoded_global_listing_counter = uint64_coder.decode(b64_decoded_global_listing_counter)[0]\n\nlisting_box_counter = encoded_global_listing_counter + 1\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nusers_listing_box_name = listing_box_coder.encode((address, listing_box_counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='postListingRequest', \n    asset_to_list=wrapped_asset_list_transaction, \n    algo_amount_requested=algos_to_microalgos(1), \n    box_fee_mbr_payment=wrapped_box_fee_payment,\n    transaction_parameters={'boxes': [[app_id, users_listing_box_name]]}\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)\n</code></pre>\n      \n      <h3>Step 9: Check Respective Listing Information</h3>\n      <p>Retrieve and verify the listing information from the contract.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>import os\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.abi import ABIType\nfrom base64 import b64decode\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\napp_id = int(os.getenv('app_id'))\n\nboxes = algod_client.application_boxes(app_id)['boxes']\n\nfor box in boxes:\n    box_name_b64encoded = box['name']\n    print(b64decode(box_name_b64encoded))\n    box_value = b64decode(algod_client.application_box_by_name(app_id, b64decode(box_name_b64encoded))['value'])\n    print(box_value)\n\n    #Asset for Algo: '(uint64,uint64)'\n    #Asset for Asset: '(uint64,uint64,bool)'\n    #Asset for Asset Quantity: '(uint64,uint64,uint64,bool)\n    #Asset Quantity for Asset Quantity: '(uint64,uint64,uint64,uint64,bool)'\n    #Universal Listing: '(uint64,uint64,uint64,uint64,bool)'\n    listing_box_value_coder = ABIType.from_string('(uint64,uint64)')\n    print(listing_box_value_coder.decode(box_value))\n</code></pre>\n      \n      <h3>Step 10: Purchase the Asset with Your Buyer Private Key</h3>\n      <p>Execute the purchase of the asset using the buyer's private key.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nasset_opt_in_transaction = AssetTransferTxn(sender=address, sp=params, receiver=address, amt=0, index=asset_1)\nwrapped_opt_in_transaction = TransactionWithSigner(asset_opt_in_transaction, signer)\natc.add_transaction(wrapped_opt_in_transaction)\n\nasset_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1_000_000)\nwrapped_asset_payment = TransactionWithSigner(asset_payment_tx, signer)\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=2000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='fulfillListingRequest', \n    asset_listed=asset_1, \n    listing_name=(lister_address,counter), \n    payment=wrapped_asset_payment, \n    transfer_fees=wrapped_fee_payment, \n    transaction_parameters={'boxes': [[app_id, box_name]], 'accounts':[lister_address]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 26,
    "language": "Python",
    "title": "Marketplace Contract Part 2 - Asset for Asset",
    "content": "\n      <h2>Video Walkthrough</h2>\n      <p>Watch the tutorial video for this chapter:</p> \n      \n\n<div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n  <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/46i8OvPWPUc\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n\n      \n      <h3>Step 1: Generate Two Accounts</h3>\n      <ul class=\"inText\">\n        <li>One for Lister, one for Buyer</li>\n      </ul>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(private_key, address)\n</code></pre>\n      \n      <h3>Step 2: Load each Account with Funds</h3>\n      <p>Use the following link to load funds into each account:</p>\n      <a href=\"https://bank.testnet.algorand.network/\" target=\"_blank\">https://bank.testnet.algorand.network/</a>\n      \n      <h3>Step 3: Create .env</h3>\n      <pre class=\"overflow-auto shadow-md\"><code>algod_token = \nalgod_server = https://testnet-api.4160.nodely.dev\nprivate_key = lqPuVOtF4p6QpsaL7iTA6mbHoy7a5+nuAPjzw7HvckiXQWUlnZQVYSCZSvUK8w+MGjh09sNsx7WybOeb0MLD/Q==\nbuyer_private_key = jHx+aE6G/5RKAMJK7J7R+j3SyjKhzLsrbYIrzmmhWphJsT7CpTxqdhsjWQx4wDpx2I5B+1FiBSp16O5fXd/Sqg==\nasset_1 = 724395141\nasset_2 = 724449087\napp_id = 724455779\n</code></pre>\n      \n      <h3>Step 4: Compile Asset for Asset Listing Contract</h3>\n      <p>Create and compile the asset listing contract:</p>\n       <pre class=\"overflow-auto shadow-md\"><code>counter = 1</code></pre>\n      <p>Use the following implementation to compile your contract:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, String, gtxn, Asset, Txn, GlobalState, itxn, Global, BoxRef, UInt64, TransactionType\nfrom algopy.arc4 import abimethod, Address, Struct, Bool\nfrom algopy.arc4 import UInt64 as arc4UInt64\n\nclass listingName(Struct):\n    lister: Address\n    counter: arc4UInt64\n    \nclass tradeListingValue(Struct):\n    asset_listed: arc4UInt64\n    asset_requested: arc4UInt64\n    fulfilled: Bool\n\nclass listings(ARC4Contract):\n    def __init__(self) -> None:\n        self.listingCounter = GlobalState(arc4UInt64(0))\n        \n    @abimethod\n    def triggerOptIn(\n        self,\n        asset_to_opt_into: Asset,\n        fee_payment: gtxn.PaymentTransaction\n    ) -> tuple[String, UInt64]:\n\n        assert fee_payment.amount >= 101_000\n        assert fee_payment.receiver == Global.current_application_address\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_to_opt_into,\n            asset_receiver=Global.current_application_address,\n            fee=Global.min_txn_fee\n        ).submit()    \n    \n        return String(\"Successfully opted in to asset: \"), asset_to_opt_into.id\n        \n    @abimethod\n    def postTradeRequest(\n        self,\n        asset_to_list: gtxn.AssetTransferTransaction,\n        asset_request: Asset,\n        box_fee_mbr_payment: gtxn.PaymentTransaction\n    ) -> String:\n        \n        assert box_fee_mbr_payment.amount == 25_300\n        assert asset_to_list.asset_receiver == Global.current_application_address\n        assert asset_to_list.asset_amount == 1\n        \n        self.listingCounter.value = arc4UInt64(self.listingCounter.value.native + 1)\n        \n        listing_box_name_info = listingName(Address(Txn.sender), self.listingCounter.value)\n        \n        listing_box = BoxRef(key=listing_box_name_info.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert not exists\n        \n        listing_box.create(size=17)\n        \n        listing_box_value_info = tradeListingValue(arc4UInt64(asset_to_list.xfer_asset.id), arc4UInt64(asset_request.id), Bool(False))    \n        \n        listing_box.put(listing_box_value_info.bytes)\n        \n        return String(\"Trade Request Posted\")\n        \n    @abimethod\n    def fulfillTradeRequest(\n        self,\n        asset_trade_fulfillment: gtxn.AssetTransferTransaction,\n        asset_transfer_fee: gtxn.PaymentTransaction,\n        asset_listed: Asset,\n        listing_name: listingName,\n        \n    ) -> String:\n        \n        assert asset_transfer_fee.amount == 1000\n        assert asset_trade_fulfillment.asset_amount == 1\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert exists\n        \n        listing_value = tradeListingValue.from_bytes(value)\n        \n        assert listing_value.asset_listed == asset_listed.id\n        assert listing_value.asset_requested == asset_trade_fulfillment.xfer_asset.id\n                \n        itxn.AssetTransfer(\n            xfer_asset=asset_listed,\n            asset_receiver=Txn.sender,\n            asset_amount=1,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_value.fulfilled = Bool(True)\n        listing_box.put(listing_value.bytes)\n                \n        return String(\"Trade Request Fulfilled!\")        \n             \n    @abimethod\n    def claimFulfilledTradeRequest(\n        self,\n        asset_transfer_fee: gtxn.PaymentTransaction,\n        asset_requested: Asset,\n        listing_name: listingName,\n    ) -> String:\n                \n        assert listing_name.lister == Address(Txn.sender)\n        assert asset_transfer_fee.amount == 1000\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert exists\n        \n        listing_value = tradeListingValue.from_bytes(value)\n        \n        assert asset_requested.id == listing_value.asset_requested\n        assert listing_value.fulfilled == Bool(True)\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_requested.id,\n            asset_receiver=Txn.sender,\n            asset_amount=1,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()\n        \n        return String(\"Trade Request Completed!\")\n        \n    @abimethod\n    def cancelTradeRequest(\n        self,\n        listed_asset: Asset,\n        listing_name: listingName,\n        transfer_fee: gtxn.PaymentTransaction\n    ) -> String:\n        \n        assert transfer_fee.amount == 1000\n        assert listing_name.lister == Address(Txn.sender)\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        \n        assert exists\n        \n        listing_value = tradeListingValue.from_bytes(value)\n        \n        assert listing_value.asset_listed == listed_asset.id\n        \n        itxn.AssetTransfer(\n            xfer_asset=listed_asset.id,\n            asset_amount=1,\n            asset_receiver=Txn.sender,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()    \n        \n        return String(\"Trade Request Cancelled!\")</code></pre>\n\n      <p>Ensure you have the necessary imports and class definitions for your contract.</p>\n      \n      <h3>Step 5: Create Two Arbitrary Assets for Experimenting</h3>\n      <p>Follow the steps to create and configure two assets for testing purposes.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import AssetConfigTxn, wait_for_confirmation\nfrom algosdk.account import address_from_private_key\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\nasset_creation_txn = AssetConfigTxn(\n    sender=address,\n    sp=params,\n    total=100,\n    default_frozen=False,\n    asset_name='Test Asset Two',\n    unit_name='TA2',\n    manager=address,\n    reserve=address,\n    strict_empty_address_check=False,\n)\n\nsigned_tx = asset_creation_txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_tx)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\n\nasset_id = algod_client.pending_transaction_info(tx_id)['asset-index']\nasset_info = algod_client.asset_info(asset_id)\nprint(asset_info)</code></pre>\n      \n      <h3>Step 6: Store Generated Asset IDs in .env</h3><pre><code>asset_1 = 123456\nasset_2 = 654321</code></pre>\n      \n      <h3>Step 7: Experiment with Opting the Contract into an Asset</h3>\n      <p>If you're creating multiple listings, you need to opt the contract into each asset the first time.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(atc, call_abi_method='triggerOptIn', asset_to_opt_into=asset_1, fee_payment=wrapped_payment)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 8: Make an Asset for Algo Listing Box</h3>\n      <p>Create an asset listing box to manage your asset listings.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nimport os\nfrom base64 import b64decode\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(\n    atc, \n    call_abi_method='triggerOptIn', \n    asset_to_opt_into=asset_1, \n    fee_payment=wrapped_payment)\n\nasset_to_list_transaction = AssetTransferTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1, index=asset_1)\nwrapped_asset_list_transaction = TransactionWithSigner(asset_to_list_transaction, signer)\n\nbox_fee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=25_300)\nwrapped_box_fee_payment = TransactionWithSigner(box_fee_payment_tx, signer)\n\ncurrent_global_listing_counter = algod_client.application_info(app_id)['params']['global-state'][0]['value']['bytes']\nuint64_coder = ABIType.from_string('(uint64)')\nb64_decoded_global_listing_counter = b64decode(current_global_listing_counter)\nencoded_global_listing_counter = uint64_coder.decode(b64_decoded_global_listing_counter)[0]\n\nlisting_box_counter = encoded_global_listing_counter + 1\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nusers_listing_box_name = listing_box_coder.encode((address, listing_box_counter))\n\nasset_2 = int(os.getenv('asset_2'))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='postTradeRequest', \n    asset_to_list=wrapped_asset_list_transaction, \n    asset_request=asset_2, \n    box_fee_mbr_payment=wrapped_box_fee_payment,\n    transaction_parameters={'boxes': [[app_id, users_listing_box_name]]}\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 9: Check Respective Listing Information</h3>\n      <p>Retrieve and verify the listing information from the contract.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>import os\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.abi import ABIType\nfrom base64 import b64decode\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\napp_id = int(os.getenv('app_id'))\n\nboxes = algod_client.application_boxes(app_id)['boxes']\n\nfor box in boxes:\n    box_name_b64encoded = box['name']\n    print(b64decode(box_name_b64encoded))\n    box_value = b64decode(algod_client.application_box_by_name(app_id, b64decode(box_name_b64encoded))['value'])\n    print(box_value)\n\n    #Asset for Algo: '(uint64,uint64)'\n    #Asset for Asset: '(uint64,uint64,bool)'\n    #Asset for Asset Quantity: '(uint64,uint64,uint64,bool)\n    #Asset Quantity for Asset Quantity: '(uint64,uint64,uint64,uint64,bool)'\n    #Universal Listing: '(uint64,uint64,uint64,uint64,bool)'\n    listing_box_value_coder = ABIType.from_string('(uint64,uint64)')\n    print(listing_box_value_coder.decode(box_value))\n</code></pre>\n      \n      <h3>Step 10: Purchase the Asset with Your Buyer Private Key</h3>\n      <p>Execute the purchase of the asset using the buyer's private key.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\nasset_2 = int(os.getenv('asset_2'))\n\n'''\nUser should Optin to the asset if they are not prepared to receive it\n'''\n#asset_opt_in_transaction = AssetTransferTxn(sender=address, sp=params, receiver=address, amt=0, index=asset_1)\n#wrapped_opt_in_transaction = TransactionWithSigner(asset_opt_in_transaction, signer)\n#atc.add_transaction(wrapped_opt_in_transaction)\n\noptin_fee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_optin_payment = TransactionWithSigner(optin_fee_payment_tx, signer)\n\napp_client.compose_call(\n    atc, \n    call_abi_method='triggerOptIn', \n    asset_to_opt_into=asset_2, \n    fee_payment=wrapped_optin_payment)\n\nasset_payment_tx = AssetTransferTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1, index=asset_2)\nwrapped_asset_payment = TransactionWithSigner(asset_payment_tx, signer)\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='fulfillTradeRequest', \n    asset_trade_fulfillment=wrapped_asset_payment,\n    asset_transfer_fee=wrapped_fee_payment,\n    asset_listed=asset_1, \n    listing_name=(lister_address,counter), \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n\n      <h3>Step 11: Complete Listing Request and Redeem Buyers Asset</h3>\n<pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\nasset_2 = int(os.getenv('asset_2'))\n\nasset_opt_in_transaction = AssetTransferTxn(sender=address, sp=params, receiver=address, amt=0, index=asset_2)\nwrapped_opt_in_transaction = TransactionWithSigner(asset_opt_in_transaction, signer)\natc.add_transaction(wrapped_opt_in_transaction)\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='claimFulfilledTradeRequest', \n    asset_transfer_fee=wrapped_fee_payment,\n    asset_requested=asset_2,\n    listing_name=(lister_address,counter), \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n\n      \n      <h3>Step 12: Experiment with Cancelling a Listing Request</h3>\n      <p>If you fulfilled the previous request already, you will need to generate a new listing again with Step 8, and increment the \"counter\" variable from 1 to 2. For example:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>counter = 2</code></pre>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\n\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='cancelTradeRequest', \n    listed_asset=asset_1, \n    listing_name=(lister_address,counter), \n    transfer_fee=wrapped_fee_payment, \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 27,
    "language": "Python",
    "title": "Marketplace Contract Part 3 - Asset for Asset Quantity",
    "content": "\n      <h2>Video Walkthrough</h2>\n      <p>Watch the tutorial video for this chapter:</p> \n      \n\n<div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n  <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/uKqqhaYpxHU\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n\n      \n      <h3>Step 1: Generate Two Accounts</h3>\n      <ul class=\"inText\">\n        <li>One for Lister, one for Buyer</li>\n      </ul>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(private_key, address)\n</code></pre>\n      \n      <h3>Step 2: Load each Account with Funds</h3>\n      <p>Use the following link to load funds into each account:</p>\n      <a href=\"https://bank.testnet.algorand.network/\" target=\"_blank\">https://bank.testnet.algorand.network/</a>\n      \n      <h3>Step 3: Create .env</h3>\n      <pre class=\"overflow-auto shadow-md\"><code>algod_token = \nalgod_server = https://testnet-api.4160.nodely.dev\nprivate_key = lqPuVOtF4p6QpsaL7iTA6mbHoy7a5+nuAPjzw7HvckiXQWUlnZQVYSCZSvUK8w+MGjh09sNsx7WybOeb0MLD/Q==\nbuyer_private_key = jHx+aE6G/5RKAMJK7J7R+j3SyjKhzLsrbYIrzmmhWphJsT7CpTxqdhsjWQx4wDpx2I5B+1FiBSp16O5fXd/Sqg==\nasset_1 = 724395141\nasset_2 = 724449087\napp_id = 724455779\n</code></pre>\n      \n      <h3>Step 4: Compile Asset for Asset Quantity Listing Contract</h3>\n      <p>Create and compile the asset listing contract:</p>\n       <pre class=\"overflow-auto shadow-md\"><code>counter = 1</code></pre>\n      <p>Use the following implementation to compile your contract:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, String, gtxn, Asset, Txn, GlobalState, itxn, Global, BoxRef, UInt64, TransactionType\nfrom algopy.arc4 import abimethod, Address, Struct, Bool\nfrom algopy.arc4 import UInt64 as arc4UInt64\n\nclass listingName(Struct):\n    lister: Address\n    counter: arc4UInt64\n        \nclass tradeListingValueWithAssetQuantity(Struct):\n    asset_listed: arc4UInt64\n    asset_requested: arc4UInt64\n    asset_amount_requested: arc4UInt64\n    fulfilled: Bool\n        \nclass listings(ARC4Contract):\n    def __init__(self) -> None:\n        self.listingCounter = GlobalState(arc4UInt64(0))\n        \n    @abimethod\n    def triggerOptIn(\n        self,\n        asset_to_opt_into: Asset,\n        fee_payment: gtxn.PaymentTransaction\n    ) -> tuple[String, UInt64]:\n\n        assert fee_payment.amount >= 101_000\n        assert fee_payment.receiver == Global.current_application_address\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_to_opt_into,\n            asset_receiver=Global.current_application_address,\n            fee=Global.min_txn_fee\n        ).submit()    \n    \n        return String(\"Successfully opted in to asset: \"), asset_to_opt_into.id    \n        \n    @abimethod\n    def postTradeRequestWithQuantity(\n        self,\n        asset_to_list: gtxn.AssetTransferTransaction,\n        asset_request: Asset,\n        asset_request_quantity: arc4UInt64,\n        box_fee_mbr_payment: gtxn.PaymentTransaction\n    ) -> String:\n\n        assert box_fee_mbr_payment.amount == 28_500\n        assert asset_to_list.asset_receiver == Global.current_application_address\n        assert asset_to_list.asset_amount == 1\n        \n        self.listingCounter.value = arc4UInt64(self.listingCounter.value.native + 1)\n        \n        listing_box_name_info = listingName(Address(Txn.sender), self.listingCounter.value)\n        \n        listing_box = BoxRef(key=listing_box_name_info.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert not exists\n        \n        listing_box.create(size=25)\n        \n        listing_box_value_info = tradeListingValueWithAssetQuantity(arc4UInt64(asset_to_list.xfer_asset.id), arc4UInt64(asset_request.id), arc4UInt64(asset_request_quantity.native), Bool(False))    \n        \n        listing_box.put(listing_box_value_info.bytes)\n        \n        return String(\"Trade Request Posted\")\n        \n    @abimethod\n    def fulfillTradeRequestWithQuantity(\n        self,\n        asset_trade_fulfillment: gtxn.AssetTransferTransaction,\n        asset_transfer_fee: gtxn.PaymentTransaction,\n        asset_listed: Asset,\n        listing_name: listingName,\n        \n    ) -> String:\n        \n        assert asset_transfer_fee.amount == 1000\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert exists\n        \n        listing_value = tradeListingValueWithAssetQuantity.from_bytes(value)\n        \n        assert listing_value.asset_listed == asset_listed.id\n        assert listing_value.asset_requested == asset_trade_fulfillment.xfer_asset.id\n        assert asset_trade_fulfillment.asset_amount == listing_value.asset_amount_requested\n                \n        itxn.AssetTransfer(\n            xfer_asset=asset_listed,\n            asset_receiver=Txn.sender,\n            asset_amount=1,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_value.fulfilled = Bool(True)\n        listing_box.put(listing_value.bytes)\n        \n        return String(\"Trade Request Fulfilled!\")        \n                \n    @abimethod\n    def claimFulfilledTradeRequestWithQuantity(\n        self,\n        asset_transfer_fee: gtxn.PaymentTransaction,\n        asset_requested: Asset,\n        listing_name: listingName,\n    ) -> String:\n                \n        assert listing_name.lister == Address(Txn.sender)\n        assert asset_transfer_fee.amount == 1000\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert exists\n        \n        listing_value = tradeListingValueWithAssetQuantity.from_bytes(value)\n        \n        assert asset_requested.id == listing_value.asset_requested\n        assert listing_value.fulfilled == Bool(True)\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_requested.id,\n            asset_receiver=Txn.sender,\n            asset_amount=listing_value.asset_amount_requested.native,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()\n        \n        return String(\"Trade Request Completed!\")\n        \n    @abimethod\n    def cancelTradeRequestWithQuantity(\n        self,\n        listed_asset: Asset,\n        listing_name: listingName,\n        transfer_fee: gtxn.PaymentTransaction\n    ) -> String:\n        \n        assert transfer_fee.amount == 1000\n        assert listing_name.lister == Address(Txn.sender)\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        alue, exists = listing_box.maybe()\n        \n        assert exists\n        \n        listing_value = tradeListingValueWithAssetQuantity.from_bytes(value)\n        \n        assert listing_value.asset_listed == listed_asset.id\n        \n        itxn.AssetTransfer(\n            xfer_asset=listed_asset.id,\n            asset_amount=1,\n            asset_receiver=Txn.sender,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()    \n        \n        return String(\"Trade Request Cancelled!\")</code></pre>\n\n      <p>Ensure you have the necessary imports and class definitions for your contract.</p>\n      \n      <h3>Step 5: Create Two Arbitrary Assets for Experimenting</h3>\n      <p>Follow the steps to create and configure two assets for testing purposes.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import AssetConfigTxn, wait_for_confirmation\nfrom algosdk.account import address_from_private_key\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\nasset_creation_txn = AssetConfigTxn(\n    sender=address,\n    sp=params,\n    total=100,\n    default_frozen=False,\n    asset_name='Test Asset Two',\n    unit_name='TA2',\n    manager=address,\n    reserve=address,\n    strict_empty_address_check=False,\n)\n\nsigned_tx = asset_creation_txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_tx)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\n\nasset_id = algod_client.pending_transaction_info(tx_id)['asset-index']\nasset_info = algod_client.asset_info(asset_id)\nprint(asset_info)</code></pre>\n      \n      <h3>Step 6: Store Generated Asset IDs in .env</h3><pre><code>asset_1 = 123456\nasset_2 = 654321</code></pre>\n      \n      <h3>Step 7: Experiment with Opting the Contract into an Asset</h3>\n      <p>If you're creating multiple listings, you need to opt the contract into each asset the first time.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(atc, call_abi_method='triggerOptIn', asset_to_opt_into=asset_1, fee_payment=wrapped_payment)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 8: Make an Asset for Algo Listing Box</h3>\n      <p>Create an asset listing box to manage your asset listings.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nfrom base64 import b64decode\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(\n    atc, \n    call_abi_method='triggerOptIn', \n    asset_to_opt_into=asset_1, \n    fee_payment=wrapped_payment)\n\nasset_to_list_transaction = AssetTransferTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1, index=asset_1)\nwrapped_asset_list_transaction = TransactionWithSigner(asset_to_list_transaction, signer)\n\nbox_fee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=28_500)\nwrapped_box_fee_payment = TransactionWithSigner(box_fee_payment_tx, signer)\n\ncurrent_global_listing_counter = algod_client.application_info(app_id)['params']['global-state'][0]['value']['bytes']\nuint64_coder = ABIType.from_string('(uint64)')\nb64_decoded_global_listing_counter = b64decode(current_global_listing_counter)\nencoded_global_listing_counter = uint64_coder.decode(b64_decoded_global_listing_counter)[0]\n\nlisting_box_counter = encoded_global_listing_counter + 1\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nusers_listing_box_name = listing_box_coder.encode((address, listing_box_counter))\n\nasset_2 = int(os.getenv('asset_2'))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='postTradeRequestWithQuantity', \n    asset_to_list=wrapped_asset_list_transaction, \n    asset_request=asset_2, \n    asset_request_quantity=5,\n    box_fee_mbr_payment=wrapped_box_fee_payment,\n    transaction_parameters={'boxes': [[app_id, users_listing_box_name]]}\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 9: Check Respective Listing Information</h3>\n      <p>Retrieve and verify the listing information from the contract.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>import os\nfrom dotenv import load_dotenv\n\nload_dotenv()\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.abi import ABIType\nfrom base64 import b64decode\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\napp_id = int(os.getenv('app_id'))\n\nboxes = algod_client.application_boxes(app_id)['boxes']\n\nfor box in boxes:\n    box_name_b64encoded = box['name']\n    print(b64decode(box_name_b64encoded))\n    box_value = b64decode(algod_client.application_box_by_name(app_id, b64decode(box_name_b64encoded))['value'])\n    print(box_value)\n\n    #Asset for Algo: '(uint64,uint64)'\n    #Asset for Asset: '(uint64,uint64,bool)'\n    #Asset for Asset Quantity: '(uint64,uint64,uint64,bool)\n    #Asset Quantity for Asset Quantity: '(uint64,uint64,uint64,uint64,bool)'\n    #Universal Listing: '(uint64,uint64,uint64,uint64,bool)'\n    listing_box_value_coder = ABIType.from_string('(uint64,uint64)')\n    print(listing_box_value_coder.decode(box_value))\n</code></pre>\n      \n      <h3>Step 10: Purchase the Asset with Your Buyer Private Key</h3>\n      <p>Execute the purchase of the asset using the buyer's private key.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\nasset_2 = int(os.getenv('asset_2'))\n\n'''\nUser should opt-in to the asset purchased if they are not prepared to receive it\n'''\n#asset_opt_in_transaction = AssetTransferTxn(sender=address, sp=params, receiver=address, amt=0, index=asset_1)\n#wrapped_opt_in_transaction = TransactionWithSigner(asset_opt_in_transaction, signer)\n#atc.add_transaction(wrapped_opt_in_transaction)\n\noptin_fee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_optin_payment = TransactionWithSigner(optin_fee_payment_tx, signer)\n\napp_client.compose_call(\n    atc, \n    call_abi_method='triggerOptIn', \n    asset_to_opt_into=asset_2, \n    fee_payment=wrapped_optin_payment)\n\nasset_payment_tx = AssetTransferTxn(sender=address, sp=params, receiver=app_client.app_address, amt=5, index=asset_2)\nwrapped_asset_payment = TransactionWithSigner(asset_payment_tx, signer)\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='fulfillTradeRequestWithQuantity', \n    asset_trade_fulfillment=wrapped_asset_payment,\n    asset_transfer_fee=wrapped_fee_payment,\n    asset_listed=asset_1, \n    listing_name=(lister_address,counter), \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n\n<h3>Step 11: Complete Listing Request and Redeem Buyers Asset</h3>\n<pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\nasset_2 = int(os.getenv('asset_2'))\n\n'''\nUser should opt into the asset if they are not prepared to receive it\n'''\n#asset_opt_in_transaction = AssetTransferTxn(sender=address, sp=params, receiver=address, amt=0, index=asset_2)\n#wrapped_opt_in_transaction = TransactionWithSigner(asset_opt_in_transaction, signer)\n#atc.add_transaction(wrapped_opt_in_transaction)\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='claimFulfilledTradeRequestWithQuantity', \n    asset_transfer_fee=wrapped_fee_payment,\n    asset_requested=asset_2,\n    listing_name=(lister_address,counter), \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 12: Experiment with Cancelling a Listing Request</h3>\n      <p>If you fulfilled the previous request already, you will need to generate a new listing again with Step 8, and increment the \"counter\" variable from 1 to 2. For example:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>counter = 2</code></pre>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='cancelTradeRequestWithQuantity', \n    listed_asset=asset_1, \n    listing_name=(lister_address,counter), \n    transfer_fee=wrapped_fee_payment, \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 28,
    "language": "Python",
    "title": "Marketplace Contract Part 4 - Asset Quantity for Asset Quantity",
    "content": "\n      <h2>Video Walkthrough</h2>\n      <p>Watch the tutorial video for this chapter:</p> \n      \n\n<div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n  <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/iIxgYnfar80\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n\n      \n      <h3>Step 1: Generate Two Accounts</h3>\n      <ul class=\"inText\">\n        <li>One for Lister, one for Buyer</li>\n      </ul>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(private_key, address)\n</code></pre>\n      \n      <h3>Step 2: Load each Account with Funds</h3>\n      <p>Use the following link to load funds into each account:</p>\n      <a href=\"https://bank.testnet.algorand.network/\" target=\"_blank\">https://bank.testnet.algorand.network/</a>\n      \n      <h3>Step 3: Create .env</h3>\n      <pre class=\"overflow-auto shadow-md\"><code>algod_token = \nalgod_server = https://testnet-api.4160.nodely.dev\nprivate_key = lqPuVOtF4p6QpsaL7iTA6mbHoy7a5+nuAPjzw7HvckiXQWUlnZQVYSCZSvUK8w+MGjh09sNsx7WybOeb0MLD/Q==\nbuyer_private_key = jHx+aE6G/5RKAMJK7J7R+j3SyjKhzLsrbYIrzmmhWphJsT7CpTxqdhsjWQx4wDpx2I5B+1FiBSp16O5fXd/Sqg==\nasset_1 = 724395141\nasset_2 = 724449087\napp_id = 724455779\n</code></pre>\n      \n      <h3>Step 4: Compile Asset Quantity for Asset Quantity Listing Contract</h3>\n      <p>Create and compile the asset listing contract:</p>\n       <pre class=\"overflow-auto shadow-md\"><code>counter = 1</code></pre>\n      <p>Use the following implementation to compile your contract:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, String, gtxn, Asset, Txn, GlobalState, itxn, Global, BoxRef, UInt64, TransactionType\nfrom algopy.arc4 import abimethod, Address, Struct, Bool\nfrom algopy.arc4 import UInt64 as arc4UInt64\n\nclass listingName(Struct):\n    lister: Address\n    counter: arc4UInt64\n    \nclass tradeListingValueQuantityWithAssetQuantity(Struct):\n    asset_listed: arc4UInt64\n    asset_listed_quantity: arc4UInt64\n    asset_requested: arc4UInt64\n    asset_amount_requested: arc4UInt64\n    fulfilled: Bool\n    \nclass listings(ARC4Contract):\n    def __init__(self) -> None:\n        self.listingCounter = GlobalState(arc4UInt64(0))\n        \n    @abimethod\n    def triggerOptIn(\n        self,\n        asset_to_opt_into: Asset,\n        fee_payment: gtxn.PaymentTransaction\n    ) -> tuple[String, UInt64]:\n\n        assert fee_payment.amount >= 101_000\n        assert fee_payment.receiver == Global.current_application_address\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_to_opt_into,\n            asset_receiver=Global.current_application_address,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        return String(\"Successfully opted in to asset: \"), asset_to_opt_into.id\n        \n    @abimethod\n    def postTradeRequestQuantityWithQuantity(\n        self,\n        asset_to_list: gtxn.AssetTransferTransaction,\n        asset_request: Asset,\n        asset_request_quantity: arc4UInt64,\n        box_fee_mbr_payment: gtxn.PaymentTransaction\n    ) -> String:\n        \n        assert box_fee_mbr_payment.amount == 31_700\n        assert asset_to_list.asset_receiver == Global.current_application_address\n        \n        self.listingCounter.value = arc4UInt64(self.listingCounter.value.native + 1)\n        \n        listing_box_name_info = listingName(Address(Txn.sender), self.listingCounter.value)\n        \n        listing_box = BoxRef(key=listing_box_name_info.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert not exists\n        \n        listing_box.create(size=33)\n        \n        listing_box_value_info = tradeListingValueQuantityWithAssetQuantity(arc4UInt64(asset_to_list.xfer_asset.id), arc4UInt64(asset_to_list.asset_amount), arc4UInt64(asset_request.id), arc4UInt64(asset_request_quantity.native), Bool(False))\n            \n        listing_box.put(listing_box_value_info.bytes)\n        \n        return String(\"Trade Request Posted\")\n        \n    @abimethod\n    def fulfillTradeRequestQuantityWithQuantity(\n        self,\n        asset_trade_fulfillment: gtxn.AssetTransferTransaction,\n        asset_transfer_fee: gtxn.PaymentTransaction,\n        asset_listed: Asset,\n        listing_name: listingName,\n        \n    ) -> String:\n        \n        assert asset_transfer_fee.amount == 1000\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert exists\n        \n        listing_value = tradeListingValueQuantityWithAssetQuantity.from_bytes(value)\n        \n        assert listing_value.asset_listed == asset_listed.id\n        assert listing_value.asset_requested == asset_trade_fulfillment.xfer_asset.id\n        assert asset_trade_fulfillment.asset_amount == listing_value.asset_amount_requested\n                \n        itxn.AssetTransfer(\n            xfer_asset=asset_listed,\n            asset_receiver=Txn.sender,\n            asset_amount=listing_value.asset_listed_quantity.native,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_value.fulfilled = Bool(True)\n        listing_box.put(listing_value.bytes)\n        \n        return String(\"Trade Request Fulfilled!\")        \n                \n    @abimethod\n    def claimFulfilledTradeRequestQuantityWithQuantity(\n        self,\n        asset_transfer_fee: gtxn.PaymentTransaction,\n        asset_requested: Asset,\n        listing_name: listingName,\n    ) -> String:\n                \n        assert listing_name.lister == Address(Txn.sender)\n        assert asset_transfer_fee.amount == 1000\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert exists\n        \n        listing_value = tradeListingValueQuantityWithAssetQuantity.from_bytes(value)\n        \n        assert asset_requested.id == listing_value.asset_requested\n        assert listing_value.fulfilled == Bool(True)\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_requested.id,\n            asset_receiver=Txn.sender,\n            asset_amount=listing_value.asset_amount_requested.native,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()\n        \n        return String(\"Trade Request Completed!\")\n        \n    @abimethod\n    def cancelTradeRequestQuantityWithQuantity(\n        self,\n        listed_asset: Asset,\n        listing_name: listingName,\n        transfer_fee: gtxn.PaymentTransaction\n    ) -> String:\n        \n        assert transfer_fee.amount == 1000\n        assert listing_name.lister == Address(Txn.sender)\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        \n        assert exists\n        \n        listing_value = tradeListingValueQuantityWithAssetQuantity.from_bytes(value)\n        \n        assert listing_value.asset_listed == listed_asset.id\n        \n        itxn.AssetTransfer(\n            xfer_asset=listed_asset.id,\n            asset_amount=listing_value.asset_listed_quantity.native,\n            asset_receiver=Txn.sender,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()    \n        \n        return String(\"Trade Request Cancelled!\")</code></pre>\n\n      <p>Ensure you have the necessary imports and class definitions for your contract.</p>\n      \n      <h3>Step 5: Create Two Arbitrary Assets for Experimenting</h3>\n      <p>Follow the steps to create and configure two assets for testing purposes.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import AssetConfigTxn, wait_for_confirmation\nfrom algosdk.account import address_from_private_key\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\nasset_creation_txn = AssetConfigTxn(\n    sender=address,\n    sp=params,\n    total=100,\n    default_frozen=False,\n    asset_name='Test Asset Two',\n    unit_name='TA2',\n    manager=address,\n    reserve=address,\n    strict_empty_address_check=False,\n)\n\nsigned_tx = asset_creation_txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_tx)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\n\nasset_id = algod_client.pending_transaction_info(tx_id)['asset-index']\nasset_info = algod_client.asset_info(asset_id)\nprint(asset_info)</code></pre>\n      \n      <h3>Step 6: Store Generated Asset IDs in .env</h3><pre><code>asset_1 = 123456\nasset_2 = 654321</code></pre>\n      \n      <h3>Step 7: Experiment with Opting the Contract into an Asset</h3>\n      <p>If you're creating multiple listings, you need to opt the contract into each asset the first time.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(atc, call_abi_method='triggerOptIn', asset_to_opt_into=asset_1, fee_payment=wrapped_payment)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 8: Make an Asset for Algo Listing Box</h3>\n      <p>Create an asset listing box to manage your asset listings.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nfrom base64 import b64decode\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(\n    atc, \n    call_abi_method='triggerOptIn', \n    asset_to_opt_into=asset_1, \n    fee_payment=wrapped_payment)\n\nasset_to_list_transaction = AssetTransferTxn(sender=address, sp=params, receiver=app_client.app_address, amt=7, index=asset_1)\nwrapped_asset_list_transaction = TransactionWithSigner(asset_to_list_transaction, signer)\n\nbox_fee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=31_700)\nwrapped_box_fee_payment = TransactionWithSigner(box_fee_payment_tx, signer)\n\ncurrent_global_listing_counter = algod_client.application_info(app_id)['params']['global-state'][0]['value']['bytes']\nuint64_coder = ABIType.from_string('(uint64)')\nb64_decoded_global_listing_counter = b64decode(current_global_listing_counter)\nencoded_global_listing_counter = uint64_coder.decode(b64_decoded_global_listing_counter)[0]\n\nlisting_box_counter = encoded_global_listing_counter + 1\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nusers_listing_box_name = listing_box_coder.encode((address, listing_box_counter))\n\nasset_2 = int(os.getenv('asset_2'))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='postTradeRequestQuantityWithQuantity', \n    asset_to_list=wrapped_asset_list_transaction, \n    asset_request=asset_2, \n    asset_request_quantity=5,\n    box_fee_mbr_payment=wrapped_box_fee_payment,\n    transaction_parameters={'boxes': [[app_id, users_listing_box_name]]}\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 9: Check Respective Listing Information</h3>\n      <p>Retrieve and verify the listing information from the contract.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>import os\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.abi import ABIType\nfrom base64 import b64decode\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\napp_id = int(os.getenv('app_id'))\n\nboxes = algod_client.application_boxes(app_id)['boxes']\n\nfor box in boxes:\n    box_name_b64encoded = box['name']\n    print(b64decode(box_name_b64encoded))\n    box_value = b64decode(algod_client.application_box_by_name(app_id, b64decode(box_name_b64encoded))['value'])\n    print(box_value)\n\n    #Asset for Algo: '(uint64,uint64)'\n    #Asset for Asset: '(uint64,uint64,bool)'\n    #Asset for Asset Quantity: '(uint64,uint64,uint64,bool)\n    #Asset Quantity for Asset Quantity: '(uint64,uint64,uint64,uint64,bool)'\n    #Universal Listing: '(uint64,uint64,uint64,uint64,bool)'\n    listing_box_value_coder = ABIType.from_string('(uint64,uint64)')\n    print(listing_box_value_coder.decode(box_value))\n</code></pre>\n      \n      <h3>Step 10: Purchase the Asset with Your Buyer Private Key</h3>\n      <p>Execute the purchase of the asset using the buyer's private key.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\nasset_2 = int(os.getenv('asset_2'))\n\n'''\nUser should optin to the asset if they are not prepared to receive it\n'''\n#asset_opt_in_transaction = AssetTransferTxn(sender=address, sp=params, receiver=address, amt=0, index=asset_1)\n#wrapped_opt_in_transaction = TransactionWithSigner(asset_opt_in_transaction, signer)\n#atc.add_transaction(wrapped_opt_in_transaction)\n\noptin_fee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_optin_payment = TransactionWithSigner(optin_fee_payment_tx, signer)\n\napp_client.compose_call(\n    atc, \n    call_abi_method='triggerOptIn', \n    asset_to_opt_into=asset_2, \n    fee_payment=wrapped_optin_payment)\n\nasset_payment_tx = AssetTransferTxn(sender=address, sp=params, receiver=app_client.app_address, amt=5, index=asset_2)\nwrapped_asset_payment = TransactionWithSigner(asset_payment_tx, signer)\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='fulfillTradeRequestQuantityWithQuantity', \n    asset_trade_fulfillment=wrapped_asset_payment,\n    asset_transfer_fee=wrapped_fee_payment,\n    asset_listed=asset_1, \n    listing_name=(lister_address,counter), \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n\n<h3>Step 11: Complete Listing Request and Redeem Buyers Asset</h3>\n<pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\nasset_2 = int(os.getenv('asset_2'))\n\n'''\nUser should opt into the asset if they are not prepared to receive it\n'''\n#asset_opt_in_transaction = AssetTransferTxn(sender=address, sp=params, receiver=address, amt=0, index=asset_2)\n#wrapped_opt_in_transaction = TransactionWithSigner(asset_opt_in_transaction, signer)\n#atc.add_transaction(wrapped_opt_in_transaction)\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='claimFulfilledTradeRequestQuantityWithQuantity', \n    asset_transfer_fee=wrapped_fee_payment,\n    asset_requested=asset_2,\n    listing_name=(lister_address,counter), \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 12: Experiment with Cancelling a Listing Request</h3>\n      <p>If you fulfilled the previous request already, you will need to generate a new listing again with Step 8, and increment the \"counter\" variable from 1 to 2. For example:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>counter = 2</code></pre>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='cancelTradeRequestQuantityWithQuantity', \n    listed_asset=asset_1, \n    listing_name=(lister_address,counter), \n    transfer_fee=wrapped_fee_payment, \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 29,
    "language": "Python",
    "title": "Marketplace Contract Part 5 - Universal Listings",
    "content": "\n      <h2>Video Walkthrough</h2>\n      <p>Watch the tutorial video for this chapter:</p>      \n\n<div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n  <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/3TAdil0hNRk\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n\n      \n      <h3>Step 1: Generate Two Accounts</h3>\n      <ul class=\"inText\">\n        <li>One for Lister, one for Buyer</li>\n      </ul>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(private_key, address)\n</code></pre>\n      \n      <h3>Step 2: Load each Account with Funds</h3>\n      <p>Use the following link to load funds into each account:</p>\n      <a href=\"https://bank.testnet.algorand.network/\" target=\"_blank\">https://bank.testnet.algorand.network/</a>\n      \n      <h3>Step 3: Create .env</h3>\n      <pre class=\"overflow-auto shadow-md\"><code>algod_token = \nalgod_server = https://testnet-api.4160.nodely.dev\nprivate_key = lqPuVOtF4p6QpsaL7iTA6mbHoy7a5+nuAPjzw7HvckiXQWUlnZQVYSCZSvUK8w+MGjh09sNsx7WybOeb0MLD/Q==\nbuyer_private_key = jHx+aE6G/5RKAMJK7J7R+j3SyjKhzLsrbYIrzmmhWphJsT7CpTxqdhsjWQx4wDpx2I5B+1FiBSp16O5fXd/Sqg==\nasset_1 = 724395141\nasset_2 = 724449087\napp_id = 724455779\n</code></pre>\n      \n      <h3>Step 4: Compile Universal Listing Contract</h3>\n      <p>Create and compile the asset listing contract:</p>\n       <pre class=\"overflow-auto shadow-md\"><code>counter = 1</code></pre>\n      <p>Use the following implementation to compile your contract:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, String, gtxn, Asset, Txn, GlobalState, itxn, Global, BoxRef, UInt64, TransactionType\nfrom algopy.arc4 import abimethod, Address, Struct, Bool\nfrom algopy.arc4 import UInt64 as arc4UInt64\n\nclass listingName(Struct):\n    lister: Address\n    counter: arc4UInt64\n    \nclass universalTradeListing(Struct):\n    asset_listed: arc4UInt64\n    asset_listed_quantity: arc4UInt64\n    asset_requested: arc4UInt64\n    asset_amount_requested: arc4UInt64\n    fulfilled: Bool\n    \nclass listings(ARC4Contract):\n    def __init__(self) -> None:\n        self.listingCounter = GlobalState(arc4UInt64(0))\n        \n    @abimethod\n    def triggerOptIn(\n        self,\n        asset_to_opt_into: Asset,\n        fee_payment: gtxn.PaymentTransaction\n    ) -> tuple[String, UInt64]:\n\n        assert fee_payment.amount >= 101_000\n        assert fee_payment.receiver == Global.current_application_address\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_to_opt_into,\n            asset_receiver=Global.current_application_address,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        return String(\"Successfully opted in to asset: \"), asset_to_opt_into.id\n        \n    @abimethod\n    def triggerOptIn(\n        self,\n        asset_to_opt_into: Asset,\n        fee_payment: gtxn.PaymentTransaction\n    ) -> tuple[String, UInt64]:\n\n        assert fee_payment.amount >= 101_000\n        assert fee_payment.receiver == Global.current_application_address\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_to_opt_into,\n            asset_receiver=Global.current_application_address,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        return String(\"Successfully opted in to asset: \"), asset_to_opt_into.id\n            \n    @abimethod\n    def postUniversalListing(\n        self,\n        asset_to_list: gtxn.AssetTransferTransaction,\n        asset_request: arc4UInt64,\n        asset_request_quantity: arc4UInt64,\n        box_fee_mbr_payment: gtxn.PaymentTransaction\n    ) -> String:\n        \n        assert box_fee_mbr_payment.amount == 31_700\n        assert asset_to_list.asset_receiver == Global.current_application_address\n        \n        self.listingCounter.value = arc4UInt64(self.listingCounter.value.native + 1)\n        \n        listing_box_name_info = listingName(Address(Txn.sender), self.listingCounter.value)\n        \n        listing_box = BoxRef(key=listing_box_name_info.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert not exists\n        \n        listing_box.create(size=33)\n        \n        listing_box_value_info = universalTradeListing(arc4UInt64(asset_to_list.xfer_asset.id), arc4UInt64(asset_to_list.asset_amount), asset_request, arc4UInt64(asset_request_quantity.native), Bool(False))\n            \n        listing_box.put(listing_box_value_info.bytes)\n        \n        return String(\"Trade Request Posted\")\n        \n    @abimethod\n    def fulfillUniversalListing(\n        self,\n        asset_transfer_fee: gtxn.PaymentTransaction,\n        asset_listed: Asset,\n        listing_name: listingName,\n        \n    ) -> String:\n        \n        assert asset_transfer_fee.amount == 1000\n\n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert exists\n        \n        listing_value = universalTradeListing.from_bytes(value)\n\n        if Global.group_size == 3:\n            assert gtxn.Transaction(0).type == TransactionType.Payment\n            payment_fulfillment_tx = gtxn.PaymentTransaction(0)\n            assert payment_fulfillment_tx.receiver == Global.current_application_address\n            assert listing_value.asset_listed == asset_listed.id\n            assert listing_value.asset_requested == 0\n            assert payment_fulfillment_tx.amount == listing_value.asset_amount_requested.native\n\n            itxn.AssetTransfer(\n                xfer_asset=asset_listed,\n                asset_receiver=Txn.sender,\n                asset_amount=listing_value.asset_listed_quantity.native,\n                fee=Global.min_txn_fee\n            ).submit()            \n            \n            itxn.Payment(\n                receiver=listing_name.lister.native,\n                amount=listing_value.asset_amount_requested.native,\n                fee=Global.min_txn_fee\n            ).submit()\n            \n            listing_box.delete()\n            \n            return String(\"Buyer paid with Algo, Listing Fulfilled!\")\n            \n        elif Global.group_size == 5:\n            assert gtxn.Transaction(2).type == TransactionType.AssetTransfer\n            asset_trade_fulfillment_tx = gtxn.AssetTransferTransaction(2)\n            assert asset_trade_fulfillment_tx.asset_receiver == Global.current_application_address\n            assert listing_value.asset_listed == asset_listed.id\n            assert listing_value.asset_requested == asset_trade_fulfillment_tx.xfer_asset.id\n            assert asset_trade_fulfillment_tx.asset_amount == listing_value.asset_amount_requested\n                        \n            itxn.AssetTransfer(\n                xfer_asset=asset_listed,\n                asset_receiver=Txn.sender,\n                asset_amount=listing_value.asset_listed_quantity.native,\n                fee=Global.min_txn_fee\n            ).submit()\n                    \n        listing_value.fulfilled = Bool(True)\n        listing_box.put(listing_value.bytes)\n        \n        return String(\"Trade Request Fulfilled! Lister can now claim\")        \n                \n    @abimethod\n    def claimUniversalListing(\n        self,\n        asset_transfer_fee: gtxn.PaymentTransaction,\n        asset_requested: Asset,\n        listing_name: listingName,\n    ) -> String:\n                \n        assert listing_name.lister == Address(Txn.sender)\n        assert asset_transfer_fee.amount == 1000\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        assert exists\n        \n        listing_value = universalTradeListing.from_bytes(value)\n        \n        assert asset_requested.id == listing_value.asset_requested\n        assert listing_value.fulfilled == Bool(True)\n        \n        itxn.AssetTransfer(\n            xfer_asset=asset_requested.id,\n            asset_receiver=Txn.sender,\n            asset_amount=listing_value.asset_amount_requested.native,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()\n        \n        return String(\"Trade Request Completed!\")\n        \n    @abimethod\n    def cancelUniversalListing(\n        self,\n        listed_asset: Asset,\n        listing_name: listingName,\n        transfer_fee: gtxn.PaymentTransaction\n    ) -> String:\n        \n        assert transfer_fee.amount == 1000\n        assert listing_name.lister == Address(Txn.sender)\n        \n        listing_box = BoxRef(key=listing_name.bytes)\n        \n        value, exists = listing_box.maybe()\n        \n        assert exists\n        \n        listing_value = universalTradeListing.from_bytes(value)\n        \n        assert listing_value.asset_listed == listed_asset.id\n        \n        itxn.AssetTransfer(\n            xfer_asset=listed_asset.id,\n            asset_amount=listing_value.asset_listed_quantity.native,\n            asset_receiver=Txn.sender,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        listing_box.delete()    \n        \n        return String(\"Trade Request Cancelled!\")</code></pre>\n\n      <p>Ensure you have the necessary imports and class definitions for your contract.</p>\n      \n      <h3>Step 5: Create Two Arbitrary Assets for Experimenting</h3>\n      <p>Follow the steps to create and configure two assets for testing purposes.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import AssetConfigTxn, wait_for_confirmation\nfrom algosdk.account import address_from_private_key\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\nasset_creation_txn = AssetConfigTxn(\n    sender=address,\n    sp=params,\n    total=100,\n    default_frozen=False,\n    asset_name='Test Asset Two',\n    unit_name='TA2',\n    manager=address,\n    reserve=address,\n    strict_empty_address_check=False,\n)\n\nsigned_tx = asset_creation_txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_tx)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\n\nasset_id = algod_client.pending_transaction_info(tx_id)['asset-index']\nasset_info = algod_client.asset_info(asset_id)\nprint(asset_info)</code></pre>\n      \n      <h3>Step 6: Store Generated Asset IDs in .env</h3><pre><code>asset_1 = 123456\nasset_2 = 654321</code></pre>\n      \n      <h3>Step 7: Experiment with Opting the Contract into an Asset</h3>\n      <p>If you're creating multiple listings, you need to opt the contract into each asset the first time.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(atc, call_abi_method='triggerOptIn', asset_to_opt_into=asset_1, fee_payment=wrapped_payment)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 8: Make an Asset for Algo Listing Box</h3>\n      <p>Create an asset listing box to manage your asset listings.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nimport os\nfrom base64 import b64decode\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_payment = TransactionWithSigner(fee_payment_tx, signer)\n\napp_client.compose_call(\n    atc, \n    call_abi_method='triggerOptIn', \n    asset_to_opt_into=asset_1, \n    fee_payment=wrapped_payment)\n\nasset_to_list_transaction = AssetTransferTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1, index=asset_1)\nwrapped_asset_list_transaction = TransactionWithSigner(asset_to_list_transaction, signer)\n\nbox_fee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=31_700)\nwrapped_box_fee_payment = TransactionWithSigner(box_fee_payment_tx, signer)\n\ncurrent_global_listing_counter = algod_client.application_info(app_id)['params']['global-state'][0]['value']['bytes']\nuint64_coder = ABIType.from_string('(uint64)')\nb64_decoded_global_listing_counter = b64decode(current_global_listing_counter)\nencoded_global_listing_counter = uint64_coder.decode(b64_decoded_global_listing_counter)[0]\n\nlisting_box_counter = encoded_global_listing_counter + 1\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nusers_listing_box_name = listing_box_coder.encode((address, listing_box_counter))\n\nasset_2 = int(os.getenv('asset_2'))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='postUniversalListing', \n    asset_to_list=wrapped_asset_list_transaction, \n    asset_request=0, \n    asset_request_quantity=2_000_000,\n    box_fee_mbr_payment=wrapped_box_fee_payment,\n    transaction_parameters={'boxes': [[app_id, users_listing_box_name]]}\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 9: Check Respective Listing Information</h3>\n      <p>Retrieve and verify the listing information from the contract.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>import os\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.abi import ABIType\nfrom base64 import b64decode\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\napp_id = int(os.getenv('app_id'))\n\nboxes = algod_client.application_boxes(app_id)['boxes']\n\nfor box in boxes:\n    box_name_b64encoded = box['name']\n    print(b64decode(box_name_b64encoded))\n    box_value = b64decode(algod_client.application_box_by_name(app_id, b64decode(box_name_b64encoded))['value'])\n    print(box_value)\n\n    #Asset for Algo: '(uint64,uint64)'\n    #Asset for Asset: '(uint64,uint64,bool)'\n    #Asset for Asset Quantity: '(uint64,uint64,uint64,bool)\n    #Asset Quantity for Asset Quantity: '(uint64,uint64,uint64,uint64,bool)'\n    #Universal Listing: '(uint64,uint64,uint64,uint64,bool)'\n    listing_box_value_coder = ABIType.from_string('(uint64,uint64)')\n    print(listing_box_value_coder.decode(box_value))\n</code></pre>\n      \n      <h3>Step 10: Purchase the Asset with Your Buyer Private Key</h3>\n      <p>Execute the purchase of the asset using the buyer's private key.</p>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('buyer_private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\nasset_2 = int(os.getenv('asset_2'))\n\n'''\nUser should opt into the asset if they are not prepared to receive it\n'''\n#asset_opt_in_transaction = AssetTransferTxn(sender=address, sp=params, receiver=address, amt=0, index=asset_1)\n#wrapped_opt_in_transaction = TransactionWithSigner(asset_opt_in_transaction, signer)\n#atc.add_transaction(wrapped_opt_in_transaction)\n\n#5 tx for asset to asset payments\n\noptin_fee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=101_000)\nwrapped_optin_payment = TransactionWithSigner(optin_fee_payment_tx, signer)\n\napp_client.compose_call(\n    atc, \n    call_abi_method='triggerOptIn', \n    asset_to_opt_into=asset_2, \n    fee_payment=wrapped_optin_payment)\n\nasset_payment_tx = AssetTransferTxn(sender=address, sp=params, receiver=app_client.app_address, amt=3, index=asset_2)\nwrapped_asset_payment = TransactionWithSigner(asset_payment_tx, signer)\n\nasset_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=2_000_000)\nwrapped_asset_payment = TransactionWithSigner(asset_payment_tx, signer)\n\natc.add_transaction(wrapped_asset_payment)\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='fulfillUniversalListing', \n    asset_transfer_fee=wrapped_fee_payment,\n    asset_listed=asset_1, \n    listing_name=(lister_address,counter), \n    transaction_parameters={'boxes': [[app_id, box_name]], 'accounts': [lister_address]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n\n<h3>Step 11: Complete Listing Request and Redeem Buyers Asset</h3>\n<pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom pathlib import Path\nfrom algosdk.util import algos_to_microalgos\nfrom algosdk.abi import ABIType\nimport os\nfrom base64 import b64decode\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\nasset_2 = int(os.getenv('asset_2'))\n\n'''\nUser should opt into the asset if they are not prepared to receive it\n'''\n#asset_opt_in_transaction = AssetTransferTxn(sender=address, sp=params, receiver=address, amt=0, index=asset_2)\n#wrapped_opt_in_transaction = TransactionWithSigner(asset_opt_in_transaction, signer)\n#atc.add_transaction(wrapped_opt_in_transaction)\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='claimUniversalListing', \n    asset_transfer_fee=wrapped_fee_payment,\n    asset_requested=asset_2,\n    listing_name=(lister_address,counter), \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n      \n      <h3>Step 12: Experiment with Cancelling a Listing Request</h3>\n      <p>If you fulfilled the previous request already, you will need to generate a new listing again with Step 8, and increment the \"counter\" variable from 1 to 2. For example:</p>\n      <pre class=\"overflow-auto shadow-md\"><code>counter = 2</code></pre>\n      <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, TransactionWithSigner, AtomicTransactionComposer\nfrom algosdk.transaction import PaymentTxn\nfrom algosdk.abi import ABIType\nfrom pathlib import Path\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\napp_spec = Path(__file__).parent / './listings.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_1 = int(os.getenv('asset_1'))\n\nfee_payment_tx = PaymentTxn(sender=address, sp=params, receiver=app_client.app_address, amt=1000)\nwrapped_fee_payment = TransactionWithSigner(fee_payment_tx, signer)\n\nlister_address = address_from_private_key(os.getenv('private_key'))\ncounter = 1 #Remember to increment counter for additional listings\n\nlisting_box_coder = ABIType.from_string('(address,uint64)')\nbox_name = listing_box_coder.encode((lister_address, counter))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='cancelUniversalListing', \n    listed_asset=asset_1, \n    listing_name=(lister_address,counter), \n    transfer_fee=wrapped_fee_payment, \n    transaction_parameters={'boxes': [[app_id, box_name]]})\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\n\nprint(tx_ids)\nprint(abi_results)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 30,
    "language": "Python",
    "title": "ARC69 NFT Metadata and IPFS Integration",
    "content": "\n    <p>This tutorial guides you through creating an ARC69-compliant NFT with metadata stored on the blockchain and the image hosted on IPFS. It complements the video tutorial.</p>\n    \n    <h2>YouTube Tutorial</h2>\n    <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n        <iframe\n            class=\"absolute top-0 left-0 w-full h-full border-0\"\n            src=\"https://www.youtube.com/embed/EN9IPhTSz34?si=Ibp9sp0jLUpAE9e9\"\n            frameborder=\"0\"\n            allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n            allowfullscreen>\n        </iframe>\n    </div>\n    \n    <h2>Generating an Account</h2>\n    <p>Use the following Python code to generate a new account for managing your ARC69 assets:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(private_key, address)</code></pre>\n    \n    <h2>Funding the Account</h2>\n    <p>Once the account is generated, it needs funding to submit transactions. Visit the <a href=\"https://bank.testnet.algorand.network/\" target=\"_blank\">Algorand Testnet Faucet</a> to add funds.</p>\n    \n    <h2>Displaying the NFT Image</h2>\n    <p>For this tutorial, the image used is \"Charmander.png\". Make sure to place this image in the <code>public/images/</code> directory and reference it appropriately. Here’s the file path:</p>\n    <img src=\"/images/charmander.png\" alt=\"Charmander NFT Image\" class=\"w-full max-w-xs mx-auto rounded-lg shadow-md\" />\n\n    <h2>ARC69 Metadata Structure</h2>\n    <p>In an ARC69 NFT, the image is immutable, but metadata (stored in the note field) can be updated. Images are hosted off-chain on IPFS, which ensures efficient and decentralized storage.</p>\n    <p>In this example, we’ll use Pinata as our IPFS service. Generate an API key, secret, and JWT on <a href=\"https://pinata.cloud/\" target=\"_blank\">Pinata</a> and store them in your <code>.env</code> file.</p>\n    \n    <h3>Example Code: Minting an ARC69 NFT</h3>\n    <p>Below is a code snippet for minting an ARC69 NFT, including metadata in the note field. This code uploads the image to IPFS and sets up the NFT on Algorand.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import wait_for_confirmation, AssetConfigTxn\nfrom dotenv import load_dotenv\nfrom pinata import Pinata\nfrom algosdk.account import address_from_private_key\nimport os\nimport json\n\nload_dotenv()\n\npinata_api_key = os.getenv('api_key')\npinata_api_secret = os.getenv('api_secret')\npinata_jwt = os.getenv('jwt')\npinata_client = Pinata(api_key=pinata_api_key, secret_key=pinata_api_secret, access_token=pinata_jwt)\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\n# Minting ARC69 NFT\nimage_path = './charmander.png'\nresponse = pinata_client.pin_file(image_path)\nimage_ipfs_hash = response['data']['IpfsHash']\nviewable_hash = f'https://gateway.pinata.cloud/ipfs/' + image_ipfs_hash\n\nmetadata = {\n    \"standard\": \"arc69\",\n    \"mime_type\": \"image/png\",\n    \"properties\": {\n        \"Type\": \"Fire\",\n        \"Description\": \"A fire pokemon with a fiery tail\",\n        \"Level\": \"1\",\n        \"Experience\": \"0\",\n    }\n}\n\nparams = algod_client.suggested_params()\n\nasset_config_transaction = AssetConfigTxn(\n    sender=address,\n    sp=params,\n    total=1,\n    decimals=0,\n    default_frozen=False,\n    manager=address,\n    reserve=address,\n    asset_name=\"Test Charmander\",\n    unit_name=\"TC#1\",\n    url=viewable_hash,\n    strict_empty_address_check=False,\n    note=json.dumps(metadata).encode()\n)\n\nsigned_ac_tx = asset_config_transaction.sign(private_key)\ntx_id = algod_client.send_transaction(signed_ac_tx)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\nasset_index = algod_client.pending_transaction_info(tx_id)['asset-index']\nprint(asset_index)\n    </code></pre>\n\n    <h3>Example Code: Updating ARC69 Metadata</h3>\n    <p>After minting, you can update specific metadata fields, such as experience or level, by sending an asset configuration transaction with updated metadata in the note field.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>metadata = {\n    \"standard\": \"arc69\",\n    \"mime_type\": \"image/png\",\n    \"properties\": {\n        \"Type\": \"Fire\",\n        \"Description\": \"A fire pokemon with a fiery tail\",\n        \"Level\": \"4\",\n        \"Experience\": \"15\",\n    }\n}\n\nasset_config_transaction = AssetConfigTxn(\n    index=asset_index,\n    sender=address,\n    sp=params,\n    manager=address,\n    reserve=address,\n    strict_empty_address_check=False,\n    note=json.dumps(metadata).encode()\n)\n\nsigned_ac_tx = asset_config_transaction.sign(private_key)\ntx_id = algod_client.send_transaction(signed_ac_tx)\nprint(tx_id)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 31,
    "language": "Python",
    "title": "Creating and Updating ARC19 NFTs with IPFS Metadata",
    "content": "\n    <p>This tutorial demonstrates how to create an ARC19-compliant NFT with mutable metadata hosted on IPFS. The metadata can be updated by changing the reserve address, which points to a new IPFS hash for the metadata. Follow along with the code examples and steps below.</p>\n\n    <h2>Generating an Account</h2>\n    <p>Use the following Python code to generate a new account that will be used for managing the ARC19 NFT:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(private_key, address)</code></pre>\n    \n    <h2>Funding the Account</h2>\n    <p>To submit transactions, you need to fund the generated account. Use the <a href=\"https://bank.testnet.algorand.network/\" target=\"_blank\">Algorand Testnet Faucet</a> to add funds.</p>\n    \n    <h2>ARC19 Overview</h2>\n    <p>With ARC19 NFTs, the metadata is mutable. The reserve address serves as a pointer to metadata stored on IPFS. By updating this address, the NFT’s metadata can change, allowing for mutable properties while the image and other data are hosted on IPFS.</p>\n\n    <h3>Image Display</h3>\n    <img src=\"/images/charmander.png\" alt=\"Charmander Image\" class=\"w-full max-w-xs mx-auto rounded-lg shadow-md\" />\n    <img src=\"/images/charmander2.0.png\" alt=\"Charmander Updated Image\" class=\"w-full max-w-xs mx-auto rounded-lg shadow-md\" />\n\n    <h2>Minting an ARC19 NFT</h2>\n    <p>The code snippet below uploads an image to IPFS via Pinata, then creates an ARC19-compliant NFT on Algorand, linking to the image metadata:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algosdk.transaction import wait_for_confirmation, AssetConfigTxn\nfrom dotenv import load_dotenv\nfrom pinata import Pinata\nfrom algosdk.account import address_from_private_key\nimport os\nimport json\nfrom PIL import Image\nfrom cid import make_cid\nimport multihash\nimport hashlib\nfrom algosdk.encoding import encode_address\n\nload_dotenv()\n\n# Set up Pinata client for IPFS\npinata_api_key = os.getenv('api_key')\npinata_api_secret = os.getenv('api_secret')\npinata_jwt = os.getenv('jwt')\npinata_client = Pinata(api_key=pinata_api_key, secret_key=pinata_api_secret, access_token=pinata_jwt)\n\n# Set up Algorand client\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\n# Mint ARC19 NFT\nimage_path = './charmander.png'\nresponse = pinata_client.pin_file(image_path)\nimage_ipfs_hash = response['data']['IpfsHash']\nviewable_hash = f'https://gateway.pinata.cloud/ipfs/' + image_ipfs_hash\n\nimg = Image.open(image_path)\n\nmetadata = {\n    \"standard\": \"arc19\",\n    \"image\": viewable_hash,\n    \"image_mime_type\": \"image/png\",\n    \"image_integrity\": \"sha256-\" + str(hashlib.sha256(img.tobytes()).hexdigest()),\n    \"properties\": {\n        \"Type\": \"Fire\",\n        \"Description\": \"A fire pokemon with a fiery tail\",\n        \"Level\": \"1\",\n        \"Experience\": \"0\",\n    }\n}\n\nfile_name = './metadata.json'\nwith open(file_name, 'w') as f:\n    json.dump(metadata, f)\n\njson_pin_hash = pinata_client.pin_file(file_name)['data']['IpfsHash']\ndigest = multihash.decode(make_cid(json_pin_hash).multihash).digest\narc19_algorand_address = encode_address(digest)\nprint(f'Original ARC19 address: {arc19_algorand_address}')\n\nparams = algod_client.suggested_params()\n\nasset_config_transaction = AssetConfigTxn(\n    sender=address,\n    sp=params,\n    total=1,\n    decimals=0,\n    default_frozen=False,\n    manager=address,\n    reserve=arc19_algorand_address,\n    asset_name=\"Test Charmander\",\n    unit_name=\"TC#1\",\n    url=\"template-ipfs://{ipfscid:0:dag-pb:reserve:sha2-256}\",\n    strict_empty_address_check=False,\n)\n\nsigned_ac_tx = asset_config_transaction.sign(private_key)\ntx_id = algod_client.send_transaction(signed_ac_tx)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\nasset_index = algod_client.pending_transaction_info(tx_id)['asset-index']\nprint(asset_index)</code></pre>\n\n    <h2>Updating ARC19 Metadata</h2>\n    <p>The following code example demonstrates updating the ARC19 metadata by pointing the reserve address to a new IPFS link, representing updated metadata:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>image_path = './charmander2.0.png'\nresponse = pinata_client.pin_file(image_path)\nimage_ipfs_hash = response['data']['IpfsHash']\nviewable_hash = f'https://gateway.pinata.cloud/ipfs/' + image_ipfs_hash\n\nimg = Image.open(image_path)\n\nmetadata = {\n    \"standard\": \"arc19\",\n    \"image\": viewable_hash,\n    \"image_mime_type\": \"image/png\",\n    \"image_integrity\": \"sha256-\" + str(hashlib.sha256(img.tobytes()).hexdigest()),\n    \"properties\": {\n        \"Type\": \"Fire\",\n        \"Description\": \"A fire pokemon with a fiery tail\",\n        \"Level\": \"4\",\n        \"Experience\": \"15\",\n    }\n}\n\nfile_name = './metadata.json'\nwith open(file_name, 'w') as f:\n    json.dump(metadata, f)\n\njson_pin_hash = pinata_client.pin_file(file_name)['data']['IpfsHash']\ndigest = multihash.decode(make_cid(json_pin_hash).multihash).digest\narc19_algorand_address = encode_address(digest)\nprint(f'New ARC19 address: {arc19_algorand_address}')\n\nparams = algod_client.suggested_params()\n\nasset_config_transaction = AssetConfigTxn(\n    index=asset_index,\n    sender=address,\n    sp=params,\n    default_frozen=False,\n    manager=address,\n    reserve=arc19_algorand_address,\n    url=\"template-ipfs://{ipfscid:0:dag-pb:reserve:sha2-256}\",\n    strict_empty_address_check=False,\n)\n\nsigned_ac_tx = asset_config_transaction.sign(private_key)\ntx_id = algod_client.send_transaction(signed_ac_tx)\nprint(tx_id)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 32,
    "language": "Python",
    "title": "ARC69 Minter and Modifier Part 1",
    "content": "\n        <h2>Video Tutorial</h2>\n<div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n    <iframe\n        class=\"absolute top-0 left-0 w-full h-full border-0\"\n        src=\"https://www.youtube.com/embed/kwMR_0300Og\"\n        frameborder=\"0\"\n        allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n        allowfullscreen>\n    </iframe>\n</div>\n        <h2>Contract - Registering and Determining the User's Pokemon</h2>\n        <p>Compile the contract using:</p>\n        <pre class=\"overflow-auto shadow-md\"><code>algokit compile arc69NFTmodifier.py</code></pre>\n\n        <h3>Python Code</h3>\n        <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, Global, GlobalState, gtxn, BoxRef, Txn, op\nfrom algopy.arc4 import abimethod, Struct\nfrom algopy.arc4 import UInt64 as arc4UInt64\nfrom algopy.arc4 import String as arc4String\n\nclass availablePokemon(Struct):\n    pokemon_name: arc4String\n    pokemon_type: arc4String\n    pokemon_description: arc4String\n    pokemon_ipfs_hash: arc4String\n\nclass arc69NFTmodifier(ARC4Contract):\n    def __init__(self) -> None:\n        self.pokemonUnitCounter = GlobalState(arc4UInt64(0))\n    \n    @abimethod\n    def registerNewPokemonData(\n        self,\n        pokemon_name: arc4String,\n        pokemon_type: arc4String,\n        pokemon_description: arc4String,\n        pokemon_ipfs_hash: arc4String,\n        payment_txn: gtxn.PaymentTransaction,\n    ) -> arc4String:\n        \n        assert payment_txn.receiver == Global.current_application_address\n        self.pokemonUnitCounter.value = arc4UInt64(self.pokemonUnitCounter.value.native + 1)\n        \n        box_ref = BoxRef(key=self.pokemonUnitCounter.value.bytes)\n        value, exists = box_ref.maybe()\n        assert not exists\n        \n        new_pokemon_info = availablePokemon(\n            pokemon_name=pokemon_name,\n            pokemon_type=pokemon_type,\n            pokemon_description=pokemon_description,\n            pokemon_ipfs_hash=pokemon_ipfs_hash\n        )\n        \n        box_ref.create(size=new_pokemon_info.bytes.length)\n        box_ref.put(new_pokemon_info.bytes)\n        \n        return arc4String('Pokemon Registered to Contract: ') + pokemon_name\n\n    @abimethod\n    def determineUserPokemon(\n        self,\n        payment_txn: gtxn.PaymentTransaction\n    ) -> tuple[arc4String, arc4UInt64]:\n        \n        assert payment_txn.amount == 18_500\n        assert payment_txn.receiver == Global.current_application_address\n        \n        randomizer = arc4UInt64(\n            Global.latest_timestamp + Global.round + arc4UInt64.from_bytes(Txn.tx_id[0:8]).native % arc4UInt64.from_bytes(Txn.tx_id[-8:]).native\n        )\n        \n        hashed_randomizer = op.sha256(randomizer.bytes)\n        \n        pokemon_selection = arc4UInt64((arc4UInt64.from_bytes(hashed_randomizer[0:8]).native % self.pokemonUnitCounter.value.native) + 1)\n        \n        users_claim_box = BoxRef(key=Txn.sender.bytes)\n        value, exists = users_claim_box.maybe()\n        assert not exists\n        \n        users_claim_box.create(size=8)\n        users_claim_box.put(pokemon_selection.bytes)\n        \n        return arc4String('Users Pokemon # Selected:'), pokemon_selection\n        </code></pre>\n\n        <h2>Setting Up Environment Variables (.env)</h2>\n        <pre class=\"overflow-auto shadow-md\"><code>private_key = ENTER PRIVATE KEY\naddress = ENTER ADDRESS (OPTIONAL)\napi_key = ENTER API KEY\napi_secret = ENTER API SECRET\njwt = ENTER JWT\nalgod_token = \nalgod_server = https://testnet-api.4160.nodely.dev\napp_id = ENTER APP ID GENERATED</code></pre>\n\n        <h2>Upload Pokemon Images to IPFS</h2>\n        <div class=\"flex justify-center space-x-4\">\n    <img src=\"/images/charmander.png\" alt=\"Charmander Image\" class=\"w-10 h-auto rounded-lg shadow-md\" />\n    <img src=\"/images/bulba.png\" alt=\"Bulbasaur Image\" class=\"w-10 h-auto rounded-lg shadow-md\" />\n    <img src=\"/images/squirtle.png\" alt=\"Squirtle Image\" class=\"w-10 h-auto rounded-lg shadow-md\" />\n</div>\n        <pre class=\"overflow-auto shadow-md\"><code>from pinata import Pinata\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\napi_key = os.getenv('api_key')\napi_secret = os.getenv('api_secret')\njwt = os.getenv('jwt')\n\npinata = Pinata(api_key=api_key, secret_key=api_secret, access_token=jwt)\n\nfile_names = ['./pokeimages/bulba.png','./pokeimages/charmander.png','./pokeimages/squirtle.png']\nfor name in file_names:\n    response = pinata.pin_file(name)\n    image_ipfs_hash = response['data']['IpfsHash']\n    viewable_hash = f'https://gateway.pinata.cloud/ipfs/' + image_ipfs_hash\n    print(image_ipfs_hash, viewable_hash)</code></pre>\n\n        <h2>Registering Pokemon for Minting to the Contract</h2>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algokit_utils import ApplicationClient\nfrom algosdk.atomic_transaction_composer import AtomicTransactionComposer, AccountTransactionSigner, TransactionWithSigner\nfrom algosdk.transaction import PaymentTxn\nfrom algosdk.account import address_from_private_key\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\n\nprivate_key = os.getenv('private_key')\n\nalgod_client = AlgodClient(node_token, node_server)\napp_spec = Path(__file__).parent / './arc69NFTmodifier.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key=private_key)\naddress = address_from_private_key(private_key=private_key)\nparams = algod_client.suggested_params()\n\napplication_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params\n)\n\npokemon_name_1 = 'Bulbasaur'\npokemon_name_2 = 'Charmander'\npokemon_name_3 = 'Squirtle'\n\npokemon_type_1 = 'Grass'\npokemon_type_2 = 'Fire'\npokemon_type_3 = 'Water'\n\npokemon_description_1 = 'A grass pokemon'\npokemon_description_2 = 'A fire pokemon'\npokemon_description_3 = 'A water pokemon'\n\npokemon_ipfs_hash_1 = 'Qmc75zNUFoFFX3uPcjnUMqhvuzezHF9tTpgbf5pph2XegF'\npokemon_ipfs_hash_2 = 'QmP2M7nPDjhU9hPr8ManjzyFzBVEJDT3LKAAKC2o5f639q'\npokemon_ipfs_hash_3 = 'QmRbPCwbQ7vps64kPUHygCkSmW36FkCLbET9X7cEjtPHJV'\n\natc = AtomicTransactionComposer()\n\npokemon_info_coder = ABIType.from_string('(string,string,string,string,uint64)')\ntotal_bytes_1 = len(pokemon_info_coder.encode((pokemon_name_1, pokemon_type_1, pokemon_description_1, pokemon_ipfs_hash_1, 0)))\ntotal_bytes_2 = len(pokemon_info_coder.encode((pokemon_name_2, pokemon_type_2, pokemon_description_2, pokemon_ipfs_hash_2, 0)))\ntotal_bytes_3 = len(pokemon_info_coder.encode((pokemon_name_3, pokemon_type_3, pokemon_description_3, pokemon_ipfs_hash_3, 0)))\n\nbox_cost_1 = 2500 + (400 * total_bytes_1)\nbox_cost_2 = 2500 + (400 * total_bytes_2)\nbox_cost_3 = 2500 + (400 * total_bytes_3)\n\nmbr_fee_payment_tx_1 = PaymentTxn(\n    sender=address,\n    sp=params,\n    receiver=application_client.app_address,\n    amt=box_cost_1,\n    note='#1'\n)\nwrapped_payment_tx_1 = TransactionWithSigner(mbr_fee_payment_tx_1, signer)\n\nmbr_fee_payment_tx_2 = PaymentTxn(\n    sender=address,\n    sp=params,\n    receiver=application_client.app_address,\n    amt=box_cost_2,\n    note='#2'\n)\nwrapped_payment_tx_2 = TransactionWithSigner(mbr_fee_payment_tx_2, signer)\n\nmbr_fee_payment_tx_3 = PaymentTxn(\n    sender=address,\n    sp=params,\n    receiver=application_client.app_address,\n    amt=box_cost_3,\n    note='#3'\n)\nwrapped_payment_tx_3 = TransactionWithSigner(mbr_fee_payment_tx_3, signer)\n\nbox_ref_1 = (1).to_bytes(8, 'big')\nbox_ref_2 = (2).to_bytes(8, 'big')\nbox_ref_3 = (3).to_bytes(8, 'big')\n\napplication_client.compose_call(\n    atc, \n    call_abi_method='registerNewPokemonData', \n    pokemon_name=pokemon_name_1, \n    pokemon_type=pokemon_type_1,\n    pokemon_description=pokemon_description_1,\n    pokemon_ipfs_hash=pokemon_ipfs_hash_1,\n    payment_txn=wrapped_payment_tx_1,\n    transaction_parameters={\n        'boxes':[[app_id, box_ref_1]]\n    }\n)\n\napplication_client.compose_call(\n    atc, \n    call_abi_method='registerNewPokemonData', \n    pokemon_name=pokemon_name_2, \n    pokemon_type=pokemon_type_2,\n    pokemon_description=pokemon_description_2,\n    pokemon_ipfs_hash=pokemon_ipfs_hash_2,\n    payment_txn=wrapped_payment_tx_2,\n    transaction_parameters={\n        'boxes':[[app_id, box_ref_2]]\n    }\n)\n\napplication_client.compose_call(\n    atc, \n    call_abi_method='registerNewPokemonData', \n    pokemon_name=pokemon_name_3, \n    pokemon_type=pokemon_type_3,\n    pokemon_description=pokemon_description_3,\n    pokemon_ipfs_hash=pokemon_ipfs_hash_3,\n    payment_txn=wrapped_payment_tx_3,\n    transaction_parameters={\n        'boxes':[[app_id, box_ref_3]]\n    }\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\nprint(tx_ids)\nprint(abi_results)</code></pre>\n\n<h2>Determining the User's Pokemon</h2>\n<pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algokit_utils import ApplicationClient\nfrom algosdk.atomic_transaction_composer import AtomicTransactionComposer, AccountTransactionSigner, TransactionWithSigner\nfrom algosdk.transaction import PaymentTxn\nfrom algosdk.account import address_from_private_key\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nfrom algosdk.encoding import decode_address\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\n\nprivate_key = os.getenv('private_key')\n\nalgod_client = AlgodClient(node_token, node_server)\napp_spec = Path(__file__).parent / './arc69NFTmodifier.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key=private_key)\naddress = address_from_private_key(private_key=private_key)\nparams = algod_client.suggested_params()\n\napplication_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params\n)\n\n\natc = AtomicTransactionComposer()\n\nmbr_fee_payment_tx_1 = PaymentTxn(\n    sender=address,\n    sp=params,\n    receiver=application_client.app_address,\n    amt=18_500,\n    note='#1'\n)\nwrapped_payment_tx_1 = TransactionWithSigner(mbr_fee_payment_tx_1, signer)\n\n\nbox_ref_1 = decode_address(address)\n\n\napplication_client.compose_call(\n    atc, \n    call_abi_method='determineUserPokemon', \n    payment_txn=wrapped_payment_tx_1,\n    transaction_parameters={\n        'boxes':[[app_id, box_ref_1]]\n    }\n)\n\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\nprint(tx_ids)\nprint(abi_results)</pre></code>\n\n\n        <h2>Confirming Existence of Pokemon Info in Contract</h2>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nimport os\nfrom base64 import b64decode\nfrom algosdk.abi import ABIType\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\napp_id = int(os.getenv('app_id'))\napp_boxes = algod_client.application_boxes(app_id)['boxes']\n\npokemon_info_coder = ABIType.from_string('(string,string,string,string)')\n\nfor box in app_boxes:\n    box_name = b64decode(box['name'])\n    if len(box_name) == 8: #This is a pokemon info box \n        box_value = algod_client.application_box_by_name(app_id, box_name)['value']\n        decoded_box_value = pokemon_info_coder.decode(b64decode(box_value))\n        print(decoded_box_value)\n        </code></pre>\n\n        <h2>Confirming Pokemon Selected for the User</h2>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nimport os\nfrom base64 import b64decode\nfrom algosdk.abi import ABIType\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\napp_id = int(os.getenv('app_id'))\napp_boxes = algod_client.application_boxes(app_id)['boxes']\n\npokemon_info_coder = ABIType.from_string('(uint64)')\n\nfor box in app_boxes:\n    box_name = b64decode(box['name'])\n    if len(box_name) == 32: #This is the users selected pokemon ready to claim\n                            #contains only the pokemon #, eg; pokemon #1, pokemon #2, or pokemon #3 \n        box_value = algod_client.application_box_by_name(app_id, box_name)['value']\n        decoded_box_value = pokemon_info_coder.decode(b64decode(box_value))\n        print(decoded_box_value)\n        </code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 33,
    "language": "Python",
    "title": "ARC69 Minter and Modifier Part 2",
    "content": "\n        <h2>Video Tutorial</h2>\n        <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n            <iframe\n                class=\"absolute top-0 left-0 w-full h-full border-0\"\n                src=\"https://www.youtube.com/embed/kwMR_0300Og\"\n                frameborder=\"0\"\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                allowfullscreen>\n            </iframe>\n        </div>\n\n        <h2>Contract - User Mints and Claims Pokemon</h2>\n        <p>Compile the contract using:</p>\n        <pre class=\"overflow-auto shadow-md\"><code>algokit compile arc69NFTmodifier.py</code></pre>\n\n        <h3>Python Code</h3>\n        <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, itxn, Global, GlobalState, UInt64, gtxn, Bytes, subroutine, String, BoxRef, Txn, op, LocalState, Account\nfrom algopy.arc4 import abimethod, Struct, Address, Bool\nfrom algopy.arc4 import UInt64 as arc4UInt64\nfrom algopy.arc4 import String as arc4String\n\nclass availablePokemon(Struct):\n    pokemon_name: arc4String\n    pokemon_type: arc4String\n    pokemon_description: arc4String\n    pokemon_ipfs_hash: arc4String\n\nclass userPokemonInfo(Struct):\n    uid: arc4UInt64\n    owner: Address\n    asset_id: arc4UInt64\n    pokemon_id: arc4UInt64\n    level: arc4UInt64\n    exp: arc4UInt64\n    training: Bool\n    training_start_time: arc4UInt64\n\nclass arc69NFTmodifier(ARC4Contract):\n    def __init__(self) -> None:\n        self.pokemonUnitCounter = GlobalState(arc4UInt64(0))\n        self.pokemonCreated = GlobalState(arc4UInt64(0))\n        \n    @subroutine\n    def itoa(self, i: UInt64) -> Bytes:\n        digits = Bytes(b\"0123456789\")\n        radix = digits.length\n        if i < radix:\n            return digits[i]\n        return self.itoa(i // radix) + digits[i % radix]\n        \n    @abimethod\n    def registerNewPokemonData(\n        self,\n        pokemon_name: arc4String,\n        pokemon_type: arc4String,\n        pokemon_description: arc4String,\n        pokemon_ipfs_hash: arc4String,\n        payment_txn: gtxn.PaymentTransaction,\n    ) -> arc4String:\n        \n        assert payment_txn.receiver == Global.current_application_address\n        self.pokemonUnitCounter.value = arc4UInt64(self.pokemonUnitCounter.value.native + 1)\n        \n        box_ref = BoxRef(key=self.pokemonUnitCounter.value.bytes)\n        value, exists = box_ref.maybe()\n        assert not exists\n        \n        new_pokemon_info = availablePokemon(\n            pokemon_name=pokemon_name,\n            pokemon_type=pokemon_type,\n            pokemon_description=pokemon_description,\n            pokemon_ipfs_hash=pokemon_ipfs_hash\n        )\n        \n        box_ref.create(size=new_pokemon_info.bytes.length)\n        box_ref.put(new_pokemon_info.bytes)\n        \n        return arc4String('Pokemon Registered to Contract: ') + pokemon_name\n    </code></pre>\n\n        <h3>Confirming User Mint</h3>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algokit_utils import ApplicationClient\nfrom algosdk.atomic_transaction_composer import AtomicTransactionComposer, AccountTransactionSigner, TransactionWithSigner\nfrom algosdk.transaction import PaymentTxn\nfrom algosdk.account import address_from_private_key\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nfrom algosdk.encoding import decode_address\nfrom dotenv import load_dotenv\nfrom base64 import b64decode\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\nprivate_key = os.getenv('private_key')\n\nalgod_client = AlgodClient(node_token, node_server)\napp_spec = Path(__file__).parent / './arc69NFTmodifier.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key=private_key)\naddress = address_from_private_key(private_key=private_key)\nparams = algod_client.suggested_params()\n\napplication_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params\n)\n\natc = AtomicTransactionComposer()\n\ndecoded_address = decode_address(address)\npokemon_selected_box_name = decoded_address\n\nuint64_coder = ABIType.from_string('(uint64)')\nuser_pokemon_selected = algod_client.application_box_by_name(app_id, pokemon_selected_box_name)['value']\nb64_decoded_value = b64decode(user_pokemon_selected)\n\nglobal_states = algod_client.application_info(app_id)['params']['global-state']\nfor key in global_states:\n    if b64decode(key['key']) == b'pokemonCreated':\n        current_uid = b64decode(key['value']['bytes'])\n\ntotal_bytes = (7 * 8) + (32 * 2) + 1\nbox_cost = (total_bytes * 400) + 2500 + 102_000\n\nmbr_fee_payment_tx_1 = PaymentTxn(\n    sender=address,\n    sp=params,\n    receiver=application_client.app_address,\n    amt=box_cost,\n    note='#1'\n)\nwrapped_payment_tx_1 = TransactionWithSigner(mbr_fee_payment_tx_1, signer)\n\nbox_ref_1 = b64_decoded_value              # The pokemon selected #1 , #2, or #3\nbox_ref_2 = decoded_address                # The users address decoded\nbox_ref_3 = current_uid + decoded_address  # The next unique ID counter + the users address\n\napplication_client.compose_call(\n    atc, \n    call_abi_method='mintUserPokemon', \n    payment_txn=wrapped_payment_tx_1,\n    transaction_parameters={\n        'boxes':[[app_id, box_ref_1], [app_id, box_ref_2], [app_id, box_ref_3]]\n    }\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\nprint(tx_ids)\nprint(abi_results)</code></pre>\n\n        <h3>Confirming User Claim</h3>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algokit_utils import ApplicationClient\nfrom algosdk.atomic_transaction_composer import AtomicTransactionComposer, AccountTransactionSigner, TransactionWithSigner\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.account import address_from_private_key\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nfrom algosdk.encoding import decode_address\nfrom dotenv import load_dotenv\nfrom base64 import b64decode\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\n\nprivate_key = os.getenv('private_key')\n\nalgod_client = AlgodClient(node_token, node_server)\napp_spec = Path(__file__).parent / './arc69NFTmodifier.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key=private_key)\naddress = address_from_private_key(private_key=private_key)\nparams = algod_client.suggested_params()\n\napplication_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params\n)\n\natc = AtomicTransactionComposer()\n\ndecoded_address = decode_address(address)\n\nmbr_fee_payment_tx_1 = PaymentTxn(\n    sender=address,\n    sp=params,\n    receiver=application_client.app_address,\n    amt=2000,\n    note='#1'\n)\nwrapped_payment_tx_1 = TransactionWithSigner(mbr_fee_payment_tx_1, signer)\natc.add_transaction(wrapped_payment_tx_1)\n\nusers_pokemon = 728462064\n\nuser_optin_tx = AssetTransferTxn(\n    sender=address,\n    receiver=address,\n    sp=params,\n    amt=0,\n    index=users_pokemon\n)\n\nwrapped_user_optin_tx = TransactionWithSigner(user_optin_tx, signer)\n\ncurrent_uid = (0).to_bytes(8, 'big')\nbox_ref_1 = current_uid + decoded_address\n\napplication_client.compose_call(\n    atc, \n    call_abi_method='claimPokemon', \n    opt_in_txn=wrapped_user_optin_tx,\n    uid=0,\n    transaction_parameters={\n        'boxes':[[app_id, box_ref_1]],\n        'foreign_assets': [users_pokemon]\n    }\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\nprint(tx_ids)\nprint(abi_results)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 34,
    "language": "Python",
    "title": "ARC69 Minter and Modifier Part 3",
    "content": "\n        <h2>Video Tutorial</h2>\n        <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n            <iframe\n                class=\"absolute top-0 left-0 w-full h-full border-0\"\n                src=\"https://www.youtube.com/embed/kwMR_0300Og\"\n                frameborder=\"0\"\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                allowfullscreen>\n            </iframe>\n        </div>\n\n        <h2>Contract - User Sends Pokemon To Training (Stakes) and Removes from Training (Unstakes)</h2>\n        <p>Compile the contract using:</p>\n        <pre class=\"overflow-auto shadow-md\"><code>algokit compile arc69NFTmodifier.py</code></pre>\n        <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, itxn, Global, GlobalState, UInt64, gtxn, Bytes, subroutine, String, BoxRef, Txn, op, LocalState, Account\nfrom algopy.arc4 import abimethod, Struct, Address, Bool\nfrom algopy.arc4 import UInt64 as arc4UInt64\nfrom algopy.arc4 import String as arc4String\n\nclass availablePokemon(Struct):\n    pokemon_name: arc4String\n    pokemon_type: arc4String\n    pokemon_description: arc4String\n    pokemon_ipfs_hash: arc4String\n    \nclass userPokemonInfo(Struct):\n    uid: arc4UInt64\n    owner: Address\n    asset_id: arc4UInt64\n    pokemon_id: arc4UInt64\n    level: arc4UInt64\n    exp: arc4UInt64\n    training: Bool\n    training_start_time: arc4UInt64\n\nclass arc69NFTmodifier(ARC4Contract):\n    def __init__(self) -> None:\n        self.pokemonUnitCounter = GlobalState(arc4UInt64(0))\n        self.pokemonCreated = GlobalState(arc4UInt64(0))\n        \n    @subroutine\n    def itoa(self, i: UInt64) -> Bytes:\n        digits = Bytes(b\"0123456789\")\n        radix = digits.length\n        if i < radix:\n            return digits[i]\n        return self.itoa(i // radix) + digits[i % radix]      \n    \n    @abimethod\n    def registerNewPokemonData(\n        self,\n        pokemon_name: arc4String,\n        pokemon_type: arc4String,\n        pokemon_description: arc4String,\n        pokemon_ipfs_hash: arc4String,\n        payment_txn: gtxn.PaymentTransaction,\n    ) -> arc4String:        \n        \n       # assert payment_txn.amount\n        assert payment_txn.receiver == Global.current_application_address\n        \n        self.pokemonUnitCounter.value = arc4UInt64(self.pokemonUnitCounter.value.native + 1)\n        \n        box_ref = BoxRef(key=self.pokemonUnitCounter.value.bytes)\n        value, exists = box_ref.maybe()\n        assert not exists\n        \n        new_pokemon_info = availablePokemon(\n            pokemon_name=pokemon_name,\n            pokemon_type=pokemon_type,\n            pokemon_description=pokemon_description,\n            pokemon_ipfs_hash=pokemon_ipfs_hash\n        )\n        \n        box_ref.create(size=new_pokemon_info.bytes.length)\n        box_ref.put(new_pokemon_info.bytes)\n        \n        \n        return arc4String('Pokemon Registered to Contract: ') + pokemon_name    \n    \n    @abimethod\n    def determineUserPokemon(\n        self,\n        payment_txn: gtxn.PaymentTransaction\n    ) -> tuple[arc4String, arc4UInt64]:\n        \n        assert payment_txn.amount == 18_500\n        assert payment_txn.receiver == Global.current_application_address\n        \n        randomizer = arc4UInt64(\n            Global.latest_timestamp + Global.round + arc4UInt64.from_bytes(Txn.tx_id[0:8]).native % arc4UInt64.from_bytes(Txn.tx_id[-8:]).native\n        )\n        \n        hashed_randomizer = op.sha256(randomizer.bytes)\n        \n        pokemon_selection = arc4UInt64((arc4UInt64.from_bytes(hashed_randomizer[0:8]).native % self.pokemonUnitCounter.value.native) + 1)\n        \n        users_claim_box = BoxRef(key=Txn.sender.bytes)\n        value, exists = users_claim_box.maybe()\n        assert not exists\n        \n        users_claim_box.create(size=8)\n        users_claim_box.put(pokemon_selection.bytes)\n        \n        return arc4String('Users Pokemon # Selected:'), pokemon_selection\n        \n    @abimethod()\n    def mintUserPokemon(\n        self,\n        payment_txn: gtxn.PaymentTransaction\n    ) -> tuple[arc4String, UInt64]:\n\n        assert payment_txn.amount >= 152900\n        assert payment_txn.receiver == Global.current_application_address\n        \n        users_claim_box = BoxRef(key=Txn.sender.bytes)\n        claim_box_value, exists = users_claim_box.maybe()\n        assert exists\n        \n        pokemon_selection = arc4UInt64.from_bytes(claim_box_value)\n        \n        pokemon_info_bytes = BoxRef(key=pokemon_selection.bytes)\n        pokemon_info_value, exists = pokemon_info_bytes.maybe()\n        assert exists\n        \n        available_pokemon_info = availablePokemon.from_bytes(pokemon_info_value)\n        unit_name_int_as_string = String.from_bytes(self.itoa(pokemon_selection.native))\n        \n        uid_as_string = String.from_bytes(self.itoa(self.pokemonCreated.value.native))        \n        \n        pokemon_creation_tx = itxn.AssetConfig(\n            total=1,\n            manager=Global.current_application_address,\n            asset_name=available_pokemon_info.pokemon_name.native,\n            unit_name='PK#' + unit_name_int_as_string,\n            decimals=0,\n            url= 'https://gateway.pinata.cloud/ipfs/' + available_pokemon_info.pokemon_ipfs_hash.native,\n            note = (\n                '{\"standard\": \"arc69\", \"mime_type\": \"image/png\", \"properties\": {'\n                '\"Type\": \"' + available_pokemon_info.pokemon_type.native + '\", '\n                '\"Description\": \"' + available_pokemon_info.pokemon_description.native + '\", '\n                '\"Level\": \"1\", '\n                '\"Experience\": \"0\", '\n                '\"Pokemon Number\": \"' + unit_name_int_as_string + '\", '\n                '\"UID\": \"' + uid_as_string + '\" }}' \n            ),\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        \n        user_pokemon_box = BoxRef(key=self.pokemonCreated.value.bytes + Txn.sender.bytes)\n        user_pokemon_box_value, exists = user_pokemon_box.maybe()\n        assert not exists\n        \n        new_user_pokemon_info = userPokemonInfo(\n            uid=self.pokemonCreated.value,\n            owner=Address(Txn.sender),\n            asset_id=arc4UInt64(pokemon_creation_tx.created_asset.id),\n            pokemon_id=pokemon_selection,\n            level=arc4UInt64(1),\n            exp=arc4UInt64(0),\n            training=Bool(False),\n            training_start_time=arc4UInt64(0),\n        )\n        \n        \n        user_pokemon_box.create(size=new_user_pokemon_info.bytes.length)\n        user_pokemon_box.put(new_user_pokemon_info.bytes)\n        \n        users_claim_box.delete()\n        \n        self.pokemonCreated.value = arc4UInt64(self.pokemonCreated.value.native + 1)\n        \n        return arc4String('User pokemon generated, asset ID: '), pokemon_creation_tx.created_asset.id\n        \n        \n    @abimethod\n    def claimPokemon(\n        self,\n        opt_in_txn: gtxn.AssetTransferTransaction,\n        uid: arc4UInt64\n    ) -> String:\n        \n        user_pokemon_box = BoxRef(key=uid.bytes + Txn.sender.bytes)\n        user_pokemon_box_value, exists = user_pokemon_box.maybe()\n        \n        assert exists\n        \n        users_pokemon_info = userPokemonInfo.from_bytes(user_pokemon_box_value)\n        \n        #assert users_pokemon_info.owner == Address(Txn.sender)\n        #assert opt_in_txn.xfer_asset.id == users_pokemon_info.asset_id\n        \n        itxn.AssetTransfer(\n            asset_receiver=Txn.sender,\n            xfer_asset=users_pokemon_info.asset_id.native,\n            fee=Global.min_txn_fee,\n            asset_amount=1\n        ).submit()        \n        \n        return String('User received their pokemon')       \n                \n    @abimethod\n    def trainPokemon(\n        self,\n        stake_pokemon_tx: gtxn.AssetTransferTransaction,\n        uid: arc4UInt64\n    ) -> String:\n        \n        assert stake_pokemon_tx.asset_amount == 1\n        assert stake_pokemon_tx.asset_receiver == Global.current_application_address\n        \n        pokemon_to_train = stake_pokemon_tx.xfer_asset.id\n        \n        users_pokemon_info = BoxRef(key=uid.bytes + Txn.sender.bytes)\n        value, exists = users_pokemon_info.maybe()\n        assert exists\n        \n        current_pokemon_info = userPokemonInfo.from_bytes(value)\n        assert pokemon_to_train == current_pokemon_info.asset_id\n        \n        current_pokemon_info.training_start_time = arc4UInt64(Global.latest_timestamp)\n        current_pokemon_info.training = Bool(True)\n        \n        users_pokemon_info.put(current_pokemon_info.bytes)\n    \n        return String(\"Pokemon Staked\")\n        \n        \n    @abimethod\n    def removePokemonFromTraining(\n        self,\n        pokemon_requested_uid: arc4UInt64\n    ) -> String:\n        \n        users_pokemon_info_box = BoxRef(key=pokemon_requested_uid.bytes + Txn.sender.bytes)\n        users_pokemon_info_value, exists = users_pokemon_info_box.maybe()\n        assert exists\n        \n        current_users_pokemon_info = userPokemonInfo.from_bytes(users_pokemon_info_value)\n        \n        general_pokemon_info_box = BoxRef(key=current_users_pokemon_info.pokemon_id.bytes)\n        general_pokemon_info_value, exists = general_pokemon_info_box.maybe()\n        \n        general_pokemon_info = availablePokemon.from_bytes(general_pokemon_info_value)\n\n\n        unit_name_as_string = String.from_bytes(self.itoa(current_users_pokemon_info.pokemon_id.native))\n        \n        initial_training_time = current_users_pokemon_info.training_start_time.native\n        current_time = Global.latest_timestamp\n        time_difference = current_time - initial_training_time\n        \n        current_level = current_users_pokemon_info.level.native\n        current_experience = current_users_pokemon_info.exp.native\n        \n        base_experience = UInt64(200)\n        cumulative_experience = current_level * base_experience\n        \n        total_experience = current_experience + time_difference\n        \n        if total_experience >= cumulative_experience:\n            levels_gained = (total_experience + base_experience - cumulative_experience) // base_experience\n            \n            new_level = current_level + levels_gained\n            new_experience = total_experience - ((new_level - 1) * base_experience)\n            \n        else:\n            new_level = current_level\n            new_experience = total_experience\n            \n            \n        new_level_string = String.from_bytes(self.itoa(new_level))\n        new_experience_string = String.from_bytes(self.itoa(new_experience))\n\n        uid_as_string = String.from_bytes(self.itoa(current_users_pokemon_info.uid.native))\n        \n        itxn.AssetConfig(\n            sender=Global.current_application_address,\n            manager=Global.current_application_address,\n            config_asset=current_users_pokemon_info.asset_id.native,\n            note = (\n                '{\"standard\": \"arc69\", \"mime_type\": \"image/png\", \"properties\": {'\n                '\"Type\": \"' + general_pokemon_info.pokemon_type.native + '\", '\n                '\"Description\": \"' + general_pokemon_info.pokemon_description.native + '\", '\n                '\"Level\": \"' + new_level_string + '\", '\n                '\"Experience\": \"' + new_experience_string + '\", '\n                '\"Pokemon Number\": \"' + unit_name_as_string + '\", '\n                '\"UID\": \"' + uid_as_string + '\" }}' \n            ),\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        itxn.AssetTransfer(\n            asset_receiver=Txn.sender,\n            asset_amount=1,\n            xfer_asset=current_users_pokemon_info.asset_id.native,\n            fee=Global.min_txn_fee\n        ).submit()\n        \n        \n        new_users_pokemon_info = current_users_pokemon_info.copy()\n        new_users_pokemon_info.level = arc4UInt64(new_level)\n        new_users_pokemon_info.exp = arc4UInt64(new_experience)\n        new_users_pokemon_info.training = Bool(False)\n\n        users_pokemon_info_box.put(new_users_pokemon_info.bytes)\n        \n        return String('Pokemon Removed from Stake')</code></pre>\n\n        <h3>Seeing the Current Status of the User's Pokemon</h3>\n        <p>Note: The UID in the metadata and the user's address is the box name</p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nimport os\nfrom base64 import b64decode\nfrom algosdk.abi import ABIType\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\napp_id = int(os.getenv('app_id'))\napp_boxes = algod_client.application_boxes(app_id)['boxes']\n\npokemon_info_coder = ABIType.from_string('(uint64,address,uint64,uint64,uint64,uint64,bool,uint64)')\n\nfor box in app_boxes:\n    box_name = b64decode(box['name'])\n    if len(box_name) == 40: #This is user specific pokemon information (box name is uid for pokemon [8 bytes] + user address [32 bytes])\n        box_value = algod_client.application_box_by_name(app_id, )['value']\n        decoded_box_value = pokemon_info_coder.decode(b64decode(box_value))\n        print(decoded_box_value)</code></pre>\n\n        <h2>Executing in Python</h2>\n\n        <h2>The Pokemon Level-up System</h2>\n        <p>Note: Experience and level gain are calculated based on time staked, with each second providing an additional experience point.</p>\n        <pre class=\"overflow-auto shadow-md\"><code>initial_training_time = current_users_pokemon_info.training_start_time.native\ncurrent_time = Global.latest_timestamp\ntime_difference = current_time - initial_training_time\n\ncurrent_level = current_users_pokemon_info.level.native\ncurrent_experience = current_users_pokemon_info.exp.native\n\nbase_experience = UInt64(200)\ncumulative_experience = current_level * base_experience\n\ntotal_experience = current_experience + time_difference\n\nif total_experience >= cumulative_experience:\n    levels_gained = (total_experience + base_experience - cumulative_experience) // base_experience\n    \n    new_level = current_level + levels_gained\n    new_experience = total_experience - ((new_level - 1) * base_experience)\n    \nelse:\n    new_level = current_level\n    new_experience = total_experience</code></pre>\n\n        <h3>Staking the Pokemon</h3>\n       \n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algokit_utils import ApplicationClient\nfrom algosdk.atomic_transaction_composer import AtomicTransactionComposer, AccountTransactionSigner, TransactionWithSigner\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.account import address_from_private_key\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nfrom algosdk.encoding import decode_address\nfrom dotenv import load_dotenv\nfrom base64 import b64decode\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\n\nprivate_key = os.getenv('private_key')\n\nalgod_client = AlgodClient(node_token, node_server)\napp_spec = Path(__file__).parent / './arc69NFTmodifier.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key=private_key)\naddress = address_from_private_key(private_key=private_key)\nparams = algod_client.suggested_params()\n\napplication_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params\n)\n\natc = AtomicTransactionComposer()\n\ndecoded_address = decode_address(address)\n\nusers_pokemon = 728462064\n\nstake_pokemon_tx = AssetTransferTxn(\n    sender=address,\n    receiver=application_client.app_address,\n    sp=params,\n    amt=1,\n    index=users_pokemon\n)\n\nwrapped_stake_tx = TransactionWithSigner(stake_pokemon_tx, signer)\n\ncurrent_uid = (0).to_bytes(8, 'big')\nbox_ref_1 = current_uid + decoded_address\n\napplication_client.compose_call(\n    atc, \n    call_abi_method='trainPokemon', \n    stake_pokemon_tx=wrapped_stake_tx,\n    uid=0,\n    transaction_parameters={\n        'boxes':[[app_id, box_ref_1]],\n        'foreign_assets': [users_pokemon]\n    }\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\nprint(tx_ids)\nprint(abi_results)</code></pre>\n\n        <h3>Unstaking the Pokemon</h3>\n      \n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.v2client.algod import AlgodClient\nfrom algokit_utils import ApplicationClient\nfrom algosdk.atomic_transaction_composer import AtomicTransactionComposer, AccountTransactionSigner, TransactionWithSigner\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.account import address_from_private_key\nfrom pathlib import Path\nfrom algosdk.abi import ABIType\nfrom algosdk.encoding import decode_address\nfrom dotenv import load_dotenv\nfrom base64 import b64decode\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\n\nprivate_key = os.getenv('private_key')\n\nalgod_client = AlgodClient(node_token, node_server)\napp_spec = Path(__file__).parent / './arc69NFTmodifier.arc32.json'\napp_id = int(os.getenv('app_id'))\nsigner = AccountTransactionSigner(private_key=private_key)\naddress = address_from_private_key(private_key=private_key)\nparams = algod_client.suggested_params()\n\napplication_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=app_spec,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params\n)\n\natc = AtomicTransactionComposer()\n\ndecoded_address = decode_address(address)\n\nmbr_fee_payment_tx_1 = PaymentTxn(\n    sender=address,\n    sp=params,\n    receiver=application_client.app_address,\n    amt=3000,\n    note='#1'\n)\nwrapped_payment_tx_1 = TransactionWithSigner(mbr_fee_payment_tx_1, signer)\natc.add_transaction(wrapped_payment_tx_1)\n\nusers_pokemon = 728462064\n\nstake_pokemon_tx = AssetTransferTxn(\n    sender=address,\n    receiver=application_client.app_address,\n    sp=params,\n    amt=1,\n    index=users_pokemon\n)\n\nwrapped_stake_tx = TransactionWithSigner(stake_pokemon_tx, signer)\n\ncurrent_uid = (0).to_bytes(8, 'big')\nbox_ref_1 = current_uid + decoded_address\nbox_ref_2 = (3).to_bytes(8, 'big')\n\napplication_client.compose_call(\n    atc, \n    call_abi_method='removePokemonFromTraining', \n    pokemon_requested_uid=0,\n    transaction_parameters={\n        'boxes':[[app_id, box_ref_1], [app_id, box_ref_2]],\n        'foreign_assets': [users_pokemon]\n    }\n)\n\nresults = atc.execute(algod_client, 2)\n\ntx_ids = [results.tx_ids[i] for i in range(len(results.tx_ids))]\nabi_results = [results.abi_results[i].return_value for i in range(len(results.abi_results))]\nprint(tx_ids)\nprint(abi_results)</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 35,
    "language": "Python",
    "title": "Transaction Comprehension",
    "content": "\n        <h2>Video Tutorial</h2>\n        <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n            <iframe\n                class=\"absolute top-0 left-0 w-full h-full border-0\"\n                src=\"https://www.youtube.com/embed/jeHALmgfB7w\"\n                frameborder=\"0\"\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                allowfullscreen>\n            </iframe>\n        </div>\n\n        <h2>Compiling Contracts</h2>\n        <p>Compile contracts with:</p>\n        <pre class=\"overflow-auto shadow-md\"><code>algokit compile py filename.py</code></pre>\n\n        <h3>Generate Two Accounts</h3>\n        <p>Create two accounts and add their private keys to your <code>.env</code> file.</p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(address)</code></pre>\n\n        <h3>Generate One Asset</h3>\n        <p>Create one asset and place its ID in your <code>.env</code> file.</p>\n        <p><em>Note: Remember the account that owns the asset, as it will be used for asset transfers later.</em></p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.transaction import AssetCreateTxn, wait_for_confirmation\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\nparams = algod_client.suggested_params()\n\nasset_create_txn = AssetCreateTxn(\n    sender=address,\n    sp=params,\n    total=10,\n    decimals=0,\n    default_frozen=False,\n    manager=address,\n    reserve=address,\n    asset_name = 'Test Asset One',\n    unit_name= 'TEST#1',\n)\n\nsigned_asset_create_txn = asset_create_txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_asset_create_txn)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\ntx_info = algod_client.pending_transaction_info(tx_id)\nprint(tx_info)</code></pre>\n\n        <h2>Launching Contracts</h2>\n        <p><em>Note: Adjust approval and clear teal filenames, as well as global/local states, as needed.</em></p>\n        <p>In this tutorial, we use a second contract, <code>SecondApp</code>, which has 1 local state <code>uint</code>.</p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.transaction import ApplicationCreateTxn, StateSchema, OnComplete, wait_for_confirmation, PaymentTxn\nfrom algosdk.account import address_from_private_key\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk import logic\nfrom dotenv import load_dotenv\nimport base64\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\nalgod_client = AlgodClient(node_token, node_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\napproval_teal_file_name = 'TransactionComp.approval.teal'\nclear_teal_file_name = 'TransactionComp.clear.teal'\n\nwith open(f'./{approval_teal_file_name}', 'r') as f:\n    approval_teal_source = f.read()\n\nwith open(f'{clear_teal_file_name}', 'r') as f:\n    clear_teal_source = f.read()\n\napproval_result = algod_client.compile(approval_teal_source)\napproval_program = base64.b64decode(approval_result['result'])\n\nclear_result = algod_client.compile(clear_teal_source)\nclear_program = base64.b64decode(clear_result['result'])\n\nglobal_schema = StateSchema(num_uints=0, num_byte_slices=0)\nlocal_schema = StateSchema(num_uints=0, num_byte_slices=0)\n\ntxn = ApplicationCreateTxn(\n    sender = address,\n    sp = params,\n    on_complete=OnComplete.NoOpOC,\n    approval_program=approval_program,\n    clear_program=clear_program,\n    global_schema=global_schema,\n    local_schema=local_schema,\n)\nsigned_txn = txn.sign(private_key)\n\ntry:\n    txid = algod_client.send_transaction(signed_txn)\nexcept Exception as e:\n    print(e)\n    \nprint(f'Tx ID: {txid}')\nwait_for_confirmation(algod_client, txid)\ntx_info = algod_client.pending_transaction_info(txid)\nprint(f'App ID: {tx_info['application-index']}')\n\napp_address = logic.get_application_address(tx_info['application-index'])\nprint(f'Application Address: {app_address}')\n\n\nactivate_contract = PaymentTxn(\n    sender = address,\n    sp = params,\n    receiver = app_address,\n    amt = 100_000\n)\n\nsigned_activation = activate_contract.sign(private_key)\nactivation_tx = algod_client.send_transaction(signed_activation)\nprint(f'MBR For Contract to be Active Account Funded: {activation_tx}')\n</code></pre>\n\n        <h3>Transaction Comprehension (TXN)</h3>\n        <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, Txn, Bytes, String\nfrom algopy.arc4 import abimethod, Address\nfrom algopy.arc4 import UInt64 as arc4UInt64\n\nclass TransactionComp(ARC4Contract):\n    def __init__(self) -> None:\n        pass\n    \n    @abimethod\n    def txn_comprehension(self) -> tuple[Address, Address, Bytes, arc4UInt64, arc4UInt64, String, String, arc4UInt64, Address, arc4UInt64, String, Address]:\n        sender = Address(Txn.sender)\n        foreign_accounts = Address(Txn.accounts(1))\n        app_arg_1 = Txn.application_args(0)\n        txn_foreign_applications = Txn.applications(0)\n        txn_foreign_application_id = arc4UInt64(txn_foreign_applications.id)\n        foreign_asset_1 = Txn.assets(0)\n        foreign_asset_id = arc4UInt64(foreign_asset_1.id)\n        foreign_asset_name = String.from_bytes(foreign_asset_1.name)\n        foreign_asset_unit_name = String.from_bytes(foreign_asset_1.unit_name)\n        sender_foreign_asset_balance = arc4UInt64(foreign_asset_1.balance(Txn.sender))\n        foreign_asset_creator_address = Address(foreign_asset_1.creator)\n        fee_for_this_transaction = arc4UInt64(Txn.fee)\n        transaction_type = String.from_bytes(Txn.type)\n        transaction_id = Address(Txn.tx_id)\n        return sender, foreign_accounts, app_arg_1, txn_foreign_application_id, foreign_asset_id, foreign_asset_name, foreign_asset_unit_name, sender_foreign_asset_balance, foreign_asset_creator_address, fee_for_this_transaction, transaction_type, transaction_id\n        \n</code></pre>\n        <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, AtomicTransactionComposer, TransactionWithSigner\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.account import address_from_private_key\nfrom pathlib import Path\nimport os\nfrom algosdk.util import algos_to_microalgos\nfrom algosdk.abi import ABIType\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\npath = Path(__file__).parent / './TransactionComp.arc32.json'\napp_id = int(os.getenv('app_id'))\nprivate_key = os.getenv('private_key')\nsigner = AccountTransactionSigner(private_key)\naddress = address_from_private_key(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=path,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\nasset_id = 723609532\n\narbitrary_account = 'MXOT5NO6DVCGIS22AWEP7N5WD72RSV6QJG4OWGDOTEH3DQKCG4R4WLLMR4'\n\napp_client.compose_call(atc, call_abi_method='txn_comprehension', transaction_parameters={'accounts': [arbitrary_account], 'foreign_assets': [asset_id]})\n\nresult = atc.execute(algod_client, 2)\n\nall_tx_ids = [result.abi_results[i].tx_id for i in range(len(result.abi_results))]\nall_abi_results = [result.abi_results[i].return_value for i in range(len(result.abi_results))]\n\nprint(all_tx_ids)\nprint(all_abi_results)\n</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 36,
    "language": "Python",
    "title": "Inner Transaction Comprehension",
    "content": "\n        <h2>Video Tutorial</h2>\n        <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n            <iframe\n                class=\"absolute top-0 left-0 w-full h-full border-0\"\n                src=\"https://www.youtube.com/embed/IRhE9E53Qhc\"\n                frameborder=\"0\"\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                allowfullscreen>\n            </iframe>\n        </div>\n\n        <h2>Compiling Contracts</h2>\n        <p>Compile contracts with:</p>\n        <pre class=\"overflow-auto shadow-md\"><code>algokit compile py filename.py</code></pre>\n\n        <h3>Generate Two Accounts</h3>\n        <p>Create two accounts and add their private keys to your <code>.env</code> file.</p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\nprivate_key, address = generate_account()\nprint(address)</code></pre>\n\n        <h3>Generate One Asset</h3>\n        <p>Create one asset and place its ID in your <code>.env</code> file.</p>\n        <p><em>Note: Remember the account that owns the asset, as it will be used for asset transfers later.</em></p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.transaction import AssetCreateTxn, wait_for_confirmation\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\nparams = algod_client.suggested_params()\n\nasset_create_txn = AssetCreateTxn(\n    sender=address,\n    sp=params,\n    total=10,\n    decimals=0,\n    default_frozen=False,\n    manager=address,\n    reserve=address,\n    asset_name = 'Test Asset One',\n    unit_name= 'TEST#1',\n)\n\nsigned_asset_create_txn = asset_create_txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_asset_create_txn)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\ntx_info = algod_client.pending_transaction_info(tx_id)\nprint(tx_info)</code></pre>\n\n        <h2>Launching Contracts</h2>\n        <p><em>Note: Adjust approval and clear teal filenames, as well as global/local states, as needed.</em></p>\n        <p>In this tutorial, we use a second contract, <code>SecondApp</code>, which has 1 local state <code>uint</code>.</p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.transaction import ApplicationCreateTxn, StateSchema, OnComplete, wait_for_confirmation, PaymentTxn\nfrom algosdk.account import address_from_private_key\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk import logic\nfrom dotenv import load_dotenv\nimport base64\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\nalgod_client = AlgodClient(node_token, node_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\napproval_teal_file_name = 'TransactionComp.approval.teal'\nclear_teal_file_name = 'TransactionComp.clear.teal'\n\nwith open(f'./{approval_teal_file_name}', 'r') as f:\n    approval_teal_source = f.read()\n\nwith open(f'{clear_teal_file_name}', 'r') as f:\n    clear_teal_source = f.read()\n\napproval_result = algod_client.compile(approval_teal_source)\napproval_program = base64.b64decode(approval_result['result'])\n\nclear_result = algod_client.compile(clear_teal_source)\nclear_program = base64.b64decode(clear_result['result'])\n\nglobal_schema = StateSchema(num_uints=0, num_byte_slices=0)\nlocal_schema = StateSchema(num_uints=0, num_byte_slices=0)\n\ntxn = ApplicationCreateTxn(\n    sender = address,\n    sp = params,\n    on_complete=OnComplete.NoOpOC,\n    approval_program=approval_program,\n    clear_program=clear_program,\n    global_schema=global_schema,\n    local_schema=local_schema,\n)\nsigned_txn = txn.sign(private_key)\n\ntry:\n    txid = algod_client.send_transaction(signed_txn)\nexcept Exception as e:\n    print(e)\n    \nprint(f'Tx ID: {txid}')\nwait_for_confirmation(algod_client, txid)\ntx_info = algod_client.pending_transaction_info(txid)\nprint(f'App ID: {tx_info['application-index']}')\n\napp_address = logic.get_application_address(tx_info['application-index'])\nprint(f'Application Address: {app_address}')\n\n\nactivate_contract = PaymentTxn(\n    sender = address,\n    sp = params,\n    receiver = app_address,\n    amt = 100_000\n)\n\nsigned_activation = activate_contract.sign(private_key)\nactivation_tx = algod_client.send_transaction(signed_activation)\nprint(f'MBR For Contract to be Active Account Funded: {activation_tx}')\n</code></pre>\n\n        <h3>Inner Transaction Comprehension (ITXN and abi_calls)</h3>\n        \n        <h4>Inner Txn with itxn Class</h4>\n        <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, UInt64, itxn, Global\nfrom algopy.arc4 import abimethod\n\nclass TransactionComp(ARC4Contract):\n    def __init__(self) -> None:\n        pass   \n\n    @abimethod\n    def inner_txn_comprehension(self) -> tuple[UInt64, UInt64, UInt64]:\n        asset_config_txn = itxn.AssetConfig(\n            total=1,\n            unit_name=\"TEST#1\",\n            asset_name=\"TEST ASSET ONE\",\n            decimals=0,\n            default_frozen=False,\n            manager=Global.current_application_address,\n            reserve=Global.current_application_address,\n            fee=Global.min_txn_fee,\n            ).submit()        \n        \n        asset_config_txn_2 = itxn.AssetConfig(\n            total=1,\n            unit_name=\"TEST#2\",\n            asset_name=\"TEST ASSET TWO\",\n            decimals=0,\n            default_frozen=False,\n            manager=Global.current_application_address,\n            reserve=Global.current_application_address,\n            fee=Global.min_txn_fee,\n            )        \n        \n        asset_config_txn_3 = itxn.AssetConfig(\n            total=1,\n            unit_name=\"TEST#3\",\n            asset_name=\"TEST ASSET THREE\",\n            decimals=0,\n            default_frozen=False,\n            manager=Global.current_application_address,\n            reserve=Global.current_application_address,\n            fee=Global.min_txn_fee,\n            )\n        \n        submit_tx_1, submit_tx_2 = itxn.submit_txns(asset_config_txn_2, asset_config_txn_3)        \n            \n        return asset_config_txn.created_asset.id, submit_tx_1.created_asset.id, submit_tx_2.created_asset.id</code></pre>\n        <pre class=\"overflow-auto shadow-md\"><code>interact_with_contract_2.py</code></pre>\n\n        <h4>Inner Txn with abi_call Class</h4>\n        <p><em>Note: Deploy a second application and place the generated app ID in the new inner transaction method, <code>inner_txn_two</code>.</em></p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, LocalState, Txn, UInt64, gtxn\nfrom algopy.arc4 import abimethod\n\nclass MySecondContract(ARC4Contract):\n    def __init__(self) -> None:\n        self.opted_in = LocalState(UInt64)        \n        \n    @abimethod()\n    def return_nothing(self) -> None:\n        pass        \n        \n    @abimethod(allow_actions=['OptIn'])\n    def local_state_return_something(self,\n                                     payment_txn: gtxn.PaymentTransaction) -> UInt64:\n        self.opted_in[Txn.sender] = UInt64(1)\n        return UInt64(1)</code></pre>\n        \n        <p>Replace the second App ID in the contract below, compile the contract, and include the new app in the <em>Foreign Assets Array</em>.</p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, UInt64, itxn, Global, OnCompleteAction\nfrom algopy.arc4 import abimethod, arc4_signature, abi_call\n\nclass TransactionComp(ARC4Contract):\n    def __init__(self) -> None:\n        pass    \n\n    @abimethod\n    def inner_txn_two(self) -> UInt64:\n        \n        method_signature = arc4_signature('return_nothing()void')\n        \n        itxn.ApplicationCall(\n            app_id=727594507,\n            app_args=(method_signature,),\n            on_completion=OnCompleteAction.NoOp,\n            fee=Global.min_txn_fee\n        ).submit()        \n        \n        result, txn = abi_call[UInt64](\n            'local_state_return_something',\n            app_id=727594507,\n            on_completion=OnCompleteAction.OptIn,\n            fee=Global.min_txn_fee\n        )\n        \n        txn = abi_call(\n            'return_nothing',\n            app_id=727594507,\n            fee=Global.min_txn_fee\n        )\n        \n        return result\n        \n</code></pre>\n        <pre class=\"overflow-auto shadow-md\"><code>from algokit_utils import ApplicationClient\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.atomic_transaction_composer import AccountTransactionSigner, AtomicTransactionComposer, TransactionWithSigner\nfrom algosdk.transaction import PaymentTxn, AssetTransferTxn\nfrom algosdk.account import address_from_private_key\nfrom pathlib import Path\nimport os\nfrom algosdk.util import algos_to_microalgos\nfrom algosdk.abi import ABIType\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\npath = Path(__file__).parent / './TransactionComp.arc32.json'\napp_id = int(os.getenv('app_id'))\nprivate_key = os.getenv('private_key')\nsigner = AccountTransactionSigner(private_key)\naddress = address_from_private_key(private_key)\nparams = algod_client.suggested_params()\n\napp_client = ApplicationClient(\n    algod_client=algod_client,\n    app_spec=path,\n    app_id=app_id,\n    signer=signer,\n    sender=address,\n    suggested_params=params,\n)\n\natc = AtomicTransactionComposer()\n\n#asset_id = 723609532\n\n#arbitrary_account = 'MXOT5NO6DVCGIS22AWEP7N5WD72RSV6QJG4OWGDOTEH3DQKCG4R4WLLMR4'\n\n#app_client.compose_call(atc, call_abi_method='txn_comprehension', transaction_parameters={'accounts': [arbitrary_account], 'foreign_assets': [asset_id]})\n\n#app_client.compose_call(\n#    atc, \n#    call_abi_method='inner_txn_comprehension',\n#)\n\nsecond_app = int(os.getenv('second_app_id'))\n\napp_client.compose_call(\n    atc, \n    call_abi_method='inner_txn_two',\n        transaction_parameters={\n        'foreign_apps': [second_app]\n    }\n)\n\nresult = atc.execute(algod_client, 2)\n\nall_tx_ids = [result.abi_results[i].tx_id for i in range(len(result.abi_results))]\nall_abi_results = [result.abi_results[i].return_value for i in range(len(result.abi_results))]\n\nprint(all_tx_ids)\nprint(all_abi_results)\n</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 37,
    "language": "Python",
    "title": "Group Transaction",
    "content": "\n        <h2>Video Tutorial</h2>\n        <div class=\"relative w-full max-w-2xl mx-auto overflow-hidden rounded-lg shadow-md\" style=\"padding-top: 56.25%;\">\n            <iframe\n                class=\"absolute top-0 left-0 w-full h-full border-0\"\n                src=\"https://www.youtube.com/embed/E8DAtyrW4Rw\"\n                frameborder=\"0\"\n                allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n                allowfullscreen>\n            </iframe>\n        </div>\n\n        <h3>Generate Two Accounts</h3>\n        <p>Create two accounts and add their private keys to your <code>.env</code> file.</p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.account import generate_account\n\n\nprivate_key, address = generate_account()\nprint(private_key, address)</code></pre>\n\n        <h3>Generate One Asset</h3>\n        <p>Create one asset and place its ID in your <code>.env</code> file.</p>\n        <p><em>Note: Remember the account that owns the asset, as it will be used for asset transfers later.</em></p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.transaction import AssetCreateTxn, wait_for_confirmation\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk.account import address_from_private_key\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nalgod_token = os.getenv('algod_token')\nalgod_server = os.getenv('algod_server')\nalgod_client = AlgodClient(algod_token, algod_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\nparams = algod_client.suggested_params()\n\nasset_create_txn = AssetCreateTxn(\n    sender=address,\n    sp=params,\n    total=10,\n    decimals=0,\n    default_frozen=False,\n    manager=address,\n    reserve=address,\n    asset_name = 'Test Asset One',\n    unit_name= 'TEST#1',\n)\n\nsigned_asset_create_txn = asset_create_txn.sign(private_key)\ntx_id = algod_client.send_transaction(signed_asset_create_txn)\nprint(tx_id)\n\nwait_for_confirmation(algod_client, tx_id)\ntx_info = algod_client.pending_transaction_info(tx_id)\nprint(tx_info)</code></pre>\n\n        <h2>Launching Contracts</h2>\n        <p><em>Note: Adjust approval and clear teal filenames, as well as global/local states, as needed.</em></p>\n        <p>In this tutorial, we use a second contract, <code>SecondApp</code>, which has 1 local state <code>uint</code>.</p>\n        <pre class=\"overflow-auto shadow-md\"><code>from algosdk.transaction import ApplicationCreateTxn, StateSchema, OnComplete, wait_for_confirmation, PaymentTxn\nfrom algosdk.account import address_from_private_key\nfrom algosdk.v2client.algod import AlgodClient\nfrom algosdk import logic\nfrom dotenv import load_dotenv\nimport base64\nimport os\n\nload_dotenv()\n\nnode_token = os.getenv('algod_token')\nnode_server = os.getenv('algod_server')\nalgod_client = AlgodClient(node_token, node_server)\n\nprivate_key = os.getenv('private_key')\naddress = address_from_private_key(private_key)\n\nparams = algod_client.suggested_params()\n\napproval_teal_file_name = 'TransactionComp.approval.teal'\nclear_teal_file_name = 'TransactionComp.clear.teal'\n\nwith open(f'./{approval_teal_file_name}', 'r') as f:\n    approval_teal_source = f.read()\n\nwith open(f'{clear_teal_file_name}', 'r') as f:\n    clear_teal_source = f.read()\n\napproval_result = algod_client.compile(approval_teal_source)\napproval_program = base64.b64decode(approval_result['result'])\n\nclear_result = algod_client.compile(clear_teal_source)\nclear_program = base64.b64decode(clear_result['result'])\n\nglobal_schema = StateSchema(num_uints=0, num_byte_slices=0)\nlocal_schema = StateSchema(num_uints=0, num_byte_slices=0)\n\ntxn = ApplicationCreateTxn(\n    sender = address,\n    sp = params,\n    on_complete=OnComplete.NoOpOC,\n    approval_program=approval_program,\n    clear_program=clear_program,\n    global_schema=global_schema,\n    local_schema=local_schema,\n)\nsigned_txn = txn.sign(private_key)\n\ntry:\n    txid = algod_client.send_transaction(signed_txn)\nexcept Exception as e:\n    print(e)\n    \nprint(f'Tx ID: {txid}')\nwait_for_confirmation(algod_client, txid)\ntx_info = algod_client.pending_transaction_info(txid)\nprint(f'App ID: {tx_info['application-index']}')\n\napp_address = logic.get_application_address(tx_info['application-index'])\nprint(f'Application Address: {app_address}')\n\n\nactivate_contract = PaymentTxn(\n    sender = address,\n    sp = params,\n    receiver = app_address,\n    amt = 100_000\n)\n\nsigned_activation = activate_contract.sign(private_key)\nactivation_tx = algod_client.send_transaction(signed_activation)\nprint(f'MBR For Contract to be Active Account Funded: {activation_tx}')\n</code></pre>\n\n        <h3>Group Transaction Comprehension (GTXN)</h3>\n        <p>In this section, we put it all together and use relative indexing in our group transaction method to enhance scalability.</p>\n        <pre class=\"overflow-auto shadow-md\"><code>TransactionComprehension_4.py</code></pre>\n        <pre class=\"overflow-auto shadow-md\"><code>from algopy import ARC4Contract, Txn, Bytes, UInt64, String, itxn, Global, OnCompleteAction, gtxn, TransactionType\nfrom algopy.arc4 import abimethod, Address, arc4_signature, abi_call\nfrom algopy.arc4 import UInt64 as arc4UInt64\n\nclass TransactionComp(ARC4Contract):\n    def __init__(self) -> None:\n        pass\n    \n    @abimethod\n    def txn_comprehension(self) -> tuple[Address, Address, Bytes, arc4UInt64, arc4UInt64, String, String, arc4UInt64, Address, arc4UInt64, String, Address]:\n        sender = Address(Txn.sender)\n        foreign_accounts = Address(Txn.accounts(1))\n        app_arg_1 = Txn.application_args(0)\n        txn_foreign_applications = Txn.applications(0)\n        txn_foreign_application_id = arc4UInt64(txn_foreign_applications.id)\n        foreign_asset_1 = Txn.assets(0)\n        foreign_asset_id = arc4UInt64(foreign_asset_1.id)\n        foreign_asset_name = String.from_bytes(foreign_asset_1.name)\n        foreign_asset_unit_name = String.from_bytes(foreign_asset_1.unit_name)\n        sender_foreign_asset_balance = arc4UInt64(foreign_asset_1.balance(Txn.sender))\n        foreign_asset_creator_address = Address(foreign_asset_1.creator)\n        fee_for_this_transaction = arc4UInt64(Txn.fee)\n        transaction_type = String.from_bytes(Txn.type)\n        transaction_id = Address(Txn.tx_id)\n        return sender, foreign_accounts, app_arg_1, txn_foreign_application_id, foreign_asset_id, foreign_asset_name, foreign_asset_unit_name, sender_foreign_asset_balance, foreign_asset_creator_address, fee_for_this_transaction, transaction_type, transaction_id        \n\n    @abimethod\n    def inner_txn_comprehension(self) -> tuple[UInt64, UInt64, UInt64]:\n        asset_config_txn = itxn.AssetConfig(\n            total=1,\n            unit_name=\"TEST#1\",\n            asset_name=\"TEST ASSET ONE\",\n            decimals=0,\n            default_frozen=False,\n            manager=Global.current_application_address,\n            reserve=Global.current_application_address,\n            fee=Global.min_txn_fee,\n            ).submit()        \n        \n        asset_config_txn_2 = itxn.AssetConfig(\n            total=1,\n            unit_name=\"TEST#2\",\n            asset_name=\"TEST ASSET TWO\",\n            decimals=0,\n            default_frozen=False,\n            manager=Global.current_application_address,\n            reserve=Global.current_application_address,\n            fee=Global.min_txn_fee,\n            )        \n        \n        asset_config_txn_3 = itxn.AssetConfig(\n            total=1,\n            unit_name=\"TEST#3\",\n            asset_name=\"TEST ASSET THREE\",\n            decimals=0,\n            default_frozen=False,\n            manager=Global.current_application_address,\n            reserve=Global.current_application_address,\n            fee=Global.min_txn_fee,\n            )\n        \n        submit_tx_1, submit_tx_2 = itxn.submit_txns(asset_config_txn_2, asset_config_txn_3)        \n            \n        return asset_config_txn.created_asset.id, submit_tx_1.created_asset.id, submit_tx_2.created_asset.id    \n    \n    \n    @abimethod\n    def inner_txn_two(self) -> UInt64:\n        \n        method_signature = arc4_signature('return_nothing()void')\n        \n        itxn.ApplicationCall(\n            app_id=727594507,\n            app_args=(method_signature,),\n            on_completion=OnCompleteAction.NoOp,\n            fee=Global.min_txn_fee\n        ).submit()        \n        \n        result, txn = abi_call[UInt64](\n            'local_state_return_something',\n            app_id=727594507,\n            on_completion=OnCompleteAction.OptIn,\n            fee=Global.min_txn_fee\n        )\n        \n        txn = abi_call(\n            'return_nothing',\n            app_id=727594507,\n            fee=Global.min_txn_fee\n        )\n        \n        return result        \n\n    @abimethod\n    def group_txn_comprehension(\n        self,\n        first_transaction: gtxn.PaymentTransaction\n    ) -> tuple[UInt64, UInt64, UInt64]:\n        \n        assert first_transaction.amount == 1000\n        \n        second_transaction = gtxn.Transaction(Txn.group_index + 1)\n        \n        if second_transaction.type == TransactionType.Payment:\n            second_transaction_amount = second_transaction.amount\n            assert second_transaction_amount == 2000\n            \n        elif second_transaction.type == TransactionType.AssetTransfer:\n            second_transaction_amount = second_transaction.asset_amount\n            assert second_transaction_amount == 1\n            \n        third_transaction = gtxn.Transaction(Txn.group_index + 2)\n\n        if third_transaction.type == TransactionType.Payment:\n            third_transaction_amount = third_transaction.amount\n            assert third_transaction_amount == 2000\n\n        elif third_transaction.type == TransactionType.AssetTransfer:\n            third_transaction_amount = third_transaction.asset_amount\n            assert third_transaction_amount == 1            \n                    \n        return first_transaction.amount, second_transaction_amount, third_transaction_amount</code></pre>\n    ",
    "initialCode": ""
  },
  {
    "id": 6,
    "language": "Javascript",
    "title": "Variables",
    "content": "\n    <p>In JavaScript, we have several data types that are used to store different kinds of information:</p>\n    <ul class=inText>\n        <li>Integer: Represents whole numbers without a decimal component. Example: let myNumber = 1000;</li>\n        <li>String: A sequence of characters enclosed within quotes. Example: let myText = \"Hello!\";</li>\n        <li>Float: Represents numbers that contain a decimal point. Example: let myFloat = 7.5;</li>\n        <li>Boolean: Represents one of two values, true or false. Examples: let myBool1 = true; let myBool2 = false;</li>\n        <li>Array: An ordered collection of items enclosed within square brackets. Example: let myList = [];</li>\n        <li>Object: A collection of key-value pairs enclosed within curly braces. Example: let myDictionary = {};</li>\n    </ul>\n    \n    <p>These data types are essential for storing and manipulating different kinds of information in JavaScript.</p>\n    <p>It's good practice to name your variables relevant to their purpose. For example, if I was creating a variable that would represent the cash price of an item, I might name it something like:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>let itemCost = 1; // The cost of an item, which will be 1 dollar\nlet supplyRemaining = 2500000000; // The number of items in inventory that are remaining\nlet nameCTO = \"John Woods\";\nlet valueOfAQuarter = 0.25;</code></pre>\n    \n    <p>You might notice that I use camelCase for naming my variables. It's important to follow JavaScript naming conventions:</p>\n    <ul class=inText>\n    <li>Variable names cannot start with a number.</li>\n    <li>Variable names cannot contain spaces.</li>\n    <li>Variable names can include letters, digits, underscores (_), and dollar signs ($), but should start with a letter, underscore, or dollar sign.</li>\n    </ul>\n    \n    <p>Here are some examples of incorrect variables that will not work in your code, and will cause an error, <strong>DO NOT USE</strong>:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let 3variable = 5;     // Starts with a number\nlet my-variable = 6;   // Contains a hyphen\nlet my variable = 7;   // Contains a space\n</code></pre>\n    \n    <h2>General Arithmetic for Integers, Floats, and Strings</h2>\n    <p>General arithmetic operations are a great place to start! Let's try creating a number variable, and logging it to the console.</p>\n    <p>If this is your first time programming, or even if you have programmed before, you'll quickly find out or are already familiar that logging is one of the most commonly used functions for debugging. It's how you \"see\" what the value is of your variable at a specific point in your code</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>let myNumber = 1;\nlet myNumberPlusOne = myNumber + 1;\nconsole.log(myNumberPlusOne); // Output will be 2</code></pre>\n    \n    <p>There are several arithmetic operators available in JavaScript, and they are as follows:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>let a = 10;\nlet b = 3;\nlet addition = a + b;          // Addition: 13\nlet subtraction = a - b;       // Subtraction: 7\nlet multiplication = a * b;    // Multiplication: 30\nlet division = a / b;          // Division: 3.3333333333333335\nlet floorDivision = Math.floor(a / b); // Floor Division: 3\nlet modulus = a % b;           // Modulus: 1\nlet exponentiation = a ** b;   // Exponentiation: 1000</code></pre>\n    \n    <p>For strings, '+' is used for concatenation:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>let greeting = \"Hello, \" + \"World!\";\nconsole.log(greeting); // Output: \"Hello, World!\"</code></pre>\n    \n    <p>Unlike Python, JavaScript does not support string multiplication using arithmetic operators; it results in NaN (Not a Number):</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let string = \"Hello\";\nlet repeatedString = string * 3;  // This will result in NaN\nconsole.log(repeatedString); // Output: NaN</code></pre>\n    \n    <p>Instead, use the repeat function for repeating strings:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let repeatedGreeting = string.repeat(3);\nconsole.log(repeatedGreeting); // Output: \"HelloHelloHello\"</code></pre>\n    \n    <p>We won't dive into Arrays or Objects just yet, but it is important to note that arrays and objects are mutable, whereas strings are immutable in JavaScript.</p>\n    <p>When you hear mutable, think \"can be changed\", where mutable means it can be changed and immutable means it cannot be changed.</p>\n    \n    <p>Example showing mutability of an array:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let myArray = [1, 2];\nconsole.log(myArray[0]); // Output: 1\nmyArray[0] = 2;\nconsole.log(myArray); // Output: [2, 2]</code></pre>\n    \n    <p>Example showing immutability (cannot be changed) of a string:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let myString = \"Hello\";\nconsole.log(myString);  // Output: \"Hello\"\nmyString[0] = \"J\";  // This does not change the string\nconsole.log(myString);  // Output: \"Hello\"</code></pre>\n    \n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What data type is used to store whole numbers in JavaScript?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"correct\">a) Integer</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) String</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) Float</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) Boolean</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which of the following is a correct variable name in JavaScript?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"incorrect\">a) 3variable</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) my-variable</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"correct\">c) itemCost</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) my variable</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the result of the following code?</p>\n          <pre class=\"overflow-auto shadow-md\"><code>let myNumber = 1;\nlet myNumberPlusOne = myNumber + 1;\nconsole.log(myNumberPlusOne);\n</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) 1</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"correct\">b) 2</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) NaN</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) undefined</label><br>\n  \n          <h3>Question 4</h3>\n          <p>Which arithmetic operator is used for exponentiation in JavaScript?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"incorrect\">a) /</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) %</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) *</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"correct\">d) **</label><br>\n  \n          <h3>Question 5</h3>\n          <p>What is the correct way to concatenate strings in JavaScript?</p>\n          <input type=\"radio\" id=\"q5a\" name=\"q5\" value=\"a\">\n          <label for=\"q5a\" class=\"correct\">a) let greeting = \"Hello, \" + \"World!\";</label><br>\n          <input type=\"radio\" id=\"q5b\" name=\"q5\" value=\"b\">\n          <label for=\"q5b\" class=\"incorrect\">b) let greeting = \"Hello, \" * \"World!\";</label><br>\n          <input type=\"radio\" id=\"q5c\" name=\"q5\" value=\"c\">\n          <label for=\"q5c\" class=\"incorrect\">c) let greeting = \"Hello, \" - \"World!\";</label><br>\n          <input type=\"radio\" id=\"q5d\" name=\"q5\" value=\"d\">\n          <label for=\"q5d\" class=\"incorrect\">d) let greeting = \"Hello, \" / \"World!\";</label><br>\n  \n          \n      </form>\n    \n    ",
    "initialCode": "let myArray = [1, 2]; \nconsole.log(myArray[0]);\nmyArray[0] = 2;\nconsole.log(myArray);"
  },
  {
    "id": 7,
    "language": "Javascript",
    "title": "Functions",
    "content": "\n    <p>In JavaScript, a function is a block of code that performs a specific task. Functions help to modularize code, making it more readable and reusable.</p>\n    <p>To define a function, we use the <code>function</code> keyword followed by the function name and parentheses. Inside the parentheses, we can specify parameters that the function can accept. The code block within every function starts with a curly brace ({) and ends with a curly brace (}).</p>\n    \n    <p>Let's start with calling this simple function above that prints a greeting message:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>function greet() {\n    console.log(\"Hello, world!\");\n}\ngreet();\n// Output: \"Hello, world!\"</code></pre>\n    \n    <p>Functions in JavaScript can accept parameters, which let you pass different values into them. Here's how we use a function called 'greet':</p>\n    <pre class=\"overflow-auto shadow-md\"><code>function greet(name) {\n    console.log(`Hello, ${name}!`);\n}\ngreet(\"Alice\"); // Outputs: \"Hello, Alice!\"\ngreet(\"Bob\"); // Outputs: \"Hello, Bob!\"</code></pre>\n    \n    <p>In this example, the <code>greet</code> function takes a parameter named <code>name</code>. When we call this function and give it a name like \"Alice\" or \"Bob\", it prints a personalized greeting.</p>\n    <p>To create the greeting message, we use something called a template literal. A template literal is a type of string that makes it easy to include variables directly inside the string. You create a template literal by wrapping your text with backtick characters, and you can insert variables like <code>name</code> by wrapping them in ${ } inside the string.</p>\n    <p>For instance, <code>Hello, ${name}!</code> combines \"Hello,\" with the name you provide when calling the function, resulting in a complete greeting message.</p>\n    \n    <p>Functions can return values using the <code>return</code> statement. This allows us to capture the result of a function and use it in our code. Here's an example:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>function add(a, b) {\n    return a + b;\n}\nlet result = add(3, 5);\nconsole.log(result);  // Output: 8</code></pre>\n    \n    <p>The <code>add</code> function takes two parameters <code>a</code> and <code>b</code>, adds them together, and returns the result. We can then store the returned value in a variable and print it.</p>\n    \n    <p>Functions can have default parameter values, which are used if no argument is provided when the function is called. Here's an example:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>function greet(name = \"world\") {\n    console.log(`Hello, ${name}!`);\n}\ngreet();  // Output: Hello, world!\ngreet(\"Alice\");  // Output: Hello, Alice!</code></pre>\n    \n    <p>In this example, the <code>greet</code> function has a default parameter value of \"world\". If no argument is passed when the function is called, it uses the default value.</p>\n    \n    <p>We can also define functions that accept a variable number of arguments using the <code>...args</code> syntax. Here's an example:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>function add(...args) {\n    return args.reduce((acc, curr) => acc + curr, 0);\n}\nconsole.log(add(1, 2, 3));  // Output: 6\nconsole.log(add(4, 5, 6, 7));  // Output: 22</code></pre>\n    \n    <p>The <code>add</code> function uses <code>...args</code> to accept a variable number of arguments. Inside the function, <code>args</code> is an array containing all the arguments passed. We use the <code>reduce</code> method to add all the values together and return the result.</p>\n    \n    <p>The <code>...</code> syntax can also be used to accept a variable number of keyword arguments in an object. Here's an example:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>function printInfo({ ...kwargs }) {\n    for (let key in kwargs) {\n        console.log(`${key}: ${kwargs[key]}`);\n    }\n}\nprintInfo({ name: \"Alice\", age: 30, city: \"New York\" });</code></pre>\n    \n    <p>In this example, the <code>printInfo</code> function uses <code>...</code> to accept a varying number of keyword arguments. Inside the function, <code>kwargs</code> is an object containing all the keyword arguments passed. We loop through the object and print each key-value pair.</p>\n    \n    <p>Functions are a fundamental part of JavaScript programming, enabling us to create modular, reusable, and maintainable code. As we progress, we'll explore more advanced concepts and techniques related to functions.</p>\n    \n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What is the correct way to define a function in JavaScript that prints \"Hello, world!\"?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"correct\">a) function greet() { console.log(\"Hello, world!\"); }</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) def greet() { print(\"Hello, world!\"); }</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) function greet { console.log(\"Hello, world!\"); }</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) function greet() console.log(\"Hello, world!\");</label><br>\n  \n          <h3>Question 2</h3>\n          <p>How do you call a function named greet that takes one parameter and logs a greeting message?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"incorrect\">a) greet[\"Alice\"]</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"correct\">b) greet(\"Alice\")</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) greet.Alice</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) greet Alice</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the result of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>function add(a, b) {\n    return a + b;\n}\nlet result = add(3, 5);\nconsole.log(result);</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) 35</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"correct\">b) 8</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) NaN</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) undefined</label><br>\n  \n          <h3>Question 4</h3>\n          <p>What is the correct syntax for a function that accepts a variable number of arguments and returns their sum?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"incorrect\">a) function add(...args) { return args.reduce((acc, curr) => acc + curr, 0); }</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) function add(args...) { return args.reduce((acc, curr) => acc + curr, 0); }</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"correct\">c) function add(...args) { return args.reduce((acc, curr) => acc + curr); }</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) function add(args...) { return args.reduce((acc, curr) => acc + curr); }</label><br>\n  \n          \n      </form>\n    \n    ",
    "initialCode": "function add(a, b) {\nreturn a + b;\n}\nlet result = add(3, 5);\nconsole.log(result); // Output: 8"
  },
  {
    "id": 8,
    "language": "Javascript",
    "title": "Arrays",
    "content": "\n    <p>Before we go over objects, which are the most common datatype when sending and receiving information between applications (back-end to front-end, front-end to back-end, or back-end to websites, etc.), and this is especially true when interacting with the Algorand blockchain, I think it's important to have an understanding of how arrays work.</p>\n    \n    <p>Below is an example of an array:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let myArray = [7, \"Hello\", false, 63.5];</code></pre>\n    \n    <p>An array can hold all types of data, and you can have all kinds of data in one array. You use arrays when you need exactly that, a list. Arrays are also mutable, as opposed to tuples—which means we can rearrange, extend, and replace items in an array, meaning they're super flexible!</p>\n    \n    <p>An array is a collection of data enclosed between square brackets [ ], and separated by commas. An example of common kinds of data you would have in an array on Algorand could be one that has asset IDs.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let asset_ids = [1265975021, 1138500612, 400593267];</code></pre>\n    \n    <p>Or perhaps an array of addresses:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let addresses = [\n'WWYUMYPM2Y5NIIZTF4O5N73A4ZTZQWXS6TNP23U37LQ6WWF543SRTGKWUU',\n'7IWZ342UGNQ2JVS2E6EGFD4MPUNL4ZIWDYNFZIANR6U7WZXORCRQCCN3YY',\n'HZ57J3K46JIJXILONBBZOHX6BKPXEM2VVXNRFSUED6DKFD5ZD24PMJ3MVA'];</code></pre>\n    \n    <p>Although arrays don't have to be organized in any way and are not descriptive, they can be manipulated. For example, if you wanted to remove duplicate entries in an array, you could use the Set object.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let myArray = [1, 1, 2, 3, 4, 4];\nlet myArrayWithoutDuplicates = [...new Set(myArray)];\nconsole.log(myArrayWithoutDuplicates);</code></pre>\n    \n    <p># Output:# [1, 2, 3, 4]</p>\n    \n    <p>Let's look back at the first example of an array:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let myArray = [7, \"Hello\", false, 63.5];</code></pre>\n    \n    <p>In the array above we have an integer at the first spot, 7; a string in the second spot, \"Hello\"; a boolean (true or false value) in the third spot; a float (decimal value), in the fourth spot.\n    I refer to the places these items are in the array as \"spots\", but the correct term is actually \"indexes\". We referenced them as the first, second, third, and fourth spot— however, in programming arrays are zero-indexed. This means that we always start from zero, and use an integer to refer to their position in the array. This feels strange, but it is something you should have ingrained into your mind, as this is universal across all programming when indexing for positions in an array.</p>\n    \n    <p>The correct reference to the positions would be Index 0 for 7, Index 1 for \"Hello\", Index 2 for false, and Index 3 for 63.5. But, how would we see this utilized in a programming scenario?</p>\n    \n    <p>To interact with the array, we must first assign it to a variable:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let myArray = [7, \"Hello\", false, 63.5];</code></pre>\n    \n    <p>Now, we can use index notation to pick out items of our choice by using their position, let's start with just logging the array to the terminal:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>console.log(myArray);</code></pre>\n    <p># Output: [7, \"Hello\", false, 63.5]</p>\n    \n    <p>... and now let's log the item at index 1 (the second item since the first item is always 0) using index notation:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let firstIndexMyArray = myArray[1];\nconsole.log(firstIndexMyArray);</code></pre>\n    <p># Output: \"Hello\"</p>\n    \n    <p>Try logging the third index into the console using index notation. I've already defined the array for you below. Click run when you're ready to run the code! The output should be 63.5.</p>\n    \n    <p>IDE WINDOW:\n    let myArray = [7, \"Hello\", false, 63.5];\n    . . .\n    CHECK OUTPUT IS 63.5 AND SHOW \"SUCCESS\"</p>\n    <p>Next chapter: Objects</p>\n    \n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What data structure is used to store a collection of values in JavaScript?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"correct\">a) Array</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) Object</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) String</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) Number</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which of the following correctly initializes an array in JavaScript?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"incorrect\">a) let myArray = {7, \"Hello\", false, 63.5};</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) let myArray = (7, \"Hello\", false, 63.5);</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"correct\">c) let myArray = [7, \"Hello\", false, 63.5];</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) let myArray = \"7, Hello, false, 63.5\";</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the output of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>let myArray = [7, \"Hello\", false, 63.5];\nconsole.log(myArray[2]);</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) 7</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) \"Hello\"</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"correct\">c) false</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) 63.5</label><br>\n  \n          <h3>Question 4</h3>\n          <p>How do you remove duplicate entries from an array in JavaScript?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>let myArray = [1, 1, 2, 3, 4, 4];\nlet myArrayWithoutDuplicates = [...new Set(myArray)];\nconsole.log(myArrayWithoutDuplicates);</code></pre>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) Using the Set object</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) Using the Map object</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) Using the Filter object</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) Using the Reduce object</label><br>\n  \n          \n      </form>\n    \n    ",
    "initialCode": "let myArray = [7, \"Hello\", false, 63.5];\n\n// Access and log the element at index 1\nlet firstIndexMyArray = myArray[1];\nconsole.log(firstIndexMyArray);\n\n// Access and log the element at index 3\nlet thirdIndexMyArray = myArray[3];\nconsole.log(thirdIndexMyArray);\n  "
  },
  {
    "id": 9,
    "language": "Javascript",
    "title": "Objects",
    "content": "\n    <p>Now we'll dive into a bit more advanced data structures, objects! An object is like an array, except it uses curly brackets { } instead of square brackets [ ]— but most importantly, objects also differ in that they store values with keys, and can accept several data types. An object can be highly versatile, and can not only be used for data storage, but for more complex algorithms like hashmaps, which we'll go over later. Most interestingly, we can have objects with objects within them, and even arrays as well! It's important to mention that keys and values have a colon ' : ' separator between them.</p>\n    \n    <p>Here's a simple example of an object:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let thisIsMyObject = {name: \"John\", age: 22};</code></pre>\n    \n    <p>In arrays, we used a process called indexing, and the index notation format to access values, eg; myArray[3]. With objects, we use a similar process called key access, and the key notation format to access values.</p>\n    \n    <p>The main difference is that we use keys, instead of solely integers that refer to position, to select values from an object— and not to confuse you, but a key in an object can also be an integer =).</p>\n    \n    <p>For example, in thisIsMyObject above, you'll see the value \"John\" belongs to the key, \"name\". As well as the value 22, belongs to the key, \"age\". This is what key notation would look like for accessing a value for a specific key in an object:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let nameValue = thisIsMyObject['name'];\nconsole.log(nameValue);</code></pre>\n    <p># Output: \"John\"</p>\n    \n    <p>Try printing the \"age\" value in the code editor below:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let ageValue = thisIsMyObject['age'];\nconsole.log(ageValue);</code></pre>\n    <p># Output: 22</p>\n    \n    <p>Now we'll look over a more intricate object, that's a bit larger and complex.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>thisIsMyObject = {name: \"John\", age: 22, likes: [\"Exercise\", \"Cooking\", \"Coding\"]};</code></pre>\n    \n    <p>We see something in this object that we haven't seen before, an array as the value to a key. Let's try accessing the 1st index of John's likes using a mix of key notation and index notation!</p>\n    <pre class=\"overflow-auto shadow-md\"><code>let likes = thisIsMyObject['likes'];\nconsole.log(likes);</code></pre>\n    <p># Output:# [\"Exercise\", \"Cooking\", \"Coding\"]</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>let likesFirstIndex = likes[1];\nconsole.log(likesFirstIndex);</code></pre>\n    <p># Output:# \"Cooking\"</p>\n    \n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What data structure is used to store values with keys in JavaScript?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) Array</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"correct\">b) Object</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) String</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) Number</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which of the following correctly initializes an object in JavaScript?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) let myObject = {name: \"John\", age: 22};</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) let myObject = {John, 22};</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) let myObject = [\"John\", 22];</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) let myObject = (name: \"John\", age: 22);</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the output of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>let thisIsMyObject = {name: \"John\", age: 22};\nconsole.log(thisIsMyObject['age']);</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) \"John\"</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"correct\">b) 22</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) \"age\"</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) undefined</label><br>\n  \n          <h3>Question 4</h3>\n          <p>What will be the output of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>let thisIsMyObject = {name: \"John\", age: 22, likes: [\"Exercise\", \"Cooking\", \"Coding\"]};\nlet likesFirstIndex = thisIsMyObject['likes'][1];\nconsole.log(likesFirstIndex);</code></pre>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"incorrect\">a) \"Exercise\"</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"correct\">b) \"Cooking\"</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) \"Coding\"</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) [\"Exercise\", \"Cooking\", \"Coding\"]</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "let thisIsMyObject = {name: \"John\", age: 22, likes: [\"Exercise\", \"Cooking\", \"Coding\"]};\n  \n// Access and log the \"likes\" array using key notation\nlet likes = thisIsMyObject['likes'];\nconsole.log(likes);\n\n// Expected Output: [\"Exercise\", \"Cooking\", \"Coding\"]\n\n// Access and log the value at the 1st index of the \"likes\" array\nlet likesFirstIndex = likes[1];\nconsole.log(likesFirstIndex);\n\n// Expected Output: \"Cooking\"\n  "
  },
  {
    "id": 10,
    "language": "Javascript",
    "title": "Imports",
    "content": "\n    <p>This code begins with module imports, which is a fancy way of saying— \"someone wrote some code that does something, and I want to use that something in my code\". It isn't possible to use libraries, which are just collections of code created by someone, without formally importing them at the beginning of your code. Imports must appear before usage of anything within them because like the English language, JavaScript interpreters read from top to bottom.</p>\n    \n    <p>The module imports the Algodv2 class from the algosdk library. The require statement is used to import the algosdk library in Node.js.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>const algosdk = require('algosdk');</code></pre>\n    \n    <p>In this code, the algosdk library is imported using require. Then, the Algodv2 client is instantiated with the API token, server address, and port.</p>\n    \n    <p>Now let's get the status of the Algod client:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>const algodToken = 'Your algod API token';\nconst algodServer = 'http://YourAlgodServerAddress';\nconst algodPort = 'YourAlgodServerPort';\nconst algodClient = new algosdk.Algodv2(algodToken, algodServer, algodPort);\nalgodClient.status().do()\n    .then(status => {\n        console.log(status);\n    })\n    .catch(err => {\n        console.error(err);\n    });</code></pre>\n    \n    <p>We use the <code>status()</code> method to get the status of the Algod client. This method returns a promise, so we use <code>.then()</code> to handle the successful response and <code>.catch()</code> to handle any errors.</p>\n    \n    <p>Next, we generate a random number using the random module. In JavaScript, we use <code>Math.random()</code> to generate random numbers.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>const random_number = Math.floor(Math.random() * 101);\nconsole.log(random_number);</code></pre>\n    \n    <p>To decide on whether or not you want to import a specific file, function, or method, you would need to use your intuition! For example, you may only need a specific function from a module.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>const { Algodv2 } = require('algosdk');\nconst algodToken = 'Your algod API token';\nconst algodServer = 'http://YourAlgodServerAddress';\nconst algodPort = 'YourAlgodServerPort';\nconst algodClient = new Algodv2(algodToken, algodServer, algodPort);</code></pre>\n    \n    <p>Now you can use <code>algodClient</code> for your transactions or other operations</p>\n    \n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What statement is used to import a module in Node.js?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) import module from 'module';</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"correct\">b) const module = require('module');</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) using module;</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) include module;</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which of the following imports only the Algodv2 class from the algosdk library?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) const { Algodv2 } = require('algosdk');</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) const algosdk = require('algosdk').Algodv2;</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) const Algodv2 = require('algosdk').default;</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) const Algodv2 = require('algosdk')['Algodv2'];</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What method is used to get the status of the Algod client?</p>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) algodClient.getStatus()</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"correct\">b) algodClient.status().do()</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) algodClient.fetchStatus()</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) algodClient.retrieveStatus()</label><br>\n  \n          <h3>Question 4</h3>\n          <p>How do you generate a random number between 0 and 100 in JavaScript?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) Math.floor(Math.random() * 101);</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) Math.random(100);</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) random(0, 100);</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) Math.rand(0, 100);</label><br>\n  \n          \n      </form>\n    \n    ",
    "initialCode": "// Import algosdk\nconst algosdk = require('algosdk');\n\n// Set up your API token, server, and port\nconst algodToken = '';\nconst algodServer = 'https://testnet-api.algonode.cloud';\nconst algodPort = '';\n\n// Initialize the Algodv2 client\nconst algodClient = new algosdk.Algodv2(algodToken, algodServer, algodPort);\n\n// Log client instance to ensure it's initialized correctly\nconsole.log(algodClient);\n  "
  },
  {
    "id": 38,
    "language": "Javascript",
    "title": "Getting Started with Algorand",
    "content": "\n    <p>To set up your own node, visit this GitHub repository for a previous tutorial series:</p>\n    <p><a href=\"https://github.com/atsoc1993/Algorand_Discord_Bots_Tutorial_Series/tree/main/Episode%201%20-%20Algorand%20Node%2C%20Python%2C%20Visual%20Studio%20Code%2C%20Ubuntu%2C%20and%20Module%20Installations\">Algorand Node Installation</a></p>\n    <p>Scroll down to the section called \"Algorand Node Installation\"— and make sure to run these commands in an Ubuntu LTS Shell (Download link in bottom resources section). If you chose to run a node, that's wonderful! If not, I will be including sections for those programming without a node.</p>\n    \n    <p>Now that we have access to an Algorand testnet node, as well as a basic understanding of how to work with different kinds of variables, functions and imports. It's time to get started! This will reaffirm your ability to use functions, methods, and imports— as well as key notation: eg; accessing the name of a customer in a variable named my_dictionary:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>const myDictionary = {'customer-name': 'Jerry'};\nconst customerName = myDictionary['customer-name'];\nconsole.log(customerName);</code></pre>\n    \n    <p>If you are using your own Algorand testnet node on Windows, you will need to access your algod_token and algod_port from your node's data directory:</p>\n    <ol class=inText>\n      <li>Enter the data directory from the root folder:\n        <code>cd node/data</code>\n      </li>\n      <li>Use the following commands to obtain your node token and port:</li>\n    </ol>\n    <pre><code>cat algod.token</code> ---Logs the token into the terminal, it should look something like:</pre>\n    <pre><code>b94c8e5d7a3f1bbd249e83a1cc5b4ae67d8c2a7e9b5f0c6d8e1a7b4f263859cd</code></pre>\n    <pre><code>cat algod.net</code> ---Logs the port into the terminal, it should look something like:</pre>\n    <pre><code>127.0.0.1:8080</code></pre>\n    <p>When programming, you will format this information for variables like so:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>const algodToken = 'b94c8e5d7a3f1bbd249e83a1cc5b4ae67d8c2a7e9b5f0c6d8e1a7b4f263859cd';\nconst algodServer = 'http:127.0.0.1';\nconst algodPort = 8080;</code></pre>\n    <p>If you are not using your own Algorand testnet node, you can use these:</p>\n    <p>(Free service does not require token, and the algodToken variable will be an empty string '', whereas the algodServer will be the algonode testnet cloud link)</p>\n    <pre class=\"overflow-auto shadow-md\"><code>const algodToken = ''; \nconst algodServer = 'https://testnet-api.algonode.cloud'; \nconst algodPort = 443;</code></pre>\n    \n    <p>Note: If you are attempting to run this code outside of the browser in your own IDE, remember to use npm init -y to create a package.json, and add \"type\": \"module\" anywhere in your package. Then make sure you install the algorand sdk by using 'npm install algosdk'. Afterwards, you can run the code in your terminal by using node nameOfYourFile.js.</p>\n    <p>If you get an error along the likes of 'node is not a function', this means you haven't installed node.js, you can install it here:</p>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>// Import algosdk\nimport algosdk from 'algosdk';\n\n// Initialize AlgodClient\nconst algodToken = ''; // Leave '' for public node service, or enter your node token\nconst algodServer = 'https://testnet-api.algonode.cloud'; // Use this cloud link, or enter your own host & port\nconst algodPort = 443;\n\n// Create an instance of the algod client\nconst algodClient = new algosdk.Algodv2(algodToken, algodServer, algodPort);\n\n// Fetch the node status and print it\nalgodClient.status().do()\n    .then(status => {\n        console.log('Node status:', status);\n    })\n    .catch(err => {\n        console.error('Failed to get node status:', err);\n    });</code></pre>\n    \n    <p>First, we import the algosdk library, which includes the AlgodClient necessary for interacting with the Algorand network.</p>\n    <p>Next, we define variables for our token, server URL, and port number for the node we'll be using. These are set up to handle connections to the Algorand testnet via a public service, but can be adjusted if you are running your own node.</p>\n    <p>We then create an instance of AlgodClient using the algodToken, algodServer, and algodPort. This instance is assigned to the variable algodClient.</p>\n    <p>Using the algodClient instance, we access the status method to fetch the current status of the Algorand network. This method returns a promise that resolves to the status information.</p>\n    <p>Once the promise resolves, the resulting status data is contained within the status variable within the .then() method's callback. Here, we print the entire status object to the console to view its contents.</p>\n    \n    <p>Try running the code now!</p>\n    \n    <p>You'll see that you receive a dictionary with several keys and associated values, here is a list of all the keys:</p>\n    <ul class=inText>\n      <li>catchpoint</li>\n      <li>catchpoint-acquired-blocks</li>\n      <li>catchpoint-processed-accounts</li>\n      <li>catchpoint-processed-kvs</li>\n      <li>catchpoint-total-accounts</li>\n      <li>catchpoint-total-blocks</li>\n      <li>catchpoint-total-kvs</li>\n      <li>catchpoint-verified-accounts</li>\n      <li>catchpoint-verified-kvs</li>\n      <li>catchup-time</li>\n      <li>last-catchpoint</li>\n      <li>last-round</li>\n      <li>last-version</li>\n      <li>next-version</li>\n      <li>next-version-round</li>\n      <li>next-version-supported</li>\n      <li>stopped-at-unsupported-round</li>\n      <li>time-since-last-round</li>\n    </ul>\n    \n    <p>The most popular keys are last-round, so you know which block you are on, and perhaps time-since-last-round, if you should need to know that information. Other keys are primarily used by node running services, like upcoming reti-pool incentives, but otherwise are not especially useful for our purposes.</p>\n    \n    <p>Referencing the information from Chapter 4, for Objects, try this:</p>\n    <ul class=inText>\n      <li>Create a variable, and name it lastRound</li>\n      <li>Assign the value of the key 'last-round' in the status dictionary to this variable you created</li>\n      <li>Print your variable!</li>\n    </ul>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>// Import algosdk\nimport algosdk from 'algosdk';\n\n// Initialize AlgodClient\nconst algodToken = ''; // Leave '' for public node service, or enter your node token\nconst algodServer = 'https://testnet-api.algonode.cloud'; // Use this cloud link, or enter your own host & port\nconst algodPort = 443;\n\n// Create an instance of the algod client\nconst algodClient = new algosdk.Algodv2(algodToken, algodServer, algodPort);\n\n// Fetch the node status and print it\nalgodClient.status().do()\n    .then(status => {\n        // Create a variable, and name it lastRound\n        const lastRound = status['last-round'];\n        // Print your variable\n        console.log('Last round:', lastRound);\n    })\n    .catch(err => {\n        console.error('Failed to get node status:', err);\n    });</code></pre>\n    \n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What command is used to navigate to the node's data directory in an Ubuntu shell?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) cd data/node</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"correct\">b) cd node/data</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) cd algod/data</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) cd node/algod</label><br>\n  \n          <h3>Question 2</h3>\n          <p>How do you log the Algorand node token to the terminal?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) cat algod.token</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) cat algod.net</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) cat node.token</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) cat node.net</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What are the default values for algodToken and algodServer when using a public Algorand testnet node?</p>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) const algodToken = 'default'; const algodServer = 'http://localhost';</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) const algodToken = 'public'; const algodServer = 'https://testnet.algorand.org';</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"correct\">c) const algodToken = ''; const algodServer = 'https://testnet-api.algonode.cloud';</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) const algodToken = 'none'; const algodServer = 'https://testnet.algorand.io';</label><br>\n  \n          <h3>Question 4</h3>\n          <p>How do you access the value of the 'last-round' key from the Algorand node status object?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>algodClient.status().do()\n.then(status => {\n    // Create a variable, and name it lastRound\n    const lastRound = status['last-round'];\n    // Print your variable\n    console.log('Last round:', lastRound);\n})\n.catch(err => {\n    console.error('Failed to get node status:', err);\n});</code></pre>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) const lastRound = status['last-round'];</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) const lastRound = status.lastRound;</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) const lastRound = status.last-round;</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) const lastRound = status['round-last'];</label><br>\n  \n          \n      </form>\n    \n    ",
    "initialCode": "\nconst algosdk = require('algosdk');\n\n// Initialize AlgodClient\nconst algodToken = ''; // Leave '' for public node service, or enter your node token\nconst algodServer = 'https://testnet-api.algonode.cloud'; // Use this cloud link, or enter your own host & port\nconst algodPort = 443;\n\n// Create an instance of the Algod client\nconst algodClient = new algosdk.Algodv2(algodToken, algodServer, algodPort);\n\n// Fetch the node status and print it\nalgodClient.status().do()\n  .then(status => {\n    console.log('Node status:', status);\n  })\n  .catch(err => {\n    console.error('Failed to get node status:', err);\n  });\n\n  "
  },
  {
    "id": 39,
    "language": "Javascript",
    "title": "Payment Transactions",
    "content": "\n    <pre class=\"overflow-auto shadow-md\">\n    <code>const algosdk = require('algosdk');\n    \n    // TWO WAYS TO IMPORT AN ACCOUNT\n    \n    // METHOD 1\n    // CREATE A NEW ACCOUNT\n    const account = algosdk.generateAccount();\n    console.log('Private Key:', Buffer.from(account.sk).toString('base64')); // Output Private Key\n    console.log('Address:', account.addr); // Output Address\n    \n    // IF NEEDED TO IMPORT TO A WALLET, YOU CAN OBTAIN THE MNEMONIC FROM THE PRIVATE KEY\n    // REDEEM MNEMONIC FROM PRIVATE KEY\n    const mnemonicPhrase = algosdk.secretKeyToMnemonic(account.sk);\n    console.log('Mnemonic Phrase:', mnemonicPhrase); // Output Mnemonic Phrase\n    \n    // METHOD 2\n    // USE MNEMONIC TO OBTAIN PRIVATE KEY\n    // REDEEM PRIVATE KEY FROM MNEMONIC\n    const mnemonic = 'brown repeat amazing april survey fish gospel brown bless core deny plate admit burden pistol device shuffle sadness genius answer hurt analyst foot above annual';\n    const recoveredAccount = algosdk.mnemonicToSecretKey(mnemonic);\n    console.log('Recovered Private Key:', Buffer.from(recoveredAccount.sk).toString('base64')); // Output Private Key</code>\n    </pre>\n    \n    <p>When developing in JavaScript with the Algorand blockchain, there are two methods to obtain a private key and address for signing transactions you create. The private key is in base64 format and is required for transaction signing.</p>\n    \n    <h4>Method 1: Create a brand new account and obtain the private key and address directly</h4>\n    \n    <p>In the algosdk's account module, there is a function called generateAccount(), which you can import at the beginning of your code, and is defined here:</p>\n    \n    <pre class=\"overflow-auto shadow-md\">\n    <code>function generateAccount() \n    Generate an account.\n    \n    Returns:\n    {addr: string, sk: Uint8Array}: An object containing the account address and secret key</code>\n    </pre>\n    \n    <p>This returns an object containing the private key (as a Uint8Array) and the account address as strings. You would assign the output of the function to a variable and then subsequently print them.</p>\n    \n    <p>In the testnet, you can now fund the account by inputting the address at <a href=\"https://bank.testnet.algorand.network/\">https://bank.testnet.algorand.network/</a>.\n    All accounts require a minimum balance of 0.1 Algo to send transactions, and then 0.001 Algorand per transaction fee.</p>\n    \n    <p>Should you need the mnemonic to import into a wallet application later, you can do so with the secretKeyToMnemonic() function in the algosdk library as well; input your secret key into the function and assign the output variable to something like \"mnemonicPhrase\". Function is defined below:</p>\n    \n    <pre class=\"overflow-auto shadow-md\">\n    <code>function secretKeyToMnemonic(secretKey: Uint8Array) -> string\n    Return the mnemonic for the secret key.\n    \n    Args:\n    secretKey (Uint8Array): The secret key as a Uint8Array\n    \n    Returns:\n    string: mnemonic phrase</code>\n    </pre>\n    \n    <h4>Method 2: Convert an Existing Mnemonic to a Private Key</h4>\n    \n    <p>Should you already have a mnemonic and require the private key in base64 format, you can create a variable called \"mnemonicPhrase\" and use the result of the mnemonicToSecretKey() function in the algosdk library, which is defined below:</p>\n    \n    <pre class=\"overflow-auto shadow-md\">\n    <code>function mnemonicToSecretKey(mnemonic: string) -> {addr: string, sk: Uint8Array}\n    Return the account object for the mnemonic.\n    \n    Args:\n    mnemonic (string): mnemonic of the private key\n    \n    Returns:\n    {addr: string, sk: Uint8Array}: An object containing the account address and secret key</code>\n    </pre>\n    \n    <p>The mnemonic must be a string, meaning it is enclosed in apostrophes or double quotes ('' or \"\"), and there must be a space between words.</p>\n    \n    <p>Now let's use the account we generated and funded using <a href=\"https://bank.testnet.algorand.network/\">https://bank.testnet.algorand.network/</a>, create our AlgodClient class to initiate a connection to the Algorand blockchain, generate a new account to interact with, and subsequently sign, and send some different kinds of payment transactions.</p>\n    \n    <p>We will be trying a typical payment transaction with a note field, followed by a rekey transaction (rekey to a new account and back to ourselves from the new account), and an account closing transaction. All three are under the scope of a payment transaction.</p>\n    \n    <pre class=\"overflow-auto shadow-md\">\n    <code>const algosdk = require('algosdk');\n    \n    // Algod client connection parameters\n    const algodToken = '';\n    const algodServer = 'https://testnet-api.algonode.cloud';\n    const algodPort = '443';\n    const algodClient = new algosdk.Algodv2(algodToken, algodServer, algodPort);\n    \n    // Sender's account details\n    const address = 'I3BHPDWGH63J47JBG2P7RJLOGD3L3HEBOI4KKUKSV3MZSYFX4VFDIDYSMU';\n    const private_key = '6KitD65Q7V6ZDB29EEx1YtoBeqy0PDt+78Ga4DchXItGwneOxj+2nn0hNp/4pW4w9r2cgXI4pVFSrtmZYLflSg==';\n    \n    // Convert 1.001 Algos to microalgos\n    const amount = algosdk.algosToMicroalgos(1.001);\n    \n    // Get transaction parameters\n    async function submitTransaction() {\n        let params = await algodClient.getTransactionParams().do();\n    \n        // Generate a new account\n        const { addr: newAccountAddress, sk: newAccountPrivateKey } = algosdk.generateAccount();\n        console.log('New Account Address:', newAccountAddress);\n    \n        // Create a payment transaction\n        let txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n            from: address,\n            to: newAccountAddress,\n            amount: amount,\n            note: new TextEncoder().encode(\"Here's your one Algo!\"),\n            suggestedParams: params\n        });\n    \n        // Sign the transaction\n        const signedTxn = txn.signTxn(Buffer.from(private_key, 'base64'));\n    \n        // Send the transaction\n        try {\n            let { txId } = await algodClient.sendRawTransaction(signedTxn).do();\n            console.log('Transaction ID:', txId);\n    \n            // Wait for confirmation\n            let confirmedTxn = await algosdk.waitForConfirmation(algodClient, txId, 4);\n            console.log('Transaction confirmed in round', confirmedTxn['confirmed-round']);\n        } catch (err) {\n            console.log('Error submitting transaction:', err);\n        }\n    }\n    \n    submitTransaction();</code>\n    </pre>\n    \n    <h4>Steps:</h4>\n    <ol class=\"inText\">\n      <li>Import our necessary modules.</li>\n      <li>Define our AlgodClient to initiate a connection to the chain.</li>\n      <li>Define our account's address and private key that we will be sending transactions from.</li>\n      <li>Define an amount of Algorand to send.</li>\n      <li>Obtain the params needed for all transactions.</li>\n      <li>Generate a new account for testing, so we have an address to send testnet Algorand to.</li>\n      <li>Define our payment transaction and its parameters.</li>\n      <li>Sign the transaction with our private key.</li>\n      <li>Assign the result of sending our signed transaction with the sendTransaction() method from the AlgodClient class.</li>\n      <li>Use the waitForConfirmation() function to ensure the transaction is successful.</li>\n      <li>Print the transaction ID for reference on an explorer like allo.info, <a href=\"https://testnet.explorer.perawallet.app/\">https://testnet.explorer.perawallet.app/</a>, <a href=\"https://www.blockpack.app/#/explorer/home\">https://www.blockpack.app/#/explorer/home</a>, or <a href=\"https://app.dappflow.org/explorer/home\">https://app.dappflow.org/explorer/home</a>.</li>\n    </ol>\n    \n    <p>We introduce a few new functions here:</p>\n    <ul class=\"inText\">\n      <li>the algosToMicroalgos() function from the algosdk.util module.</li>\n      <li>the makePaymentTxnWithSuggestedParams() function and waitForConfirmation() function from the algosdk module.</li>\n      <li>The sendRawTransaction() function, which is a method from the AlgodClient class.</li>\n    </ul>\n    \n    <p>In the Algorand SDK, when we want to reference an amount of Algo, that amount needs to be in a format called \"MicroAlgo\"; MicroAlgo is essentially an amount of Algo times 1,000,000. Meaning that 1 Algo would be 1,000,000 MicroAlgo, and the transaction fee of 0.001 Algo is 1,000 MicroAlgo.</p>\n    \n    <p>Instead of manually calculating the MicroAlgo amount each time, what we can do is use the algosToMicroalgos() function, and pass in the amount of Algo as an argument.</p>\n    \n    <p>The makePaymentTxnWithSuggestedParams() function comes with a lot of functionality, aside from simple payment transactions of an amount of Algo to more advanced features, including:</p>\n    <ul class=\"inText\">\n      <li>the ability to rekey your account to another (giving them full access, and losing your access)</li>\n      <li>closing your account (send all of your remaining Algo to them)</li>\n    </ul>\n    \n    <p>PaymentTransaction format:</p>\n    <pre class=\"overflow-auto shadow-md\">\n    <code>function makePaymentTxnWithSuggestedParams(sender, receiver, amount, closeRemainderTo, note, suggestedParams, rekeyTo) {\n        // Returns a transaction object\n    }</code>\n    </pre>\n    \n    <p>After we define our Payment Transaction parameters, we can then use the signTransaction() method that is included within it. This sign function accepts our private key, and outputs a signed transaction object, which is needed to input to the sendRawTransaction() function.</p>\n    \n    <p>The waitForConfirmation() function requires the AlgodClient variable we created, as well as the transaction ID to wait for.</p>\n    \n    <p>Lastly, the sendRawTransaction() function, which accepts signed transaction objects and outputs the transaction ID.</p>\n    \n    <p>Below are examples of rekey transactions and close amount to transactions, which are sent in succession (BUT NOT A GROUP TRANSACTION, WHICH WE WILL LEARN ABOUT LATER).</p>\n    \n    <pre class=\"overflow-auto shadow-md\">\n    <code>// Repeat the process for the Rekey Transaction and the Close Remainder to Transaction\n    \n    // Rekey Transaction\n    const rekeyToNewAccountPayment = algosdk.makePaymentTxnWithSuggestedParams(\n        senderAddress,\n        newAccountAddress,\n        0,\n        undefined,\n        new TextEncoder().encode(\"Take care of my account for me! I'll be back in a week\"),\n        params,\n        newAccountAddress\n    );\n    \n    const signedRekeyToNewAccountPayment = rekeyToNewAccountPayment.signTxn(senderPrivateKey);\n    const rekeyTransactionID = await algodClient.sendRawTransaction(signedRekeyToNewAccountPayment).do();\n    await algosdk.waitForConfirmation(algodClient, rekeyTransactionID, 4);\n    console.log(rekeyTransactionID);\n    \n    // New account rekeys back to the original account\n    const rekeyBackToOldAccountFromNewAccount = algosdk.makePaymentTxnWithSuggestedParams(\n        newAccountAddress,\n        senderAddress,\n        0,\n        undefined,\n        new TextEncoder().encode(\"Sorry! I'm too busy trading this week. Maybe ask PorkChop.algo?\"),\n        params,\n        senderAddress\n    );\n    \n    const signedRekeyBackToOldAccountFromNewAccount = rekeyBackToOldAccountFromNewAccount.signTxn(newAccountPrivateKey);\n    const rekeyBackTransactionID = await algodClient.sendRawTransaction(signedRekeyBackToOldAccountFromNewAccount).do();\n    await algosdk.waitForConfirmation(algodClient, rekeyBackTransactionID, 4);\n    console.log(rekeyBackTransactionID);\n    \n    // Close Remainder to Transaction\n    const closeAccountToNewAccount = algosdk.makePaymentTxnWithSuggestedParams(\n        senderAddress,\n        newAccountAddress,\n        0,\n        newAccountAddress,\n        new TextEncoder().encode('Take care of my precious Algo!'),\n        params\n    );\n    \n    const signedCloseAccountToNewAccount = closeAccountToNewAccount.signTxn(senderPrivateKey);\n    const closeAccountTransactionID = await algodClient.sendRawTransaction(signedCloseAccountToNewAccount).do();\n    await algosdk.waitForConfirmation(algodClient, closeAccountTransactionID, 4);\n    console.log(closeAccountTransactionID);</code>\n    </pre>\n    \n    <p>DISCLAIMER: When rekeying and closing out accounts, this process is irreversible! If you don't know the person, or feel unsure about doing so, you should never use these transactions outside of testing purposes without ultimate confidence. No platforms currently utilize rekey transactions for users, but do use them internally when generating smart contracts for contract-to-contract calls, which will come later in our learning process.</p>\n    \n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What function is used to create a new Algorand account in the algosdk library?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"correct\">a) algosdk.generateAccount()</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) algosdk.createAccount()</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) algosdk.newAccount()</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) algosdk.accountCreate()</label><br>\n  \n          <h3>Question 2</h3>\n          <p>How can you obtain the mnemonic phrase from a private key in the algosdk library?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) algosdk.secretKeyToMnemonic()</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) algosdk.privateKeyToMnemonic()</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) algosdk.mnemonicFromPrivateKey()</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) algosdk.mnemonicConvert()</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What are the minimum balance and transaction fee requirements for Algorand accounts?</p>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) 0.5 Algo and 0.01 Algo per transaction</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) 0.01 Algo and 0.001 Algo per transaction</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"correct\">c) 0.1 Algo and 0.001 Algo per transaction</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) 1 Algo and 0.1 Algo per transaction</label><br>\n  \n          <h3>Question 4</h3>\n          <p>Which method is used to send a signed transaction in the Algorand SDK?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) algodClient.sendRawTransaction()</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) algodClient.sendTransaction()</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) algodClient.submitTransaction()</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) algodClient.sendSignedTransaction()</label><br>\n  \n          \n      </form>\n    \n    ",
    "initialCode": "const algosdk = require('algosdk');\n\n// Mnemonic phrase\nconst mnemonic = 'brown repeat amazing april survey fish gospel brown bless core deny plate admit burden pistol device shuffle sadness genius answer hurt analyst foot above annual';\n\n// Recover account using the mnemonic\nconst recoveredAccount = algosdk.mnemonicToSecretKey(mnemonic);\nconsole.log('Recovered Private Key:', Buffer.from(recoveredAccount.sk).toString('base64')); // Output Private Key\nconsole.log('Recovered Address:', recoveredAccount.addr); // Output Address\n\n  "
  },
  {
    "id": 11,
    "language": "GO",
    "title": "Variables",
    "content": "\n    <p>In Go, we have several data types that are used to store different kinds of information:</p>\n    <ul class=inText>\n        <li>Integer: Represents whole numbers without a decimal component.</li>\n        <li>String: A sequence of characters enclosed within quotes.</li>\n        <li>Float: Represents numbers that contain a decimal point.</li>\n        <li>Boolean: Represents one of two values, true or false.</li>\n        <li>List: An ordered collection of items, here using an interface{} to allow any type.</li>\n        <li>Dictionary: A collection of key-value pairs where keys are strings and values are any type.</li>\n    </ul>\n    \n    <p>It's good practice to name your variable relevant to its purpose, and use camelCase for naming conventions. Variable names cannot start with a number, include special characters other than '_', or contain spaces.</p>\n    \n    <p>Here are some more variable examples:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>var (\n    itemCost        int     = 1     // The cost of an item, which will be 1 dollar\n    supplyRemaining int64   = 2500000000 // The number of items in inventory that are remaining\n    nameCTO         string  = \"John Woods\" // Name of a CTO\n    valueOfAQuarter float64 = 0.25  // The value of a quarter in dollars\n)</code></pre>\n    \n    <p>There are several arithmetic operators available in Go, and they are as follows:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>a := 10\nb := 3\naddition := a + b\nsubtraction := a - b\nmultiplication := a * b\ndivision := myFloat / float64(b)\nfloorDivision := a / b\nmodulus := a % b\nexponentiation := math.Pow(float64(a), float64(b))</code></pre>\n    \n    <p>Similar to integers and floats, you can also use arithmetic operators on strings:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>result := myText + \" World!\"\nfmt.Println(\"Concatenated String:\", result)\nrepeatedString := strings.Repeat(myText, 3)\nfmt.Println(\"Repeated String:\", repeatedString)</code></pre>\n    \n    <p>We won't dive into Lists, Dictionaries, or Tuples just yet, but I would like to mention, and this is something you'll see in practice later— that lists and dictionaries are mutable, whereas tuples are immutable.\n    When you hear mutable, think \"can be changed\", where mutable means it can be changed and immutable means it cannot be changed.</p>\n    \n    <p>Example:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>my_tuple = (1, 2)\nprint(my_tuple[0])\nmy_tuple[0] = 2\nprint(my_tuple)\n# ERROR\n#    my_tuple[0] = 2\n#    ~~~~~~~~^^^\n# TypeError: 'tuple' object does not support item assignment\n</code></pre>\n    \n    <p>A more advanced concept to start early with, but another thing we will review later:</p>\n    <h2>Examples of mutable and immutable parameters on an asset on Algorand</h2>\n    <strong>Immutable Parameters:</strong></br>\n    <p>These parameters can only be specified when an asset is created.</p>\n    <ul class=inText>\n    <li>Creator: The address of the account that created the asset.</li>\n    <li>AssetName: The name of the asset.</li>\n    <li>UnitName: The unit name of the asset.</li>\n    <li>Total: The total number of units of the asset.</li>\n    <li>Decimals: The number of digits to use after the decimal point when displaying the asset.</li>\n    <li>DefaultFrozen: Whether the asset is frozen by default.</li>\n    <li>URL: A URL where more information about the asset can be retrieved.</li>\n    <li>MetaDataHash: A commitment to some unspecified asset metadata.</li>\n    </ul>\n    <strong>Mutable Parameters:</strong></br>\n    <p>These parameters can be changed after the asset is created.</p>\n    <ul class=inText>\n    <li>Manager: The address of the account that can change the asset's mutable parameters.</li>\n    <li>Reserve: The address of the account that holds the asset reserve. (Cannot be changed if initially not declared)</li>\n    <li>Freeze: The address of the account that can freeze or unfreeze user asset holdings. (Cannot be changed if initially not declared)</li>\n    <li>Clawback: The address of the account that can revoke user asset holdings and send them to other addresses. (Cannot be changed if initially not declared)</li>\n    </ul>\n    <em>*Note: Exception for various ARC types like ARC19 and ARC69 that use the reserve address and/or note field to point to metadata*</em>\n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>Which of the following correctly declares a variable in Go?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"incorrect\">a) var itemCost = 1 int</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"correct\">b) var itemCost int = 1</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) itemCost := int 1</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) int itemCost = 1</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which of the following variable names is valid in Go?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"incorrect\">a) 3variable</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) my-variable</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"correct\">c) itemCost</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) my variable</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the result of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>a := 10\nb := 3\naddition := a + b\nfmt.Println(addition)</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) 13</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"correct\">b) 13</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) 7</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) 30</label><br>\n  \n          <h3>Question 4</h3>\n          <p>How do you perform exponentiation in Go?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"incorrect\">a) a ^ b</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"correct\">b) math.Pow(float64(a), float64(b))</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) a ** b</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) pow(a, b)</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc main() {\n\t// Variables\n\tname := \"Alice\"\n\tage := 25\n\theight := 5.6\n\tisStudent := true\n\n\tfmt.Println(\"Name:\", name, \"Age:\", age, \"Height:\", height, \"Is Student:\", isStudent)\n\n\t// Arithmetic\n\ta, b := 10, 3\n\tfmt.Println(\"Sum:\", a+b, \"Product:\", a*b, \"Power:\", math.Pow(float64(a), float64(b)))\n\n\t// Strings\n\tgreeting := \"Hello\"\n\tfmt.Println(greeting + \", \" + name + \"!\")\n}\n"
  },
  {
    "id": 12,
    "language": "GO",
    "title": "Functions",
    "content": "\n    <p>In Go, a function is a block of code that performs a specific task. Functions help to modularize code, making it more readable and reusable.</p>\n    <p>To define a function, we use the <code>func</code> keyword followed by the function name and parentheses. Inside the parentheses, we can specify parameters that the function can accept. The code block within every function starts with a curly brace ({) and ends with a curly brace (}).</p>\n    \n    <p>Let's start with a simple function that prints a greeting message:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>func greet() {\n    fmt.Println(\"Hello, world!\");\n}\nfunc main() {\n    greet();\n// Output: \"Hello, world!\"</code></pre>\n\n<p>Functions can also accept parameters, which allow us to pass values into the function for processing. Here's an example:</p>\n<pre class=\"overflow-auto shadow-md\">func greetWithName(name string) {\n    fmt.Printf(\"Hello, %s!\n\", name);\n}\ngreetWithName(\"Alice\"); // Output: \"Hello, Alice!\"\ngreetWithName(\"Bob\");   // Output: \"Hello, Bob!\"</code></pre>\n    \n    <p>Functions can return values using the <code>return</code> statement. This allows us to capture the result of a function and use it in our code. Here's an example:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>func add(a, b int) int {\n    return a + b;\n}\nlet result = add(3, 5);\nfmt.Println(result); // Output: 8</code></pre>\n    \n    <p>Functions can have default parameter values, which are used if no argument is provided when the function is called. Here's an example:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>func greetWithDefaultName(name string) {\n    if name == \"\" {\n        name = \"world\";\n    }\n    fmt.Printf(\"Hello, %s!\n\", name);\n}\ngreetWithDefaultName(\"\");  // Output: Hello, world!\ngreetWithDefaultName(\"Alice\");  // Output: Hello, Alice!</code></pre>\n    \n    <p>We can also define functions that accept a variable number of arguments using the <code>...</code> syntax. Here's an example:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>func addMultiple(nums ...int) int {\n    sum := 0;\n    for _, num := range nums {\n        sum += num;\n    }\n    return sum;\n}\nfmt.Println(addMultiple(1, 2, 3)); // Output: 6\nfmt.Println(addMultiple(4, 5, 6, 7)); // Output: 22</code></pre>\n    \n    <p>The <code>...</code> syntax allows us to accept a variable number of arguments. Here's an example using a map for keyword arguments:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>func printInfo(info map[string]interface{}) {\n    for key, value := range info {\n        fmt.Printf(\"%s: %v\n\", key, value);\n    }\n}\nprintInfo(map[string]interface{}{\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"});</code></pre>\n\n<p>Functions are a fundamental part of Go programming, enabling us to create modular, reusable, and maintainable code. As we progress, we'll explore more advanced concepts and techniques related to functions.</p>\n\n  <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What keyword is used to define a function in Go?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"correct\">a) func</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) function</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) def</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) fn</label><br>\n  \n          <h3>Question 2</h3>\n          <p>How do you define a function in Go that accepts a parameter?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) func greetWithName(name string) { ... }</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) func greetWithName(string name) { ... }</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) func greetWithName(name: string) { ... }</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) func greetWithName(name) string { ... }</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the result of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\">\n  func add(a, b int) int {\n      return a + b\n  }\n  result := add(3, 5)\n  fmt.Println(result)\n</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"correct\">a) 8</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) 35</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) 15</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) 3</label><br>\n  \n          <h3>Question 4</h3>\n          <p>How do you define a function in Go that accepts a variable number of arguments?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) func addMultiple(nums ...int) { ... }</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) func addMultiple(nums int...) { ... }</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) func addMultiple(...nums int) { ... }</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) func addMultiple(nums: int...) { ... }</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "package main\n\nimport \"fmt\"\n\n// Simple function\nfunc greet(name string) {\n    fmt.Printf(\"Hello, %s!\n\", name)\n}\n\n// Function with return value\nfunc add(a, b int) int {\n    return a + b\n}\n\nfunc main() {\n    greet(\"Alice\")          // Output: Hello, Alice!\n    result := add(3, 5)     // Adds 3 and 5\n    fmt.Println(\"Sum:\", result) // Output: Sum: 8\n}\n"
  },
  {
    "id": 13,
    "language": "GO",
    "title": "Slices",
    "content": "\n    <p>Before we go over structs, which are the most common data type when sending and receiving information between applications (back-end to front-end, front-end to back-end, or back-end to websites, etc.), and this is especially true when interacting with the Algorand blockchain, I think it's important to have an understanding of how slices work.</p>\n    \n    <p>Below is an example of a slice:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>var mySlice = []interface{}{7, \"Hello\", false, 63.5}</code></pre>\n    \n    <p>A slice can hold all types of data, and you can have all kinds of data in one slice. You use slices when you need exactly that, a list. Slices are also mutable, which means we can rearrange, extend, and replace items in a slice, meaning they're super flexible!</p>\n    \n    <p>A slice is a collection of data enclosed between square brackets [ ], and separated by commas. An example of common kinds of data you would have in a slice on Algorand could be one that has asset IDs.</p>\n    <pre class=\"overflow-auto shadow-md\">var assetIDs = []int{1265975021, 1138500612, 400593267}</code></pre>\n    \n    <p>Or perhaps a slice of addresses:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>var addresses = [\n\"WWYUMYPM2Y5NIIZTF4O5N73A4ZTZQWXS6TNP23U37LQ6WWF543SRTGKWUU\",\n\"7IWZ342UGNQ2JVS2E6EGFD4MPUNL4ZIWDYNFZIANR6U7WZXORCRQCCN3YY\",\n\"HZ57J3K46JIJXILONBBZOHX6BKPXEM2VVXNRFSUED6DKFD5ZD24PMJ3MVA\"];</code></pre>\n    \n    <p>Although slices don't have to be organized in any way and are not descriptive, they can be manipulated. For example, if you wanted to remove duplicate entries in a slice, you could use a map to achieve this.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>func removeDuplicates(elements []int) []int {\n    encountered := map[int]bool{};\n    result := []int{};\n    for v := range elements {\n        if encountered[elements[v]] != true {\n            encountered[elements[v]] = true;\n            result = append(result, elements[v]);\n        }\n    }\n    return result;\n}\nmySlice := []int{1, 1, 2, 3, 4, 4};\nmySliceWithoutDuplicates := removeDuplicates(mySlice);\nfmt.Println(mySliceWithoutDuplicates);\n# Output: [1, 2, 3, 4]</code></pre>\n    \n    <p>Let's look back at the first example of a slice:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>mySlice = []interface{}{7, \"Hello\", false, 63.5}</code></pre>\n    \n    <p>In the slice above we have an integer at the first spot, 7; a string in the second spot, \"Hello\"; a boolean (true or false value) in the third spot; a float (decimal value), in the fourth spot.\n    I refer to the places these items are in the slice as \"spots\", but the correct term is actually \"indexes\". We referenced them as the first, second, third, and fourth spot— however, in programming slices are zero-indexed. This means that we always start from zero, and use an integer to refer to their position in the slice. This feels strange, but it is something you should have ingrained into your mind, as this is universal across all programming when indexing for positions in a slice.</p>\n    \n    <p>The correct reference to the positions would be Index 0 for 7, Index 1 for \"Hello\", Index 2 for false, and Index 3 for 63.5. But, how would we see this utilized in a programming scenario?</p>\n    \n    <p>To interact with the slice, we must first assign it to a variable:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>mySlice2 := []interface{}{7, \"Hello\", false, 63.5};\nfmt.Println(mySlice2);\n# Output: [7, \"Hello\", false, 63.5]</code></pre>\n    \n    <p>... and now let's log the item at index 1 (the second item since the first item is always 0) using index notation:</p>\n    <pre class=\"overflow-auto shadow-md\">let firstIndexMySlice = mySlice2[1];\nconsole.log(firstIndexMySlice);\n# Output: \"Hello\"</code></pre>\n    \n    <p>Try logging the third index into the console using index notation. I've already defined the slice for you below. Click run when you're ready to run the code! The output should be 63.5.</p>\n    \n    <pre><code>mySlice3 := []interface{}{7, \"Hello\", false, 63.5};\nthirdIndexMySlice := mySlice3[3];\nfmt.Println(thirdIndexMySlice);\n# Output: 63.5</code></pre>\n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What is a slice in Go?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"correct\">a) A mutable, ordered collection of elements</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) An immutable, ordered collection of elements</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) A mutable, unordered collection of elements</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) An immutable, unordered collection of elements</label><br>\n  \n          <h3>Question 2</h3>\n          <p>How do you declare a slice in Go that can hold different types of data?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) var mySlice = []interface{}{7, \"Hello\", false, 63.5}</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) var mySlice = []{7, \"Hello\", false, 63.5}</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) var mySlice = [7, \"Hello\", false, 63.5]</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) var mySlice = {7, \"Hello\", false, 63.5}</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the result of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>mySlice := []interface{}{7, \"Hello\", false, 63.5}\nfmt.Println(mySlice[1])\n</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) 7</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"correct\">b) \"Hello\"</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) false</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) 63.5</label><br>\n  \n          <h3>Question 4</h3>\n          <p>How do you remove duplicate entries from a slice in Go?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>func removeDuplicates(elements []int) []int {\n    encountered := map[int]bool{}\n    result := []int{}\n    for v := range elements {\n        if !encountered[elements[v]] {\n            encountered[elements[v]] = true\n            result = append(result, elements[v])\n        }\n    }\n    return result\n}\nmySlice := []int{1, 1, 2, 3, 4, 4}\nmySliceWithoutDuplicates := removeDuplicates(mySlice)\nfmt.Println(mySliceWithoutDuplicates)\n</code></pre>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) Using a map to track encountered elements</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) Using a set to track encountered elements</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) Using a list to track encountered elements</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) Using a dictionary to track encountered elements</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "package main\n\nimport \"fmt\"\n\nfunc main() {\n    // Define a slice\n    mySlice := []interface{}{7, \"Hello\", false, 63.5}\n\n    // Print the entire slice\n    fmt.Println(\"Slice:\", mySlice)\n\n    // Access and print specific elements by index\n    fmt.Println(\"Index 1:\", mySlice[1]) // Output: \"Hello\"\n    fmt.Println(\"Index 3:\", mySlice[3]) // Output: 63.5\n}\n"
  },
  {
    "id": 14,
    "language": "GO",
    "title": "Structs",
    "content": "\n    <p>Now we'll dive into a bit more advanced data structures, structs! A struct is like a slice, except it uses curly brackets { } instead of square brackets [ ]— but most importantly, structs also differ in that they store values with keys (called fields), and can accept several data types. A struct can be highly versatile and can not only be used for data storage, but for more complex algorithms like hashmaps, which we'll go over later. Most interestingly, we can have structs with nested structs within them, and even slices as well! It's important to mention that fields and values have a colon ' : ' separator between them.</p>\n    \n    <p>Here's a simple example of a struct:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>type Person struct {\n    Name string\n    Age  int\n}\nthisIsMyStruct := Person{Name: \"John\", Age: 22}</code></pre>\n    \n    <p>In slices, we used a process called indexing, and the index notation format to access values, e.g.; mySlice[3]. With structs, we use a similar process called field access, and the field notation format to access values.</p>\n    \n    <p>The main difference is that we use fields, instead of solely integers that refer to position, to select values from a struct— and not to confuse you, but a field in a struct can also be an integer =).</p>\n    \n    <p>For example, in thisIsMyStruct above, you'll see the value \"John\" belongs to the field, \"Name\". As well as the value 22, belongs to the field, \"Age\". This is what field notation would look like for accessing a value for a specific field in a struct:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>nameValue := thisIsMyStruct.Name\nfmt.Println(nameValue)\n# Output: \"John\"</code></pre>\n    \n    <p>Try printing the \"Age\" value in the code editor below:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>ageValue := thisIsMyStruct.Age\nfmt.Println(ageValue)\n# Output: 22</code></pre>\n    \n    <p>Now we'll look over a more intricate struct, that's a bit larger and complex.</p>\n    <pre class=\"overflow-auto shadow-md\"><code>type PersonWithLikes struct {\n    Name  string\n    Age   int\n    Likes []string\n}\nthisIsMyStructWithLikes := PersonWithLikes{\n    Name:  \"John\",\n    Age:   22,\n    Likes: []string{\"Exercise\", \"Cooking\", \"Coding\"},\n}</code></pre>\n    \n    <p>We see something in this struct that we haven't seen before, a slice as the value to a field. Let's try accessing the 1st index of John's likes using a mix of field notation and index notation!</p>\n    <pre class=\"overflow-auto shadow-md\"><code>likes := thisIsMyStructWithLikes.Likes\nfmt.Println(likes)\n# Output: [\"Exercise\", \"Cooking\", \"Coding\"]</code></pre>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>likesFirstIndex := likes[1]\nfmt.Println(likesFirstIndex)\n# Output: \"Cooking\"</code></pre>\n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What is a struct in Go?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"correct\">a) A collection of fields that can hold different data types</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) A collection of ordered elements of the same type</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) A function that returns multiple values</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) A type that defines methods</label><br>\n  \n          <h3>Question 2</h3>\n          <p>How do you declare a struct in Go with the fields \"Name\" (string) and \"Age\" (int)?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) type Person struct { Name string; Age int }</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) type Person { string Name; int Age }</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) struct Person { Name: string, Age: int }</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) struct Person { string Name; int Age }</label><br>\n  \n          <h3>Question 3</h3>\n          <p>What will be the result of the following code?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>type Person struct {\n    Name string\n    Age  int\n}\n  thisIsMyStruct := Person{Name: \"John\", Age: 22}\n  fmt.Println(thisIsMyStruct.Name)\n</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"correct\">a) \"John\"</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) 22</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) \"Age\"</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) \"Person\"</label><br>\n  \n          <h3>Question 4</h3>\n          <p>How do you access the first element of the \"Likes\" slice in the following struct?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>type PersonWithLikes struct {\n    Name  string\n    Age   int\n    Likes []string\n}\nthisIsMyStructWithLikes := PersonWithLikes{\n    Name: \"John\",\n    Age:  22,\n    Likes: []string{\"Exercise\", \"Cooking\", \"Coding\"},\n}\nfmt.Println(thisIsMyStructWithLikes.Likes[0])\n</code></pre>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) \"Exercise\"</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) \"Cooking\"</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) \"Coding\"</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) \"Likes\"</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "package main\n\nimport \"fmt\"\n\n// Define a struct\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    // Create a struct instance\n    thisIsMyStruct := Person{Name: \"John\", Age: 22}\n\n    // Access and print struct fields\n    fmt.Println(\"Name:\", thisIsMyStruct.Name) // Output: John\n    fmt.Println(\"Age:\", thisIsMyStruct.Age)   // Output: 22\n}\n"
  },
  {
    "id": 15,
    "language": "GO",
    "title": "Imports",
    "content": "\n    <p>This code begins with package imports, which is a fancy way of saying— \"someone wrote some code that does something, and I want to use that something in my code\". It isn't possible to use libraries, which are just collections of code created by someone, without formally importing them at the beginning of your code. Imports must appear before usage of anything within them because like the English language, Go interpreters read from top to bottom.</p>\n    \n    <p>The package imports are from the Go Algorand SDK library and the standard library.</p>\n    \n    <p>Now let's get the status of the Algod client:</p>\n<pre class=\"overflow-auto shadow-md\"><code>import (\n    \"fmt\"\n    \"log\"\n    \"math/rand\"\n    \"strings\"\n    \"time\"\n    \"github.com/algorand/go-algorand-sdk/client/v2/algod\"\n    \"github.com/algorand/go-algorand-sdk/client/v2/common\"\n)\nfunc main() {\n    var algodAddress = \"http://localhost:4001\";\n    var algodToken = strings.Repeat(\"a\", 64);\n    algodClient, err := algod.MakeClient(algodAddress, algodToken);\n    if err != nil {\n        log.Fatalf(\"failed to make algod client: %v\", err);\n    }\n    status, err := algodClient.Status().Do();\n    if err != nil {\n        log.Fatalf(\"failed to get status: %v\", err);\n    }\n    fmt.Printf(\"Status: %+v\n\", status);\n    rand.Seed(time.Now().UnixNano());\n    randomNumber := rand.Intn(101);\n    fmt.Println(randomNumber);\n}</code></pre>\n\n    <p>The imports are:</p>\n    <ul class=inText>\n        <li>\"fmt\" for formatting and printing output.</li>\n        <li>\"log\" for logging errors.</li>\n        <li>\"math/rand\" for generating random numbers.</li>\n        <li>\"strings\" for creating repeated strings.</li>\n        <li>\"time\" for seeding the random number generator.</li>\n        <li>\"github.com/algorand/go-algorand-sdk/client/v2/algod\" for the Algod client.</li>\n        <li>\"github.com/algorand/go-algorand-sdk/client/v2/common\" for common headers.</li>\n    </ul>\n    \n    <p>The Go Algorand SDK library is imported with specific paths to the required packages. This is similar to how we imported specific modules in Python.</p>\n    \n    <p>To install the Algorand Go SDK, you can use the following command:</p>\n    <pre class=\"overflow-auto shadow-md\"><code>go get -u github.com/algorand/go-algorand-sdk/...</code></pre>\n    \n    <p>If you don't have Go installed, it must be installed manually, which is detailed in the Go installation guide on their website.</p>\n    \n    <p>We use the rand.Seed(time.Now().UnixNano()) to seed the random number generator with the current time. This ensures that we get different random numbers each time the program runs.</p>\n    ",
    "initialCode": "package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    // Seed the random number generator\n    rand.Seed(time.Now().UnixNano())\n\n    // Generate and print a random number between 0 and 100\n    randomNumber := rand.Intn(101)\n    fmt.Println(\"Random Number:\", randomNumber)\n}\n"
  },
  {
    "id": 18,
    "language": "GO",
    "title": "Getting Started with Algorand",
    "content": "\n\n    <p>To set up your own node, visit this GitHub repository for a previous tutorial series: \n    <a href=\"https://github.com/atsoc1993/Algorand_Discord_Bots_Tutorial_Series/tree/main/Episode%201%20-%20Algorand%20Node%2C%20Python%2C%20Visual%20Studio%20Code%2C%20Ubuntu%2C%20and%20Module%20Installations\">https://github.com/atsoc1993/Algorand_Discord_Bots_Tutorial_Series/</a>\n    </p>\n    <p>Scroll down to the section called \"Algorand Node Installation\" — and make sure to run these commands in an Ubuntu LTS Shell (Download link in bottom resources section)\n    If you chose to run a node, that's wonderful! If not, I will be including sections for those programming without a node.</p>\n    \n    <p>If you are trying to run this code natively on your computer, and not in this browser:\n\n    Make sure you have GO installed: \n    <a href=\"https://go.dev/dl/\">https://go.dev/dl/</a>\n    </p>\n\n    \n    \n    \n    \n    Initialize your project by using the following command in the terminal:\n\n    <pre class=\"overflow-auto shadow-md\"><code>'go mod init algolearn'</code></pre>\n    \n    Ensure that the name of the file ends with '.go', and that you've installed the go algorand SDK afterwards using the following command in the IDE terminal:\n    \n    go get github.com/algorand/go-algorand-sdk/...\n    \n    You can copy and paste the code below into your yourFileName.go file, and use 'go run yourFileName.go' in the terminal to run it!\n    */\n   <pre class=\"overflow-auto shadow-md\"><code>package main\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    \"github.com/algorand/go-algorand-sdk/client/v2/algod\"\n)\n\nfunc main() {\n    // Variables for Algorand testnet node access\n    algodToken := \"\" // Leave empty for public node service, or enter your node token\n    algodServer := \"https://testnet-api.algonode.cloud\"\n\n    // Create an algod client\n    algodClient, err := algod.MakeClient(algodServer, algodToken)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to make algod client: %s\\n\", err)\n        return\n    }\n\n    // Fetch the node status and print it\n    status, err := algodClient.Status().Do(context.Background())\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to get node status: %s\\n\", err)\n        return\n    }\n\n    fmt.Printf(\"Node status: %+v\\n\", status)\n}</code></pre>\n    \n    <p>First, we import the necessary Go packages, including <code>context</code> for API call management, <code>fmt</code> for formatted output, and <code>os</code> for system-level operations. We also import <code>algod</code> from the Algorand SDK, which allows us to interact with the Algorand blockchain.</p>\n    \n    <p>Next, we set up variables for the token and server URL for the Algorand testnet node. These are initialized to work with a public node service, but can be customized for a private node by specifying a token.</p>\n    \n    <p>We then attempt to create an <code>algodClient</code> using the <code>MakeClient</code> function, passing in our server URL and token. This function returns an <code>algodClient</code> object and an error. If an error occurs during client creation, it is handled immediately by printing an error message and exiting the function.</p>\n    \n    <p>Using the created <code>algodClient</code>, we proceed to fetch the current node status. This is done by calling the <code>Status</code> method followed by <code>Do</code>, passing in a context to manage the request. If an error occurs, it is caught and printed, similar to the client creation step.</p>\n    \n    <p>If the status fetch is successful, we print the complete status object to the console to inspect its contents. Additionally, we access and print the <code>LastRound</code> information from the status object, which represents the most recent round of the Algorand consensus protocol.</p>\n    \n    <p>Print statement formatting:</p>\n    <ul class=\"inText\">\n        <li><code>%+v</code>: This format specifier in <code>fmt.Printf</code> is used for printing structs or composite values in Go. The <code>+</code> flag adds field names to the output, making it very useful for debugging by showing both the field names and their values. In your code, it's used to display the complete status of the Algorand node, providing a detailed look at all its properties.</li>\n        <li><code>%d</code>: This is used to format integers. In your code, it prints the value of <code>lastRound</code>, which is an integer representing the latest round number of the blockchain network. This specifier ensures that the number is printed as a base-10 decimal.</li>\n    </ul>\n    \n    <p>Try running the code now!</p>\n    \n    <p>You'll see that you receive a dictionary with several keys and associated values, here is a list of all the keys:</p>\n    \n    <ul class=\"inText\">\n      <li>catchpoint</li>\n      <li>catchpoint-acquired-blocks</li>\n      <li>catchpoint-processed-accounts</li>\n      <li>catchpoint-processed-kvs</li>\n      <li>catchpoint-total-accounts</li>\n      <li>catchpoint-total-blocks</li>\n      <li>catchpoint-total-kvs</li>\n      <li>catchpoint-verified-accounts</li>\n      <li>catchpoint-verified-kvs</li>\n      <li>catchup-time</li>\n      <li>last-catchpoint</li>\n      <li>last-round</li>\n      <li>last-version</li>\n      <li>next-version</li>\n      <li>next-version-round</li>\n      <li>next-version-supported</li>\n      <li>stopped-at-unsupported-round</li>\n      <li>time-since-last-round</li>\n    </ul>\n    \n    <p>The most popular keys are <code>last-round</code>, so you know which block you are on, and perhaps <code>time-since-last-round</code>, if you should need to know that information. Other keys are primarily used by node running services, like upcoming reti-pool incentives, but otherwise are not especially useful for our purposes.</p>\n    \n    <p>Referencing the information from Chapter 4, for Structs, try this:</p>\n    <ul class=\"inText\">\n      <li>Create a variable, and name it <code>lastRound</code></li>\n      <li>Assign the value of the key <code>'last-round'</code> in the status dictionary to this variable you created</li>\n      <li>Print your variable!</li>\n    </ul>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n\n    \"github.com/algorand/go-algorand-sdk/client/v2/algod\"\n)\n\nfunc main() {\n    // Variables for Algorand testnet node access\n    algodToken := \"\" // Leave empty for public node service, or enter your node token\n    algodServer := \"https://testnet-api.algonode.cloud\"\n\n    // Create an algod client\n    algodClient, err := algod.MakeClient(algodServer, algodToken)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to make algod client: %s\\n\", err)\n        return\n    }\n\n    // Fetch the node status and print it\n    status, err := algodClient.Status().Do(context.Background())\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to get node status: %s\\n\", err)\n        return\n    }\n\n    // CREATE LAST ROUND VARIABLE AND PRINT THE LAST ROUND HERE\n\n}</code></pre>\n    \n    <p><strong>Reveal Answer:</strong></p>\n    \n    <pre class=\"overflow-auto shadow-md\">\n<code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"os\"\n    \"github.com/algorand/go-algorand-sdk/client/v2/algod\"\n)\n\nfunc main() {\n    // Variables for Algorand testnet node access\n    algodToken := \"\" // Leave empty for public node service, or enter your node token\n    algodServer := \"https://testnet-api.algonode.cloud\"\n\n    // Create an algod client\n    algodClient, err := algod.MakeClient(algodServer, algodToken)\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to make algod client: %s\\n\", err)\n        return\n    }\n\n    // Fetch the node status and print it\n    status, err := algodClient.Status().Do(context.Background())\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"Failed to get node status: %s\\n\", err)\n        return\n    }\n\n    // Access last round status information\n    lastRound := status.LastRound\n    fmt.Printf(\"Last round: %d\\n\", lastRound)\n}</code></pre>\n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What is the correct way to create an Algorand client in Go?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"correct\">a) algodClient, err := algod.MakeClient(algodServer, algodToken)</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) algodClient, err := algod.NewClient(algodServer, algodToken)</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) algodClient, err := algod.InitClient(algodServer, algodToken)</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) algodClient, err := algod.CreateClient(algodServer, algodToken)</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which package needs to be imported to use the Algorand SDK in Go?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) github.com/algorand/go-algorand-sdk/client/v2/algod</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) github.com/algorand/go-algorand/client/v2/algod</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) github.com/algorand/go-algorand-sdk/algod</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) github.com/algorand/sdk-go/client/v2/algod</label><br>\n  \n          <h3>Question 3</h3>\n          <p>How do you fetch the status of an Algorand node in Go?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>algodClient, err := algod.MakeClient(algodServer, algodToken)\nif err != nil {\n    fmt.Fprintf(os.Stderr, \"Failed to make algod client: %s\n\", err)\n    return\n}\n</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"incorrect\">a) status, err := algodClient.NodeStatus().Do(context.Background())</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) status, err := algodClient.GetStatus().Do(context.Background())</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"correct\">c) status, err := algodClient.Status().Do(context.Background())</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) status, err := algodClient.FetchStatus().Do(context.Background())</label><br>\n  \n          <h3>Question 4</h3>\n          <p>How do you access the last round from the status response in Go?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>status, err := algodClient.Status().Do(context.Background())\nif err != nil {\n    fmt.Fprintf(os.Stderr, \"Failed to get node status: %s\n\", err)\n    return\n}\n</code></pre>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) lastRound := status.LastRound</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) lastRound := status[\"last-round\"]</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) lastRound := status.Last-Round</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) lastRound := status.GetLastRound()</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/algorand/go-algorand-sdk/client/v2/algod\"\n)\n\nfunc main() {\n\t// Algorand testnet node information\n\talgodToken := \"\" // Public node access\n\talgodServer := \"https://testnet-api.algonode.cloud\"\n\n\t// Create an algod client\n\talgodClient, err := algod.MakeClient(algodServer, algodToken)\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to create algod client: %s\n\", err)\n\t\treturn\n\t}\n\n\t// Fetch and print node status\n\tstatus, err := algodClient.Status().Do(context.Background())\n\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"Failed to fetch node status: %s\n\", err)\n\t\treturn\n\t}\n\n\t// Access and print the last round\n\tfmt.Printf(\"Last round: %d\n\", status.LastRound)\n}\n    "
  },
  {
    "id": 19,
    "language": "GO",
    "title": "Payment Transactions",
    "content": "\n    <pre class=\"overflow-auto shadow-md\"><code>package main\n\nimport (\n    \"fmt\"\n    \"github.com/algorand/go-algorand-sdk/crypto\"\n    \"github.com/algorand/go-algorand-sdk/mnemonic\"\n)\n\nfunc main() {\n    // METHOD 1: Create a New Account\n    newAccount := crypto.GenerateAccount()\n    fmt.Printf(\"Private Key: %s\\n\", newAccount.PrivateKey)\n    fmt.Printf(\"Address: %s\\n\", newAccount.Address.String())\n\n    // Convert Private Key to Mnemonic\n    mnemo, err := mnemonic.FromPrivateKey(newAccount.PrivateKey)\n    if err != nil {\n        fmt.Printf(\"Error converting private key to mnemonic: %s\\n\", err)\n        return\n    }\n    fmt.Println(\"Mnemonic:\", mnemo)\n\n    // METHOD 2: Use Mnemonic to Obtain Private Key\n    // Assuming mnemonicPhrase is obtained securely and already exists\n    mnemonicPhrase := \"brown repeat amazing april survey fish gospel brown bless core deny plate admit burden pistol device shuffle sadness genius answer hurt analyst foot above annual\"\n    privKey, err := mnemonic.ToPrivateKey(mnemonicPhrase)\n    if err != nil {\n        fmt.Printf(\"Error retrieving private key from mnemonic: %s\\n\", err)\n        return\n    }\n    fmt.Printf(\"Private Key from Mnemonic: %s\\n\", privKey)\n}</code></pre>\n    \n    <p>When developing in Go with the Algorand SDK, there are two primary methods for obtaining a private key and address which are necessary for signing transactions. The private key is typically managed in byte slice format and is essential for the creation and signing of transactions.</p>\n    \n    <p>Method 1: Create a New Account and Obtain the Private Key and Address Directly</p>\n    <p>In the Algorand Go SDK, you use the <code>crypto.GenerateAccount()</code> function to generate a new account. This function returns an account object that contains both the private key and the address, not in a tuple like Python, but directly accessible via the account object properties. Once you have this account, you can print the private key and the address. These details can then be used to sign transactions or manage Algorand assets.</p>\n    \n    <p>After generating a new account, you can fund it by sending Algos to the generated address. This can be done through the Algorand dispenser for testnet, which is available at <a href=\"https://bank.testnet.algorand.network/\">https://bank.testnet.algorand.network/</a>. Remember that all accounts require a minimum balance of 0.1 Algo to remain active, and each transaction typically costs a fee of 0.001 Algo.</p>\n    \n    <p>For wallet applications, if you need to derive the mnemonic from the private key, you can use the <code>mnemonic.FromPrivateKey()</code> function provided by the Go SDK. This function converts the private key into a human-readable mnemonic phrase.</p>\n    \n    <p>Method 2: Convert an Existing Mnemonic to a Private Key</p>\n    <p>If you already possess a mnemonic and need to derive the corresponding private key, you can utilize the <code>mnemonic.ToPrivateKey(mnemonic string)</code> function. This function takes a string mnemonic and returns the corresponding private key. It is crucial to ensure that the mnemonic is correctly formatted, enclosed in quotes, and that it includes spaces between the words as expected in standard mnemonic phrases.</p>\n    \n    <p>Using the Account for Transactions</p>\n    <p>Once you have an account with funds, you can use the <code>AlgodClient</code> to initiate a connection to the Algorand blockchain. This setup allows you to interact with the blockchain, send transactions, and check account details. You might engage in various transaction types such as sending Algos to another account, rekeying the account (which changes the authoritative private key for the account), or closing the account (transferring all remaining Algos to another account). Each of these actions can be encapsulated within a payment transaction using the Algorand Go SDK.</p>\n    \n    <p>This text should provide a clear, non-code explanation of the key processes involved in using the Algorand Go SDK for creating and managing accounts, as well as performing transactions.</p>\n    \n    <pre class=\"overflow-auto shadow-md\">\n<code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"github.com/algorand/go-algorand-sdk/client/algod\"\n    \"github.com/algorand/go-algorand-sdk/crypto\"\n    \"github.com/algorand/go-algorand-sdk/future\"\n    \"github.com/algorand/go-algorand-sdk/types\"\n)\n\nfunc main() {\n    // Define the Algod client\n    algodToken := \"\"\n    algodAddress := \"https://testnet-api.algonode.cloud\"\n    headers := []*algod.Header{{Key: \"X-API-Key\", Value: algodToken}}\n    algodClient, err := algod.MakeClientWithHeaders(algodAddress, algodToken, headers)\n    if err != nil {\n        fmt.Printf(\"Failed to make algod client: %s\\n\", err)\n        return\n    }\n\n    // Existing account details\n    address := \"I3BHPDWGH63J47JBG2P7RJLOGD3L3HEBOI4KKUKSV3MZSYFX4VFDIDYSMU\"\n    privateKey := \"6KitD65Q7V6ZDB29EEx1YtoBeqy0PDt+78Ga4DchXItGwneOxj+2nn0hNp/4pW4w9r2cgXI4pVFSrtmZYLflSg==\"\n\n    // Convert 1.001 Algo to microAlgos for transaction amount\n    amount := uint64(1.001 * 1e6) // Algos are expressed in microAlgos in the SDK\n\n    // Fetch the suggested transaction parameters\n    txParams, err := algodClient.SuggestedParams().Do(context.Background())\n    if err != nil {\n        fmt.Printf(\"Error getting suggested tx params: %s\\n\", err)\n        return\n    }\n\n    // Generate a new account\n    newAccount := crypto.GenerateAccount()\n    newAccountAddress := newAccount.Address.String()\n    newAccountPrivateKey := newAccount.PrivateKey\n\n    // Create a payment transaction\n    note := []byte(\"Here's your one Algo!\")\n    tx, err := future.MakePaymentTxn(address, newAccountAddress, amount, note, \"\", txParams)\n    if err != nil {\n        fmt.Printf(\"Failed to make transaction: %s\\n\", err)\n        return\n    }\n\n    // Sign the transaction\n    signTx, err := crypto.SignTransaction(privateKey, tx)\n    if err != nil {\n        fmt.Printf(\"Failed to sign transaction: %s\\n\", err)\n        return\n    }\n\n    // Send the transaction\n    sendResponse, err := algodClient.SendRawTransaction(signTx).Do(context.Background())\n    if err != nil {\n        fmt.Printf(\"Failed to send transaction: %s\\n\", err)\n        return\n    }\n\n    // Wait for confirmation\n    confirmedTxn, err := future.WaitForConfirmation(algodClient, sendResponse.TxID, 4, context.Background())\n    if err != nil {\n        fmt.Printf(\"Error waiting for confirmation: %s\\n\", err)\n        return\n    }\n\n    // Print the transaction ID\n    fmt.Printf(\"Transaction confirmed with ID: %s\\n\", confirmedTxn.Txn.Txn.ID)\n}</code>\n    </pre>\n    \n    <p>Steps:</p>\n    <ol class=\"inText\">\n        <li>Import our necessary modules</li>\n        <li>Define our <code>AlgodClient</code> to initiate a connection to the chain</li>\n        <li>Define our account's address and private key that we will be sending transactions from</li>\n        <li>Define an amount of Algorand to send</li>\n        <li>Obtain the params needed for all transactions</li>\n        <li>Generate a new account for testing, so we have an address to send testnet Algorand to</li>\n        <li>Define our payment transaction and its parameters</li>\n        <li>Sign the transaction with our private key</li>\n        <li>Assign the result of sending our signed transaction with the <code>send_transaction()</code> function from the <code>AlgodClient</code> class</li>\n        <li>Use the <code>wait_for_confirmation()</code> function to ensure the transaction is successful</li>\n        <li>Print the transaction ID for reference on an explorer like allo.info, <a href=\"https://testnet.explorer.perawallet.app/\">https://testnet.explorer.perawallet.app/</a>, <a href=\"https://www.blockpack.app/#/explorer/home\">https://www.blockpack.app/#/explorer/home</a>, or <a href=\"https://app.dappflow.org/explorer/home\">https://app.dappflow.org/explorer/home</a></li>\n    </ol>\n    \n    <p>We introduce a few new functions here:</p>\n    <ul class=\"inText\">\n        <li>the <code>algos_to_microalgos()</code> function from the <code>algosdk.util</code> module</li>\n        <li>the <code>PaymentTxn</code> class and <code>wait_for_confirmation()</code> function from the <code>algosdk.transaction</code> module</li>\n        <li>The <code>send_transaction()</code> function, which is a method from the <code>AlgodClient</code> class</li>\n    </ul>\n    \n    <p>In the Algorand SDKs, when we want to reference an amount of Algo, that amount needs to be in a format called \"Microalgo\"; Microalgo is essentially an amount of Algo times 1,000,000. Meaning that 1 Algo would be 1,000,000 Microalgo, and the transaction fee of 0.001 Algo is 1,000 Microalgo.</p>\n    \n    <p>Instead of manually calculating the microalgo amount each time, what we can do is use the <code>algos_to_microalgos()</code> function, and pass in the amount of Algo as an argument.</p>\n    \n    <p>The <code>PaymentTransaction</code> class comes with a lot of functionality, aside from simple payment transactions of an amount of Algo to more advanced features, including:</p>\n    <ul class=\"inText\">\n        <li>the ability to rekey your account to another (giving them full access, and losing your access)</li>\n        <li>closing your account (send all of your remaining Algo to them)</li>\n    </ul>\n    \n    <pre class=\"overflow-auto shadow-md\"><code>PaymentTransaction format:\n\nclass PaymentTxn(\n    sender: str,\n    sp: SuggestedParams,\n    receiver: Any,\n    amt: Any,\n    close_remainder_to: Any | None = None,\n    note: Any | None = None,\n    lease: Any | None = None,\n    rekey_to: Any | None = None\n)\n#Represents a payment transaction.\n\nArgs:\n    sender (str): address of the sender\n    sp (SuggestedParams): suggested params from algod\n    receiver (str): address of the receiver\n    amt (int): amount in microAlgos to be sent\n    close_remainder_to (str, optional): if nonempty, account will be closed and remaining algos will be sent to this address\n    note (bytes, optional): arbitrary optional bytes\n    lease (byte[32], optional): specifies a lease, and no other transaction with the same sender and lease can be confirmed in this transaction's valid rounds\n    rekey_to (str, optional): additionally rekey the sender to this address\n\nAfter we define our <code>Payment Transaction</code> class parameters, we can then use the <code>sign()</code> method that is included within it. This sign function accepts our private key, and outputs a signed transaction object, which is needed to input to the <code>send_transaction()</code> function:\n\n(method) def sign(private_key: Any) -> SignedTransaction\nSign the transaction with a private key.\n\nArgs:\n    private_key (str): the private key of the signing account\n\nReturns:\n    SignedTransaction: signed transaction with the signature</code></pre>\n\nThe <code>wait_for_confirmation()</code> function requires the <code>AlgodClient</code> class variable we created, as well as the transaction ID to wait for:\n\n<pre class=\"overflow-auto shadow-md\"><code>(function) def wait_for_confirmation(\n    algod_client: AlgodClient,\n    txid: str,\n)</code></pre>\n\nLastly, the <code>send_transaction()</code> function, which accepts signed transaction objects\n\n<pre class=\"overflow-auto shadow-md\"><code>(method) def send_transaction(\n    txn: GenericSignedTransaction,\n) -> Outputs transaction ID</code></pre>\n    \n    <p>Below are examples of rekey transactions and close amount to transactions, which are sent in succession (BUT NOT A GROUP TRANSACTION, WHICH WE WILL LEARN ABOUT LATER)</p>\n    \n    <pre class=\"overflow-auto shadow-md\">\n<code># Repeat the process for the Rekey Transaction and the close remainder to transaction\n\n// Rekey Transaction\nrekey_to_new_account_payment = PaymentTxn(\n    sender = address,\n    receiver = new_account_address,\n    sp = params,\n    amt = 0,\n    rekey_to = new_account_address,\n    note = \"Take care of my account for me! I'll be back in a week\"\n)\n\nsigned_rekey_to_new_account_payment = rekey_to_new_account_payment.sign(private_key)\ntransaction_id = algod_client.send_transaction(signed_rekey_to_new_account_payment)\nwait_for_confirmation(algod_client, transaction_id)\nprint(transaction_id)\n\n// New account rekeys back to the original account, note that the sender is the original account but the new account uses their own private key, not the original accounts private key\n\nrekey_back_to_old_account_from_new_account = PaymentTxn(\n    sender = address,\n    receiver = address,\n    sp = params,\n    rekey_to = address,\n    amt = 0,\n    note = \"Sorry! I'm too busy trading this week. Maybe ask PorkChop.algo?\"\n)\n\nsigned_rekey_back_to_old_account_from_new_account = rekey_back_to_old_account_from_new_account.sign(new_account_private_key)\ntransaction_id = algod_client.send_transaction(signed_rekey_back_to_old_account_from_new_account)\nwait_for_confirmation(algod_client, transaction_id)\nprint(transaction_id)\n\n// Close remainder to transaction\n\nclose_account_to_new_account = PaymentTxn(\n    sender = address,\n    receiver = new_account_address,\n    sp = params,\n    amt = 0,\n    close_remainder_to = new_account_address,\n    note = 'Take care of my precious Algo!'\n)\n\nsigned_close_account_to_new_account = close_account_to_new_account.sign(private_key)\ntransaction_id = algod_client.send_transaction(signed_close_account_to_new_account)\nwait_for_confirmation(algod_client, transaction_id)\nprint(transaction_id)</code>\n    </pre>\n    \n    <p>Although the <code>Payment Transaction</code> has many possible inputs, the bare minimum is using the sender, sp, receiver, and amt field. Anything else is at your discretion!</p>\n    \n    <p>DISCLAIMER: that when rekeying and closing out accounts, this process is irreversible! If you don't know the person, or feel unsure about doing so, you should never use these transactions outside of testing purposes without ultimate confidence. No platforms currently utilize rekey transactions for users, but do use them internally when generating smart contracts for contract to contract calls, which will come later in our learning process.</p>\n  \n      <hr><form class=\"quiz-form\">\n    <h1>Quiz</h1>\n  \n          <h3>Question 1</h3>\n          <p>What function is used to generate a new account in the Algorand Go SDK?</p>\n          <input type=\"radio\" id=\"q1a\" name=\"q1\" value=\"a\">\n          <label for=\"q1a\" class=\"correct\">a) crypto.GenerateAccount()</label><br>\n          <input type=\"radio\" id=\"q1b\" name=\"q1\" value=\"b\">\n          <label for=\"q1b\" class=\"incorrect\">b) crypto.NewAccount()</label><br>\n          <input type=\"radio\" id=\"q1c\" name=\"q1\" value=\"c\">\n          <label for=\"q1c\" class=\"incorrect\">c) crypto.CreateAccount()</label><br>\n          <input type=\"radio\" id=\"q1d\" name=\"q1\" value=\"d\">\n          <label for=\"q1d\" class=\"incorrect\">d) crypto.MakeAccount()</label><br>\n  \n          <h3>Question 2</h3>\n          <p>Which function is used to convert a private key to a mnemonic in the Algorand Go SDK?</p>\n          <input type=\"radio\" id=\"q2a\" name=\"q2\" value=\"a\">\n          <label for=\"q2a\" class=\"correct\">a) mnemonic.FromPrivateKey()</label><br>\n          <input type=\"radio\" id=\"q2b\" name=\"q2\" value=\"b\">\n          <label for=\"q2b\" class=\"incorrect\">b) mnemonic.ConvertPrivateKey()</label><br>\n          <input type=\"radio\" id=\"q2c\" name=\"q2\" value=\"c\">\n          <label for=\"q2c\" class=\"incorrect\">c) mnemonic.PrivateKeyToMnemonic()</label><br>\n          <input type=\"radio\" id=\"q2d\" name=\"q2\" value=\"d\">\n          <label for=\"q2d\" class=\"incorrect\">d) mnemonic.KeyToMnemonic()</label><br>\n  \n          <h3>Question 3</h3>\n          <p>How do you convert an amount in Algos to microAlgos in the Algorand Go SDK?</p>\n           <pre class=\"overflow-auto shadow-md\"><code>amount := 1.001\nmicroAlgos := uint64(amount * 1e6)</code></pre>\n          <input type=\"radio\" id=\"q3a\" name=\"q3\" value=\"a\">\n          <label for=\"q3a\" class=\"correct\">a) uint64(amount * 1e6)</label><br>\n          <input type=\"radio\" id=\"q3b\" name=\"q3\" value=\"b\">\n          <label for=\"q3b\" class=\"incorrect\">b) uint64(amount * 1e3)</label><br>\n          <input type=\"radio\" id=\"q3c\" name=\"q3\" value=\"c\">\n          <label for=\"q3c\" class=\"incorrect\">c) uint64(amount * 1e5)</label><br>\n          <input type=\"radio\" id=\"q3d\" name=\"q3\" value=\"d\">\n          <label for=\"q3d\" class=\"incorrect\">d) uint64(amount * 1e4)</label><br>\n  \n          <h3>Question 4</h3>\n          <p>Which function is used to sign a transaction in the Algorand Go SDK?</p>\n          <input type=\"radio\" id=\"q4a\" name=\"q4\" value=\"a\">\n          <label for=\"q4a\" class=\"correct\">a) crypto.SignTransaction()</label><br>\n          <input type=\"radio\" id=\"q4b\" name=\"q4\" value=\"b\">\n          <label for=\"q4b\" class=\"incorrect\">b) crypto.CreateSignedTransaction()</label><br>\n          <input type=\"radio\" id=\"q4c\" name=\"q4\" value=\"c\">\n          <label for=\"q4c\" class=\"incorrect\">c) crypto.GenerateSignedTransaction()</label><br>\n          <input type=\"radio\" id=\"q4d\" name=\"q4\" value=\"d\">\n          <label for=\"q4d\" class=\"incorrect\">d) crypto.MakeSignedTransaction()</label><br>\n  \n          \n      </form>\n    ",
    "initialCode": "package main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/algorand/go-algorand-sdk/client/v2/algod\"\n\t\"github.com/algorand/go-algorand-sdk/crypto\"\n\t\"github.com/algorand/go-algorand-sdk/future\"\n)\n\nfunc main() {\n\t// Testnet algod client setup\n\talgodToken := \"\"\n\talgodServer := \"https://testnet-api.algonode.cloud\"\n\talgodClient, err := algod.MakeClient(algodServer, algodToken)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to create algod client: %s\n\", err)\n\t\treturn\n\t}\n\n\t// Sender account details\n\tsenderAddress := \"YOUR_SENDER_ADDRESS\"\n\tprivateKey := \"YOUR_PRIVATE_KEY\" // Private key of the sender\n\n\t// Receiver account details\n\treceiverAddress := \"RECEIVER_ADDRESS\"\n\n\t// Transaction amount in microAlgos\n\tamount := uint64(1000000) // 1 Algo = 1,000,000 microAlgos\n\n\t// Get suggested transaction parameters\n\ttxParams, err := algodClient.SuggestedParams().Do(context.Background())\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to get suggested transaction params: %s\n\", err)\n\t\treturn\n\t}\n\n\t// Create a payment transaction\n\tnote := []byte(\"Test transaction\")\n\ttx, err := future.MakePaymentTxn(senderAddress, receiverAddress, amount, note, \"\", txParams)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to create payment transaction: %s\n\", err)\n\t\treturn\n\t}\n\n\t// Sign the transaction\n\tsignedTx, err := crypto.SignTransaction(privateKey, tx)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to sign transaction: %s\n\", err)\n\t\treturn\n\t}\n\n\t// Send the transaction\n\tsendResponse, err := algodClient.SendRawTransaction(signedTx).Do(context.Background())\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to send transaction: %s\n\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Transaction sent successfully! TxID: %s\n\", sendResponse)\n}\n\n    "
  }
]